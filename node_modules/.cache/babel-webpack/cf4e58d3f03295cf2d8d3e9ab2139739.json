{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar fs = require('fs');\n\nvar sysPath = require('path');\n\nvar _require = require('util'),\n    promisify = _require.promisify;\n\nvar fsevents;\n\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  var mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n\n  if (mtch && mtch[1] && mtch[2]) {\n    var maj = Number.parseInt(mtch[1], 10);\n    var min = Number.parseInt(mtch[2], 10);\n\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nvar _require2 = require('./constants'),\n    EV_ADD = _require2.EV_ADD,\n    EV_CHANGE = _require2.EV_CHANGE,\n    EV_ADD_DIR = _require2.EV_ADD_DIR,\n    EV_UNLINK = _require2.EV_UNLINK,\n    EV_ERROR = _require2.EV_ERROR,\n    STR_DATA = _require2.STR_DATA,\n    STR_END = _require2.STR_END,\n    FSEVENT_CREATED = _require2.FSEVENT_CREATED,\n    FSEVENT_MODIFIED = _require2.FSEVENT_MODIFIED,\n    FSEVENT_DELETED = _require2.FSEVENT_DELETED,\n    FSEVENT_MOVED = _require2.FSEVENT_MOVED,\n    FSEVENT_UNKNOWN = _require2.FSEVENT_UNKNOWN,\n    FSEVENT_TYPE_FILE = _require2.FSEVENT_TYPE_FILE,\n    FSEVENT_TYPE_DIRECTORY = _require2.FSEVENT_TYPE_DIRECTORY,\n    FSEVENT_TYPE_SYMLINK = _require2.FSEVENT_TYPE_SYMLINK,\n    ROOT_GLOBSTAR = _require2.ROOT_GLOBSTAR,\n    DIR_SUFFIX = _require2.DIR_SUFFIX,\n    DOT_SLASH = _require2.DOT_SLASH,\n    FUNCTION_TYPE = _require2.FUNCTION_TYPE,\n    EMPTY_FN = _require2.EMPTY_FN,\n    IDENTITY_FN = _require2.IDENTITY_FN;\n\nvar Depth = function Depth(value) {\n  return isNaN(value) ? {} : {\n    depth: value\n  };\n};\n\nvar stat = promisify(fs.stat);\nvar lstat = promisify(fs.lstat);\nvar realpath = promisify(fs.realpath);\nvar statMethods = {\n  stat: stat,\n  lstat: lstat\n};\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n// fsevents instance helper functions\n\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\n\nvar FSEventsWatchers = new Map(); // Threshold of duplicate path prefixes at which to start\n// consolidating going forward\n\nvar consolidateThreshhold = 10;\nvar wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\n\nvar createFSEventsInstance = function createFSEventsInstance(path, callback) {\n  var stop = fsevents.watch(path, callback);\n  return {\n    stop: stop\n  };\n};\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\n\n\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  var watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;\n  var parentPath = sysPath.dirname(watchPath);\n  var cont = FSEventsWatchers.get(watchPath); // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  var resolvedPath = sysPath.resolve(path);\n  var hasSymlink = resolvedPath !== realPath;\n\n  var filteredListener = function filteredListener(fullPath, flags, info) {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);\n  }; // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n\n\n  var watchedParent = false;\n\n  var _iterator = _createForOfIteratorHelper(FSEventsWatchers.keys()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var watchedPath = _step.value;\n\n      if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n        watchPath = watchedPath;\n        cont = FSEventsWatchers.get(watchPath);\n        watchedParent = true;\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter: rawEmitter,\n      watcher: createFSEventsInstance(watchPath, function (fullPath, flags) {\n        if (!cont.listeners.size) return;\n        var info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(function (list) {\n          list(fullPath, flags, info);\n        });\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  } // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n\n\n  return function () {\n    var lst = cont.listeners;\n    lst.delete(filteredListener);\n\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(function () {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n} // Decide whether or not we should start a new higher-level\n// parent watcher\n\n\nvar couldConsolidate = function couldConsolidate(path) {\n  var count = 0;\n\n  var _iterator2 = _createForOfIteratorHelper(FSEventsWatchers.keys()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var watchPath = _step2.value;\n\n      if (watchPath.indexOf(path) === 0) {\n        count++;\n\n        if (count >= consolidateThreshhold) {\n          return true;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return false;\n}; // returns boolean indicating whether fsevents can be used\n\n\nvar canUse = function canUse() {\n  return fsevents && FSEventsWatchers.size < 128;\n}; // determines subdirectory traversal levels from root to path\n\n\nvar calcDepth = function calcDepth(path, root) {\n  var i = 0;\n\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) {\n    i++;\n  }\n\n  return i;\n}; // returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\n\n\nvar sameTypes = function sameTypes(info, stats) {\n  return info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();\n};\n/**\n * @mixin\n */\n\n\nvar FsEventsHandler = /*#__PURE__*/function () {\n  /**\n   * @param {import('../index').FSWatcher} fsw\n   */\n  function FsEventsHandler(fsw) {\n    _classCallCheck(this, FsEventsHandler);\n\n    this.fsw = fsw;\n  }\n\n  _createClass(FsEventsHandler, [{\n    key: \"checkIgnored\",\n    value: function checkIgnored(path, stats) {\n      var ipaths = this.fsw._ignoredPaths;\n\n      if (this.fsw._isIgnored(path, stats)) {\n        ipaths.add(path);\n\n        if (stats && stats.isDirectory()) {\n          ipaths.add(path + ROOT_GLOBSTAR);\n        }\n\n        return true;\n      }\n\n      ipaths.delete(path);\n      ipaths.delete(path + ROOT_GLOBSTAR);\n    }\n  }, {\n    key: \"addOrChange\",\n    value: function addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n      var event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n      this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }, {\n    key: \"checkExists\",\n    value: function () {\n      var _checkExists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n        var stats;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return stat(path);\n\n              case 3:\n                stats = _context.sent;\n\n                if (!this.fsw.closed) {\n                  _context.next = 6;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 6:\n                if (sameTypes(info, stats)) {\n                  this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n                } else {\n                  this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n                }\n\n                _context.next = 12;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](0);\n\n                if (_context.t0.code === 'EACCES') {\n                  this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n                } else {\n                  this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n                }\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 9]]);\n      }));\n\n      function checkExists(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {\n        return _checkExists.apply(this, arguments);\n      }\n\n      return checkExists;\n    }()\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n      if (this.fsw.closed || this.checkIgnored(path)) return;\n\n      if (event === EV_UNLINK) {\n        var isDirectory = info.type === FSEVENT_TYPE_DIRECTORY; // suppress unlink events on never before seen files\n\n        if (isDirectory || watchedDir.has(item)) {\n          this.fsw._remove(parent, item, isDirectory);\n        }\n      } else {\n        if (event === EV_ADD) {\n          // track new directories\n          if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n          if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n            // push symlinks back to the top of the stack to get handled\n            var curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;\n            return this._addToFsEvents(path, false, true, curDepth);\n          } // track new paths\n          // (other than symlinks being followed, which will be tracked soon)\n\n\n          this.fsw._getWatchedDir(parent).add(item);\n        }\n        /**\n         * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n         */\n\n\n        var eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n\n        this.fsw._emit(eventName, path);\n\n        if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n      }\n    }\n    /**\n     * Handle symlinks encountered during directory scan\n     * @param {String} watchPath  - file/dir path to be watched with fsevents\n     * @param {String} realPath   - real path (in case of symlinks)\n     * @param {Function} transform  - path transformer\n     * @param {Function} globFilter - path filter in case a glob pattern was provided\n     * @returns {Function} closer for the watcher instance\n    */\n\n  }, {\n    key: \"_watchWithFsEvents\",\n    value: function _watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n      var _this = this;\n\n      if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n      var opts = this.fsw.options;\n\n      var watchCallback = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(fullPath, flags, info) {\n          var path, parent, item, watchedDir, stats;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!_this.fsw.closed) {\n                    _context2.next = 2;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 2:\n                  if (!(opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth)) {\n                    _context2.next = 4;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 4:\n                  path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));\n\n                  if (!(globFilter && !globFilter(path))) {\n                    _context2.next = 7;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 7:\n                  // ensure directories are tracked\n                  parent = sysPath.dirname(path);\n                  item = sysPath.basename(path);\n                  watchedDir = _this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent); // correct for wrong events emitted\n\n                  if (!(wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN)) {\n                    _context2.next = 30;\n                    break;\n                  }\n\n                  if (!(typeof opts.ignored === FUNCTION_TYPE)) {\n                    _context2.next = 27;\n                    break;\n                  }\n\n                  _context2.prev = 12;\n                  _context2.next = 15;\n                  return stat(path);\n\n                case 15:\n                  stats = _context2.sent;\n                  _context2.next = 20;\n                  break;\n\n                case 18:\n                  _context2.prev = 18;\n                  _context2.t0 = _context2[\"catch\"](12);\n\n                case 20:\n                  if (!_this.fsw.closed) {\n                    _context2.next = 22;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 22:\n                  if (!_this.checkIgnored(path, stats)) {\n                    _context2.next = 24;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 24:\n                  if (sameTypes(info, stats)) {\n                    _this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n                  } else {\n                    _this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n                  }\n\n                  _context2.next = 28;\n                  break;\n\n                case 27:\n                  _this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\n                case 28:\n                  _context2.next = 35;\n                  break;\n\n                case 30:\n                  _context2.t1 = info.event;\n                  _context2.next = _context2.t1 === FSEVENT_CREATED ? 33 : _context2.t1 === FSEVENT_MODIFIED ? 33 : _context2.t1 === FSEVENT_DELETED ? 34 : _context2.t1 === FSEVENT_MOVED ? 34 : 35;\n                  break;\n\n                case 33:\n                  return _context2.abrupt(\"return\", _this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts));\n\n                case 34:\n                  return _context2.abrupt(\"return\", _this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts));\n\n                case 35:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[12, 18]]);\n        }));\n\n        return function watchCallback(_x9, _x10, _x11) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      var closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);\n\n      this.fsw._emitReady();\n\n      return closer;\n    }\n    /**\n     * Handle symlinks encountered during directory scan\n     * @param {String} linkPath path to symlink\n     * @param {String} fullPath absolute path to the symlink\n     * @param {Function} transform pre-existing path transformer\n     * @param {Number} curDepth level of subdirectories traversed to where symlink is\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_handleFsEventsSymlink\",\n    value: function () {\n      var _handleFsEventsSymlink2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(linkPath, fullPath, transform, curDepth) {\n        var linkTarget;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                this.fsw._symlinkPaths.set(fullPath, true);\n\n                this.fsw._incrReadyCount();\n\n                _context3.prev = 4;\n                _context3.next = 7;\n                return realpath(linkPath);\n\n              case 7:\n                linkTarget = _context3.sent;\n\n                if (!this.fsw.closed) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 10:\n                if (!this.fsw._isIgnored(linkTarget)) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this.fsw._emitReady());\n\n              case 12:\n                this.fsw._incrReadyCount(); // add the linkTarget for watching with a wrapper for transform\n                // that causes emitted paths to incorporate the link's path\n\n\n                this._addToFsEvents(linkTarget || linkPath, function (path) {\n                  var aliasedPath = linkPath;\n\n                  if (linkTarget && linkTarget !== DOT_SLASH) {\n                    aliasedPath = path.replace(linkTarget, linkPath);\n                  } else if (path !== DOT_SLASH) {\n                    aliasedPath = sysPath.join(linkPath, path);\n                  }\n\n                  return transform(aliasedPath);\n                }, false, curDepth);\n\n                _context3.next = 20;\n                break;\n\n              case 16:\n                _context3.prev = 16;\n                _context3.t0 = _context3[\"catch\"](4);\n\n                if (!this.fsw._handleError(_context3.t0)) {\n                  _context3.next = 20;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this.fsw._emitReady());\n\n              case 20:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[4, 16]]);\n      }));\n\n      function _handleFsEventsSymlink(_x12, _x13, _x14, _x15) {\n        return _handleFsEventsSymlink2.apply(this, arguments);\n      }\n\n      return _handleFsEventsSymlink;\n    }()\n    /**\n     *\n     * @param {Path} newPath\n     * @param {fs.Stats} stats\n     */\n\n  }, {\n    key: \"emitAdd\",\n    value: function emitAdd(newPath, stats, processPath, opts, forceAdd) {\n      var pp = processPath(newPath);\n      var isDir = stats.isDirectory();\n\n      var dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n\n      var base = sysPath.basename(pp); // ensure empty dirs get tracked\n\n      if (isDir) this.fsw._getWatchedDir(pp);\n      if (dirObj.has(base)) return;\n      dirObj.add(base);\n\n      if (!opts.ignoreInitial || forceAdd === true) {\n        this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n      }\n    }\n  }, {\n    key: \"initWatch\",\n    value: function initWatch(realPath, path, wh, processPath) {\n      if (this.fsw.closed) return;\n\n      var closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n\n      this.fsw._addPathCloser(path, closer);\n    }\n    /**\n     * Handle added path with fsevents\n     * @param {String} path file/dir path or glob pattern\n     * @param {Function|Boolean=} transform converts working path to what the user expects\n     * @param {Boolean=} forceAdd ensure add is emitted\n     * @param {Number=} priorDepth Level of subdirectories already traversed.\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_addToFsEvents\",\n    value: function () {\n      var _addToFsEvents2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(path, transform, forceAdd, priorDepth) {\n        var _this2 = this;\n\n        var opts, processPath, wh, stats, realPath;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this.fsw.closed) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                opts = this.fsw.options;\n                processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n                wh = this.fsw._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch\n\n                _context4.prev = 5;\n                _context4.next = 8;\n                return statMethods[wh.statMethod](wh.watchPath);\n\n              case 8:\n                stats = _context4.sent;\n\n                if (!this.fsw.closed) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 11:\n                if (!this.fsw._isIgnored(wh.watchPath, stats)) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                throw null;\n\n              case 13:\n                if (!stats.isDirectory()) {\n                  _context4.next = 20;\n                  break;\n                }\n\n                // emit addDir unless this is a glob parent\n                if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd); // don't recurse further if it would exceed depth setting\n\n                if (!(priorDepth && priorDepth > opts.depth)) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 17:\n                // scan the contents of the dir\n                this.fsw._readdirp(wh.watchPath, _objectSpread({\n                  fileFilter: function fileFilter(entry) {\n                    return wh.filterPath(entry);\n                  },\n                  directoryFilter: function directoryFilter(entry) {\n                    return wh.filterDir(entry);\n                  }\n                }, Depth(opts.depth - (priorDepth || 0)))).on(STR_DATA, function (entry) {\n                  // need to check filterPath on dirs b/c filterDir is less restrictive\n                  if (_this2.fsw.closed) {\n                    return;\n                  }\n\n                  if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n                  var joinedPath = sysPath.join(wh.watchPath, entry.path);\n                  var fullPath = entry.fullPath;\n\n                  if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n                    // preserve the current depth here since it can't be derived from\n                    // real paths past the symlink\n                    var curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n                    _this2._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n                  } else {\n                    _this2.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n                  }\n                }).on(EV_ERROR, EMPTY_FN).on(STR_END, function () {\n                  _this2.fsw._emitReady();\n                });\n\n                _context4.next = 22;\n                break;\n\n              case 20:\n                this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n\n                this.fsw._emitReady();\n\n              case 22:\n                _context4.next = 27;\n                break;\n\n              case 24:\n                _context4.prev = 24;\n                _context4.t0 = _context4[\"catch\"](5);\n\n                if (!_context4.t0 || this.fsw._handleError(_context4.t0)) {\n                  // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n                  this.fsw._emitReady();\n\n                  this.fsw._emitReady();\n                }\n\n              case 27:\n                if (!(opts.persistent && forceAdd !== true)) {\n                  _context4.next = 41;\n                  break;\n                }\n\n                if (!(typeof transform === FUNCTION_TYPE)) {\n                  _context4.next = 32;\n                  break;\n                }\n\n                // realpath has already been resolved\n                this.initWatch(undefined, path, wh, processPath);\n                _context4.next = 41;\n                break;\n\n              case 32:\n                _context4.prev = 32;\n                _context4.next = 35;\n                return realpath(wh.watchPath);\n\n              case 35:\n                realPath = _context4.sent;\n                _context4.next = 40;\n                break;\n\n              case 38:\n                _context4.prev = 38;\n                _context4.t1 = _context4[\"catch\"](32);\n\n              case 40:\n                this.initWatch(realPath, path, wh, processPath);\n\n              case 41:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[5, 24], [32, 38]]);\n      }));\n\n      function _addToFsEvents(_x16, _x17, _x18, _x19) {\n        return _addToFsEvents2.apply(this, arguments);\n      }\n\n      return _addToFsEvents;\n    }()\n  }]);\n\n  return FsEventsHandler;\n}();\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/chokidar/lib/fsevents-handler.js"],"names":["fs","require","sysPath","promisify","fsevents","error","process","env","CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR","console","mtch","version","match","maj","Number","parseInt","min","undefined","EV_ADD","EV_CHANGE","EV_ADD_DIR","EV_UNLINK","EV_ERROR","STR_DATA","STR_END","FSEVENT_CREATED","FSEVENT_MODIFIED","FSEVENT_DELETED","FSEVENT_MOVED","FSEVENT_UNKNOWN","FSEVENT_TYPE_FILE","FSEVENT_TYPE_DIRECTORY","FSEVENT_TYPE_SYMLINK","ROOT_GLOBSTAR","DIR_SUFFIX","DOT_SLASH","FUNCTION_TYPE","EMPTY_FN","IDENTITY_FN","Depth","value","isNaN","depth","stat","lstat","realpath","statMethods","FSEventsWatchers","Map","consolidateThreshhold","wrongEventFlags","Set","createFSEventsInstance","path","callback","stop","watch","setFSEventsListener","realPath","listener","rawEmitter","watchPath","extname","dirname","parentPath","cont","get","couldConsolidate","resolvedPath","resolve","hasSymlink","filteredListener","fullPath","flags","info","replace","indexOf","sep","watchedParent","keys","watchedPath","listeners","add","watcher","size","getInfo","forEach","list","event","set","lst","delete","then","Object","freeze","count","canUse","calcDepth","root","i","sameTypes","stats","type","isDirectory","isSymbolicLink","isFile","FsEventsHandler","fsw","ipaths","_ignoredPaths","_isIgnored","parent","watchedDir","item","opts","has","handleEvent","closed","addOrChange","code","checkIgnored","_remove","_getWatchedDir","followSymlinks","curDepth","_addToFsEvents","eventName","_emit","transform","globFilter","options","watchCallback","join","relative","basename","ignored","checkExists","closer","_emitRaw","_emitReady","linkPath","_symlinkPaths","_incrReadyCount","linkTarget","aliasedPath","_handleError","newPath","processPath","forceAdd","pp","isDir","dirObj","base","ignoreInitial","wh","_watchWithFsEvents","_addPathCloser","priorDepth","_getWatchHelpers","statMethod","emitAdd","_readdirp","fileFilter","entry","filterPath","directoryFilter","filterDir","on","joinedPath","_handleFsEventsSymlink","persistent","initWatch","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\n\nlet fsevents;\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD,\n  EV_CHANGE,\n  EV_ADD_DIR,\n  EV_UNLINK,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN,\n  IDENTITY_FN\n} = require('./constants');\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\nconst statMethods = { stat, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;\n\n  const parentPath = sysPath.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n)\n\n/**\n * @mixin\n */\nclass FsEventsHandler {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat(path)\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath.join(\n      watchPath, sysPath.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath.dirname(path);\n    const item = sysPath.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE) {\n        let stats;\n        try {\n          stats = await stat(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n  const base = sysPath.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n}\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;\n"]},"metadata":{},"sourceType":"script"}