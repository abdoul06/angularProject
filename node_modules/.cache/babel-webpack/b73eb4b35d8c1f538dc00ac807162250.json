{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/imports/src/alias\", [\"require\", \"exports\", \"@angular/compiler\", \"@angular/compiler-cli/src/ngtsc/imports/src/emitter\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.AliasStrategy = exports.PrivateExportAliasingHost = exports.UnifiedModulesAliasingHost = void 0;\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var emitter_1 = require(\"@angular/compiler-cli/src/ngtsc/imports/src/emitter\"); // Escape anything that isn't alphanumeric, '/' or '_'.\n\n\n  var CHARS_TO_ESCAPE = /[^a-zA-Z0-9/_]/g;\n  /**\n   * An `AliasingHost` which generates and consumes alias re-exports when module names for each file\n   * are determined by a `UnifiedModulesHost`.\n   *\n   * When using a `UnifiedModulesHost`, aliasing prevents issues with transitive dependencies. See the\n   * README.md for more details.\n   */\n\n  var UnifiedModulesAliasingHost =\n  /** @class */\n  function () {\n    function UnifiedModulesAliasingHost(unifiedModulesHost) {\n      this.unifiedModulesHost = unifiedModulesHost;\n      /**\n       * With a `UnifiedModulesHost`, aliases are chosen automatically without the need to look through\n       * the exports present in a .d.ts file, so we can avoid cluttering the .d.ts files.\n       */\n\n      this.aliasExportsInDts = false;\n    }\n\n    UnifiedModulesAliasingHost.prototype.maybeAliasSymbolAs = function (ref, context, ngModuleName, isReExport) {\n      if (!isReExport) {\n        // Aliasing is used with a UnifiedModulesHost to prevent transitive dependencies. Thus,\n        // aliases\n        // only need to be created for directives/pipes which are not direct declarations of an\n        // NgModule which exports them.\n        return null;\n      }\n\n      return this.aliasName(ref.node, context);\n    };\n    /**\n     * Generates an `Expression` to import `decl` from `via`, assuming an export was added when `via`\n     * was compiled per `maybeAliasSymbolAs` above.\n     */\n\n\n    UnifiedModulesAliasingHost.prototype.getAliasIn = function (decl, via, isReExport) {\n      if (!isReExport) {\n        // Directly exported directives/pipes don't require an alias, per the logic in\n        // `maybeAliasSymbolAs`.\n        return null;\n      } // viaModule is the module it'll actually be imported from.\n\n\n      var moduleName = this.unifiedModulesHost.fileNameToModuleName(via.fileName, via.fileName);\n      return new compiler_1.ExternalExpr({\n        moduleName: moduleName,\n        name: this.aliasName(decl, via)\n      });\n    };\n    /**\n     * Generates an alias name based on the full module name of the file which declares the aliased\n     * directive/pipe.\n     */\n\n\n    UnifiedModulesAliasingHost.prototype.aliasName = function (decl, context) {\n      // The declared module is used to get the name of the alias.\n      var declModule = this.unifiedModulesHost.fileNameToModuleName(decl.getSourceFile().fileName, context.fileName);\n      var replaced = declModule.replace(CHARS_TO_ESCAPE, '_').replace(/\\//g, '$');\n      return 'ɵng$' + replaced + '$$' + decl.name.text;\n    };\n\n    return UnifiedModulesAliasingHost;\n  }();\n\n  exports.UnifiedModulesAliasingHost = UnifiedModulesAliasingHost;\n  /**\n   * An `AliasingHost` which exports directives from any file containing an NgModule in which they're\n   * declared/exported, under a private symbol name.\n   *\n   * These exports support cases where an NgModule is imported deeply from an absolute module path\n   * (that is, it's not part of an Angular Package Format entrypoint), and the compiler needs to\n   * import any matched directives/pipes from the same path (to the NgModule file). See README.md for\n   * more details.\n   */\n\n  var PrivateExportAliasingHost =\n  /** @class */\n  function () {\n    function PrivateExportAliasingHost(host) {\n      this.host = host;\n      /**\n       * Under private export aliasing, the `AbsoluteModuleStrategy` used for emitting references will\n       * will select aliased exports that it finds in the .d.ts file for an NgModule's file. Thus,\n       * emitting these exports in .d.ts is a requirement for the `PrivateExportAliasingHost` to\n       * function correctly.\n       */\n\n      this.aliasExportsInDts = true;\n    }\n\n    PrivateExportAliasingHost.prototype.maybeAliasSymbolAs = function (ref, context, ngModuleName) {\n      if (ref.hasOwningModuleGuess) {\n        // Skip nodes that already have an associated absolute module specifier, since they can be\n        // safely imported from that specifier.\n        return null;\n      } // Look for a user-provided export of `decl` in `context`. If one exists, then an alias export\n      // is not needed.\n      // TODO(alxhub): maybe add a host method to check for the existence of an export without going\n      // through the entire list of exports.\n\n\n      var exports = this.host.getExportsOfModule(context);\n\n      if (exports === null) {\n        // Something went wrong, and no exports were available at all. Bail rather than risk creating\n        // re-exports when they're not needed.\n        throw new Error(\"Could not determine the exports of: \" + context.fileName);\n      }\n\n      var found = false;\n      exports.forEach(function (value) {\n        if (value.node === ref.node) {\n          found = true;\n        }\n      });\n\n      if (found) {\n        // The module exports the declared class directly, no alias is necessary.\n        return null;\n      }\n\n      return \"\\u0275ngExport\\u0275\" + ngModuleName + \"\\u0275\" + ref.node.name.text;\n    };\n    /**\n     * A `PrivateExportAliasingHost` only generates re-exports and does not direct the compiler to\n     * directly consume the aliases it creates.\n     *\n     * Instead, they're consumed indirectly: `AbsoluteModuleStrategy` `ReferenceEmitterStrategy` will\n     * select these alias exports automatically when looking for an export of the directive/pipe from\n     * the same path as the NgModule was imported.\n     *\n     * Thus, `getAliasIn` always returns `null`.\n     */\n\n\n    PrivateExportAliasingHost.prototype.getAliasIn = function () {\n      return null;\n    };\n\n    return PrivateExportAliasingHost;\n  }();\n\n  exports.PrivateExportAliasingHost = PrivateExportAliasingHost;\n  /**\n   * A `ReferenceEmitStrategy` which will consume the alias attached to a particular `Reference` to a\n   * directive or pipe, if it exists.\n   */\n\n  var AliasStrategy =\n  /** @class */\n  function () {\n    function AliasStrategy() {}\n\n    AliasStrategy.prototype.emit = function (ref, context, importMode) {\n      if (importMode & emitter_1.ImportFlags.NoAliasing || ref.alias === null) {\n        return null;\n      }\n\n      return {\n        expression: ref.alias,\n        importedFile: 'unknown'\n      };\n    };\n\n    return AliasStrategy;\n  }();\n\n  exports.AliasStrategy = AliasStrategy;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/imports/src/alias.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, ExternalExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {UnifiedModulesHost} from '../../core/api';\nimport {ClassDeclaration, ReflectionHost} from '../../reflection';\n\nimport {EmittedReference, ImportFlags, ReferenceEmitStrategy} from './emitter';\nimport {Reference} from './references';\n\n\n// Escape anything that isn't alphanumeric, '/' or '_'.\nconst CHARS_TO_ESCAPE = /[^a-zA-Z0-9/_]/g;\n\n/**\n * A host for the aliasing system, which allows for alternative exports/imports of directives/pipes.\n *\n * Given an import of an NgModule (e.g. `CommonModule`), the compiler must generate imports to the\n * directives and pipes exported by this module (e.g. `NgIf`) when they're used in a particular\n * template. In its default configuration, if the compiler is not directly able to import the\n * component from another file within the same project, it will attempt to import the component\n * from the same (absolute) path by which the module was imported. So in the above example if\n * `CommonModule` was imported from '@angular/common', the compiler will attempt to import `NgIf`\n * from '@angular/common' as well.\n *\n * The aliasing system interacts with the above logic in two distinct ways.\n *\n * 1) It can be used to create \"alias\" re-exports from different files, which can be used when the\n *    user hasn't exported the directive(s) from the ES module containing the NgModule. These re-\n *    exports can also be helpful when using a `UnifiedModulesHost`, which overrides the import\n *    logic described above.\n *\n * 2) It can be used to get an alternative import expression for a directive or pipe, instead of\n *    the import that the normal logic would apply. The alias used depends on the provenance of the\n *    `Reference` which was obtained for the directive/pipe, which is usually a property of how it\n *    came to be in a template's scope (e.g. by which NgModule).\n *\n * See the README.md for more information on how aliasing works within the compiler.\n */\nexport interface AliasingHost {\n  /**\n   * Controls whether any alias re-exports are rendered into .d.ts files.\n   *\n   * This is not always necessary for aliasing to function correctly, so this flag allows an\n   * `AliasingHost` to avoid cluttering the .d.ts files if exports are not strictly needed.\n   */\n  readonly aliasExportsInDts: boolean;\n\n  /**\n   * Determine a name by which `decl` should be re-exported from `context`, depending on the\n   * particular set of aliasing rules in place.\n   *\n   * `maybeAliasSymbolAs` can return `null`, in which case no alias export should be generated.\n   *\n   * @param ref a `Reference` to the directive/pipe to consider for aliasing.\n   * @param context the `ts.SourceFile` in which the alias re-export might need to be generated.\n   * @param ngModuleName the declared name of the `NgModule` within `context` for which the alias\n   * would be generated.\n   * @param isReExport whether the directive/pipe under consideration is re-exported from another\n   * NgModule (as opposed to being declared by it directly).\n   */\n  maybeAliasSymbolAs(\n      ref: Reference<ClassDeclaration>, context: ts.SourceFile, ngModuleName: string,\n      isReExport: boolean): string|null;\n\n  /**\n   * Determine an `Expression` by which `decl` should be imported from `via` using an alias export\n   * (which should have been previously created when compiling `via`).\n   *\n   * `getAliasIn` can return `null`, in which case no alias is needed to import `decl` from `via`\n   * (and the normal import rules should be used).\n   *\n   * @param decl the declaration of the directive/pipe which is being imported, and which might be\n   * aliased.\n   * @param via the `ts.SourceFile` which might contain an alias to the\n   */\n  getAliasIn(decl: ClassDeclaration, via: ts.SourceFile, isReExport: boolean): Expression|null;\n}\n\n/**\n * An `AliasingHost` which generates and consumes alias re-exports when module names for each file\n * are determined by a `UnifiedModulesHost`.\n *\n * When using a `UnifiedModulesHost`, aliasing prevents issues with transitive dependencies. See the\n * README.md for more details.\n */\nexport class UnifiedModulesAliasingHost implements AliasingHost {\n  constructor(private unifiedModulesHost: UnifiedModulesHost) {}\n\n  /**\n   * With a `UnifiedModulesHost`, aliases are chosen automatically without the need to look through\n   * the exports present in a .d.ts file, so we can avoid cluttering the .d.ts files.\n   */\n  readonly aliasExportsInDts = false;\n\n  maybeAliasSymbolAs(\n      ref: Reference<ClassDeclaration>, context: ts.SourceFile, ngModuleName: string,\n      isReExport: boolean): string|null {\n    if (!isReExport) {\n      // Aliasing is used with a UnifiedModulesHost to prevent transitive dependencies. Thus,\n      // aliases\n      // only need to be created for directives/pipes which are not direct declarations of an\n      // NgModule which exports them.\n      return null;\n    }\n    return this.aliasName(ref.node, context);\n  }\n\n  /**\n   * Generates an `Expression` to import `decl` from `via`, assuming an export was added when `via`\n   * was compiled per `maybeAliasSymbolAs` above.\n   */\n  getAliasIn(decl: ClassDeclaration, via: ts.SourceFile, isReExport: boolean): Expression|null {\n    if (!isReExport) {\n      // Directly exported directives/pipes don't require an alias, per the logic in\n      // `maybeAliasSymbolAs`.\n      return null;\n    }\n    // viaModule is the module it'll actually be imported from.\n    const moduleName = this.unifiedModulesHost.fileNameToModuleName(via.fileName, via.fileName);\n    return new ExternalExpr({moduleName, name: this.aliasName(decl, via)});\n  }\n\n  /**\n   * Generates an alias name based on the full module name of the file which declares the aliased\n   * directive/pipe.\n   */\n  private aliasName(decl: ClassDeclaration, context: ts.SourceFile): string {\n    // The declared module is used to get the name of the alias.\n    const declModule = this.unifiedModulesHost.fileNameToModuleName(\n        decl.getSourceFile().fileName, context.fileName);\n\n    const replaced = declModule.replace(CHARS_TO_ESCAPE, '_').replace(/\\//g, '$');\n    return 'ɵng$' + replaced + '$$' + decl.name.text;\n  }\n}\n\n/**\n * An `AliasingHost` which exports directives from any file containing an NgModule in which they're\n * declared/exported, under a private symbol name.\n *\n * These exports support cases where an NgModule is imported deeply from an absolute module path\n * (that is, it's not part of an Angular Package Format entrypoint), and the compiler needs to\n * import any matched directives/pipes from the same path (to the NgModule file). See README.md for\n * more details.\n */\nexport class PrivateExportAliasingHost implements AliasingHost {\n  constructor(private host: ReflectionHost) {}\n\n  /**\n   * Under private export aliasing, the `AbsoluteModuleStrategy` used for emitting references will\n   * will select aliased exports that it finds in the .d.ts file for an NgModule's file. Thus,\n   * emitting these exports in .d.ts is a requirement for the `PrivateExportAliasingHost` to\n   * function correctly.\n   */\n  readonly aliasExportsInDts = true;\n\n  maybeAliasSymbolAs(\n      ref: Reference<ClassDeclaration>, context: ts.SourceFile, ngModuleName: string): string|null {\n    if (ref.hasOwningModuleGuess) {\n      // Skip nodes that already have an associated absolute module specifier, since they can be\n      // safely imported from that specifier.\n      return null;\n    }\n    // Look for a user-provided export of `decl` in `context`. If one exists, then an alias export\n    // is not needed.\n    // TODO(alxhub): maybe add a host method to check for the existence of an export without going\n    // through the entire list of exports.\n    const exports = this.host.getExportsOfModule(context);\n    if (exports === null) {\n      // Something went wrong, and no exports were available at all. Bail rather than risk creating\n      // re-exports when they're not needed.\n      throw new Error(`Could not determine the exports of: ${context.fileName}`);\n    }\n    let found: boolean = false;\n    exports.forEach(value => {\n      if (value.node === ref.node) {\n        found = true;\n      }\n    });\n    if (found) {\n      // The module exports the declared class directly, no alias is necessary.\n      return null;\n    }\n    return `ɵngExportɵ${ngModuleName}ɵ${ref.node.name.text}`;\n  }\n\n  /**\n   * A `PrivateExportAliasingHost` only generates re-exports and does not direct the compiler to\n   * directly consume the aliases it creates.\n   *\n   * Instead, they're consumed indirectly: `AbsoluteModuleStrategy` `ReferenceEmitterStrategy` will\n   * select these alias exports automatically when looking for an export of the directive/pipe from\n   * the same path as the NgModule was imported.\n   *\n   * Thus, `getAliasIn` always returns `null`.\n   */\n  getAliasIn(): null {\n    return null;\n  }\n}\n\n/**\n * A `ReferenceEmitStrategy` which will consume the alias attached to a particular `Reference` to a\n * directive or pipe, if it exists.\n */\nexport class AliasStrategy implements ReferenceEmitStrategy {\n  emit(ref: Reference, context: ts.SourceFile, importMode: ImportFlags): EmittedReference|null {\n    if (importMode & ImportFlags.NoAliasing || ref.alias === null) {\n      return null;\n    }\n\n    return {expression: ref.alias, importedFile: 'unknown'};\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}