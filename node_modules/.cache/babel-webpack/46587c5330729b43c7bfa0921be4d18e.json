{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/view/i18n/util\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/i18n/i18n_ast\", \"@angular/compiler/src/i18n/serializers/xmb\", \"@angular/compiler/src/output/output_ast\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.declareI18nVariable = exports.getTranslationConstPrefix = exports.formatI18nPlaceholderName = exports.i18nFormatPlaceholderNames = exports.assembleBoundTextPlaceholders = exports.updatePlaceholderMap = exports.placeholdersToParams = exports.getSeqNumberGenerator = exports.assembleI18nBoundString = exports.wrapI18nPlaceholder = exports.icuFromI18nMessage = exports.hasI18nAttrs = exports.hasI18nMeta = exports.isSingleI18nIcu = exports.isI18nRootNode = exports.isI18nAttribute = exports.I18N_PLACEHOLDER_SYMBOL = exports.I18N_ICU_MAPPING_PREFIX = exports.I18N_ICU_VAR_PREFIX = exports.I18N_ATTR_PREFIX = exports.I18N_ATTR = exports.TRANSLATION_VAR_PREFIX = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var i18n = require(\"@angular/compiler/src/i18n/i18n_ast\");\n\n  var xmb_1 = require(\"@angular/compiler/src/i18n/serializers/xmb\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n  /* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\n\n\n  var CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\n  /**\n   * Prefix for non-`goog.getMsg` i18n-related vars.\n   * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\n   * considers variables like `I18N_0` as constants and throws an error when their value changes.\n   */\n\n  exports.TRANSLATION_VAR_PREFIX = 'i18n_';\n  /** Name of the i18n attributes **/\n\n  exports.I18N_ATTR = 'i18n';\n  exports.I18N_ATTR_PREFIX = 'i18n-';\n  /** Prefix of var expressions used in ICUs */\n\n  exports.I18N_ICU_VAR_PREFIX = 'VAR_';\n  /** Prefix of ICU expressions for post processing */\n\n  exports.I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n  /** Placeholder wrapper for i18n expressions **/\n\n  exports.I18N_PLACEHOLDER_SYMBOL = '�';\n\n  function isI18nAttribute(name) {\n    return name === exports.I18N_ATTR || name.startsWith(exports.I18N_ATTR_PREFIX);\n  }\n\n  exports.isI18nAttribute = isI18nAttribute;\n\n  function isI18nRootNode(meta) {\n    return meta instanceof i18n.Message;\n  }\n\n  exports.isI18nRootNode = isI18nRootNode;\n\n  function isSingleI18nIcu(meta) {\n    return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof i18n.Icu;\n  }\n\n  exports.isSingleI18nIcu = isSingleI18nIcu;\n\n  function hasI18nMeta(node) {\n    return !!node.i18n;\n  }\n\n  exports.hasI18nMeta = hasI18nMeta;\n\n  function hasI18nAttrs(element) {\n    return element.attrs.some(function (attr) {\n      return isI18nAttribute(attr.name);\n    });\n  }\n\n  exports.hasI18nAttrs = hasI18nAttrs;\n\n  function icuFromI18nMessage(message) {\n    return message.nodes[0];\n  }\n\n  exports.icuFromI18nMessage = icuFromI18nMessage;\n\n  function wrapI18nPlaceholder(content, contextId) {\n    if (contextId === void 0) {\n      contextId = 0;\n    }\n\n    var blockId = contextId > 0 ? \":\" + contextId : '';\n    return \"\" + exports.I18N_PLACEHOLDER_SYMBOL + content + blockId + exports.I18N_PLACEHOLDER_SYMBOL;\n  }\n\n  exports.wrapI18nPlaceholder = wrapI18nPlaceholder;\n\n  function assembleI18nBoundString(strings, bindingStartIndex, contextId) {\n    if (bindingStartIndex === void 0) {\n      bindingStartIndex = 0;\n    }\n\n    if (contextId === void 0) {\n      contextId = 0;\n    }\n\n    if (!strings.length) return '';\n    var acc = '';\n    var lastIdx = strings.length - 1;\n\n    for (var i = 0; i < lastIdx; i++) {\n      acc += \"\" + strings[i] + wrapI18nPlaceholder(bindingStartIndex + i, contextId);\n    }\n\n    acc += strings[lastIdx];\n    return acc;\n  }\n\n  exports.assembleI18nBoundString = assembleI18nBoundString;\n\n  function getSeqNumberGenerator(startsAt) {\n    if (startsAt === void 0) {\n      startsAt = 0;\n    }\n\n    var current = startsAt;\n    return function () {\n      return current++;\n    };\n  }\n\n  exports.getSeqNumberGenerator = getSeqNumberGenerator;\n\n  function placeholdersToParams(placeholders) {\n    var params = {};\n    placeholders.forEach(function (values, key) {\n      params[key] = o.literal(values.length > 1 ? \"[\" + values.join('|') + \"]\" : values[0]);\n    });\n    return params;\n  }\n\n  exports.placeholdersToParams = placeholdersToParams;\n\n  function updatePlaceholderMap(map, name) {\n    var values = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      values[_i - 2] = arguments[_i];\n    }\n\n    var current = map.get(name) || [];\n    current.push.apply(current, tslib_1.__spread(values));\n    map.set(name, current);\n  }\n\n  exports.updatePlaceholderMap = updatePlaceholderMap;\n\n  function assembleBoundTextPlaceholders(meta, bindingStartIndex, contextId) {\n    if (bindingStartIndex === void 0) {\n      bindingStartIndex = 0;\n    }\n\n    if (contextId === void 0) {\n      contextId = 0;\n    }\n\n    var startIdx = bindingStartIndex;\n    var placeholders = new Map();\n    var node = meta instanceof i18n.Message ? meta.nodes.find(function (node) {\n      return node instanceof i18n.Container;\n    }) : meta;\n\n    if (node) {\n      node.children.filter(function (child) {\n        return child instanceof i18n.Placeholder;\n      }).forEach(function (child, idx) {\n        var content = wrapI18nPlaceholder(startIdx + idx, contextId);\n        updatePlaceholderMap(placeholders, child.name, content);\n      });\n    }\n\n    return placeholders;\n  }\n\n  exports.assembleBoundTextPlaceholders = assembleBoundTextPlaceholders;\n  /**\n   * Format the placeholder names in a map of placeholders to expressions.\n   *\n   * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\n   * format (e.g. `startTagDiv_1`).\n   *\n   * @param params A map of placeholder names to expressions.\n   * @param useCamelCase whether to camelCase the placeholder name when formatting.\n   * @returns A new map of formatted placeholder names to expressions.\n   */\n\n  function i18nFormatPlaceholderNames(params, useCamelCase) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    var _params = {};\n\n    if (params && Object.keys(params).length) {\n      Object.keys(params).forEach(function (key) {\n        return _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key];\n      });\n    }\n\n    return _params;\n  }\n\n  exports.i18nFormatPlaceholderNames = i18nFormatPlaceholderNames;\n  /**\n   * Converts internal placeholder names to public-facing format\n   * (for example to use in goog.getMsg call).\n   * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n   *\n   * @param name The placeholder name that should be formatted\n   * @returns Formatted placeholder name\n   */\n\n  function formatI18nPlaceholderName(name, useCamelCase) {\n    if (useCamelCase === void 0) {\n      useCamelCase = true;\n    }\n\n    var publicName = xmb_1.toPublicName(name);\n\n    if (!useCamelCase) {\n      return publicName;\n    }\n\n    var chunks = publicName.split('_');\n\n    if (chunks.length === 1) {\n      // if no \"_\" found - just lowercase the value\n      return name.toLowerCase();\n    }\n\n    var postfix; // eject last element if it's a number\n\n    if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n      postfix = chunks.pop();\n    }\n\n    var raw = chunks.shift().toLowerCase();\n\n    if (chunks.length) {\n      raw += chunks.map(function (c) {\n        return c.charAt(0).toUpperCase() + c.slice(1).toLowerCase();\n      }).join('');\n    }\n\n    return postfix ? raw + \"_\" + postfix : raw;\n  }\n\n  exports.formatI18nPlaceholderName = formatI18nPlaceholderName;\n  /**\n   * Generates a prefix for translation const name.\n   *\n   * @param extra Additional local prefix that should be injected into translation var name\n   * @returns Complete translation const prefix\n   */\n\n  function getTranslationConstPrefix(extra) {\n    return (\"\" + CLOSURE_TRANSLATION_VAR_PREFIX + extra).toUpperCase();\n  }\n\n  exports.getTranslationConstPrefix = getTranslationConstPrefix;\n  /**\n   * Generate AST to declare a variable. E.g. `var I18N_1;`.\n   * @param variable the name of the variable to declare.\n   */\n\n  function declareI18nVariable(variable) {\n    return new o.DeclareVarStmt(variable.name, undefined, o.INFERRED_TYPE, undefined, variable.sourceSpan);\n  }\n\n  exports.declareI18nVariable = declareI18nVariable;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler/src/render3/view/i18n/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {toPublicName} from '../../../i18n/serializers/xmb';\nimport * as html from '../../../ml_parser/ast';\nimport * as o from '../../../output/output_ast';\nimport * as t from '../../r3_ast';\n\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\n\n/**\n * Prefix for non-`goog.getMsg` i18n-related vars.\n * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\n * considers variables like `I18N_0` as constants and throws an error when their value changes.\n */\nexport const TRANSLATION_VAR_PREFIX = 'i18n_';\n\n/** Name of the i18n attributes **/\nexport const I18N_ATTR = 'i18n';\nexport const I18N_ATTR_PREFIX = 'i18n-';\n\n/** Prefix of var expressions used in ICUs */\nexport const I18N_ICU_VAR_PREFIX = 'VAR_';\n\n/** Prefix of ICU expressions for post processing */\nexport const I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n\n/** Placeholder wrapper for i18n expressions **/\nexport const I18N_PLACEHOLDER_SYMBOL = '�';\n\nexport function isI18nAttribute(name: string): boolean {\n  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\n\nexport function isI18nRootNode(meta?: i18n.I18nMeta): meta is i18n.Message {\n  return meta instanceof i18n.Message;\n}\n\nexport function isSingleI18nIcu(meta?: i18n.I18nMeta): boolean {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof i18n.Icu;\n}\n\nexport function hasI18nMeta(node: t.Node&{i18n?: i18n.I18nMeta}): boolean {\n  return !!node.i18n;\n}\n\nexport function hasI18nAttrs(element: html.Element): boolean {\n  return element.attrs.some((attr: html.Attribute) => isI18nAttribute(attr.name));\n}\n\nexport function icuFromI18nMessage(message: i18n.Message) {\n  return message.nodes[0] as i18n.IcuPlaceholder;\n}\n\nexport function wrapI18nPlaceholder(content: string|number, contextId: number = 0): string {\n  const blockId = contextId > 0 ? `:${contextId}` : '';\n  return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;\n}\n\nexport function assembleI18nBoundString(\n    strings: string[], bindingStartIndex: number = 0, contextId: number = 0): string {\n  if (!strings.length) return '';\n  let acc = '';\n  const lastIdx = strings.length - 1;\n  for (let i = 0; i < lastIdx; i++) {\n    acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;\n  }\n  acc += strings[lastIdx];\n  return acc;\n}\n\nexport function getSeqNumberGenerator(startsAt: number = 0): () => number {\n  let current = startsAt;\n  return () => current++;\n}\n\nexport function placeholdersToParams(placeholders: Map<string, string[]>):\n    {[name: string]: o.LiteralExpr} {\n  const params: {[name: string]: o.LiteralExpr} = {};\n  placeholders.forEach((values: string[], key: string) => {\n    params[key] = o.literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);\n  });\n  return params;\n}\n\nexport function updatePlaceholderMap(map: Map<string, any[]>, name: string, ...values: any[]) {\n  const current = map.get(name) || [];\n  current.push(...values);\n  map.set(name, current);\n}\n\nexport function assembleBoundTextPlaceholders(\n    meta: i18n.I18nMeta, bindingStartIndex: number = 0, contextId: number = 0): Map<string, any[]> {\n  const startIdx = bindingStartIndex;\n  const placeholders = new Map<string, any>();\n  const node =\n      meta instanceof i18n.Message ? meta.nodes.find(node => node instanceof i18n.Container) : meta;\n  if (node) {\n    (node as i18n.Container)\n        .children\n        .filter((child: i18n.Node): child is i18n.Placeholder => child instanceof i18n.Placeholder)\n        .forEach((child: i18n.Placeholder, idx: number) => {\n          const content = wrapI18nPlaceholder(startIdx + idx, contextId);\n          updatePlaceholderMap(placeholders, child.name, content);\n        });\n  }\n  return placeholders;\n}\n\n/**\n * Format the placeholder names in a map of placeholders to expressions.\n *\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\n * format (e.g. `startTagDiv_1`).\n *\n * @param params A map of placeholder names to expressions.\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\n * @returns A new map of formatted placeholder names to expressions.\n */\nexport function i18nFormatPlaceholderNames(\n    params: {[name: string]: o.Expression} = {}, useCamelCase: boolean) {\n  const _params: {[key: string]: o.Expression} = {};\n  if (params && Object.keys(params).length) {\n    Object.keys(params).forEach(\n        key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);\n  }\n  return _params;\n}\n\n/**\n * Converts internal placeholder names to public-facing format\n * (for example to use in goog.getMsg call).\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n *\n * @param name The placeholder name that should be formatted\n * @returns Formatted placeholder name\n */\nexport function formatI18nPlaceholderName(name: string, useCamelCase: boolean = true): string {\n  const publicName = toPublicName(name);\n  if (!useCamelCase) {\n    return publicName;\n  }\n  const chunks = publicName.split('_');\n  if (chunks.length === 1) {\n    // if no \"_\" found - just lowercase the value\n    return name.toLowerCase();\n  }\n  let postfix;\n  // eject last element if it's a number\n  if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n    postfix = chunks.pop();\n  }\n  let raw = chunks.shift()!.toLowerCase();\n  if (chunks.length) {\n    raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\n  }\n  return postfix ? `${raw}_${postfix}` : raw;\n}\n\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\nexport function getTranslationConstPrefix(extra: string): string {\n  return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\n}\n\n/**\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\n * @param variable the name of the variable to declare.\n */\nexport function declareI18nVariable(variable: o.ReadVarExpr): o.Statement {\n  return new o.DeclareVarStmt(\n      variable.name!, undefined, o.INFERRED_TYPE, undefined, variable.sourceSpan);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}