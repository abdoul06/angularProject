{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/transformers/program\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"fs\", \"path\", \"typescript\", \"@angular/compiler-cli/src/diagnostics/translate_diagnostics\", \"@angular/compiler-cli/src/metadata/index\", \"@angular/compiler-cli/src/ngtsc/core/src/compiler\", \"@angular/compiler-cli/src/ngtsc/program\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/src/typescript_support\", \"@angular/compiler-cli/src/transformers/api\", \"@angular/compiler-cli/src/transformers/compiler_host\", \"@angular/compiler-cli/src/transformers/downlevel_decorators_transform\", \"@angular/compiler-cli/src/transformers/inline_resources\", \"@angular/compiler-cli/src/transformers/lower_expressions\", \"@angular/compiler-cli/src/transformers/metadata_cache\", \"@angular/compiler-cli/src/transformers/node_emitter_transform\", \"@angular/compiler-cli/src/transformers/r3_metadata_transform\", \"@angular/compiler-cli/src/transformers/r3_transform\", \"@angular/compiler-cli/src/transformers/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.i18nGetExtension = exports.i18nSerialize = exports.i18nExtract = exports.createSrcToOutPathMapper = exports.createProgram = exports.resetTempProgramHandlerForTest = exports.setTempProgramHandlerForTest = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var fs = require(\"fs\");\n\n  var path = require(\"path\");\n\n  var ts = require(\"typescript\");\n\n  var translate_diagnostics_1 = require(\"@angular/compiler-cli/src/diagnostics/translate_diagnostics\");\n\n  var metadata_1 = require(\"@angular/compiler-cli/src/metadata/index\");\n\n  var compiler_2 = require(\"@angular/compiler-cli/src/ngtsc/core/src/compiler\");\n\n  var program_1 = require(\"@angular/compiler-cli/src/ngtsc/program\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var typescript_support_1 = require(\"@angular/compiler-cli/src/typescript_support\");\n\n  var api_1 = require(\"@angular/compiler-cli/src/transformers/api\");\n\n  var compiler_host_1 = require(\"@angular/compiler-cli/src/transformers/compiler_host\");\n\n  var downlevel_decorators_transform_1 = require(\"@angular/compiler-cli/src/transformers/downlevel_decorators_transform\");\n\n  var inline_resources_1 = require(\"@angular/compiler-cli/src/transformers/inline_resources\");\n\n  var lower_expressions_1 = require(\"@angular/compiler-cli/src/transformers/lower_expressions\");\n\n  var metadata_cache_1 = require(\"@angular/compiler-cli/src/transformers/metadata_cache\");\n\n  var node_emitter_transform_1 = require(\"@angular/compiler-cli/src/transformers/node_emitter_transform\");\n\n  var r3_metadata_transform_1 = require(\"@angular/compiler-cli/src/transformers/r3_metadata_transform\");\n\n  var r3_transform_1 = require(\"@angular/compiler-cli/src/transformers/r3_transform\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/transformers/util\");\n  /**\n   * Maximum number of files that are emitable via calling ts.Program.emit\n   * passing individual targetSourceFiles.\n   */\n\n\n  var MAX_FILE_COUNT_FOR_SINGLE_FILE_EMIT = 20;\n  /**\n   * Fields to lower within metadata in render2 mode.\n   */\n\n  var LOWER_FIELDS = ['useValue', 'useFactory', 'data', 'id', 'loadChildren'];\n  /**\n   * Fields to lower within metadata in render3 mode.\n   */\n\n  var R3_LOWER_FIELDS = tslib_1.__spread(LOWER_FIELDS, ['providers', 'imports', 'exports']);\n  /**\n   * Installs a handler for testing purposes to allow inspection of the temporary program.\n   */\n\n\n  var tempProgramHandlerForTest = null;\n\n  function setTempProgramHandlerForTest(handler) {\n    tempProgramHandlerForTest = handler;\n  }\n\n  exports.setTempProgramHandlerForTest = setTempProgramHandlerForTest;\n\n  function resetTempProgramHandlerForTest() {\n    tempProgramHandlerForTest = null;\n  }\n\n  exports.resetTempProgramHandlerForTest = resetTempProgramHandlerForTest;\n  var emptyModules = {\n    ngModules: [],\n    ngModuleByPipeOrDirective: new Map(),\n    files: []\n  };\n\n  var defaultEmitCallback = function defaultEmitCallback(_a) {\n    var program = _a.program,\n        targetSourceFile = _a.targetSourceFile,\n        writeFile = _a.writeFile,\n        cancellationToken = _a.cancellationToken,\n        emitOnlyDtsFiles = _a.emitOnlyDtsFiles,\n        customTransformers = _a.customTransformers;\n    return program.emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);\n  };\n\n  var AngularCompilerProgram =\n  /** @class */\n  function () {\n    function AngularCompilerProgram(rootNames, options, host, oldProgram) {\n      var _a;\n\n      var _this = this;\n\n      this.options = options;\n      this.host = host;\n      this._optionsDiagnostics = [];\n      this._transformTsDiagnostics = [];\n      this._isCompilingAngularCore = null;\n      this.rootNames = tslib_1.__spread(rootNames);\n\n      if (!options.disableTypeScriptVersionCheck) {\n        typescript_support_1.verifySupportedTypeScriptVersion();\n      }\n\n      this.oldTsProgram = oldProgram ? oldProgram.getTsProgram() : undefined;\n\n      if (oldProgram) {\n        this.oldProgramLibrarySummaries = oldProgram.getLibrarySummaries();\n        this.oldProgramEmittedGeneratedFiles = oldProgram.getEmittedGeneratedFiles();\n        this.oldProgramEmittedSourceFiles = oldProgram.getEmittedSourceFiles();\n      }\n\n      if (options.flatModuleOutFile) {\n        var _b = metadata_1.createBundleIndexHost(options, this.rootNames, host, function () {\n          return _this.flatModuleMetadataCache;\n        }),\n            bundleHost = _b.host,\n            indexName = _b.indexName,\n            errors = _b.errors;\n\n        if (errors) {\n          (_a = this._optionsDiagnostics).push.apply(_a, tslib_1.__spread(errors.map(function (e) {\n            return {\n              category: e.category,\n              messageText: e.messageText,\n              source: api_1.SOURCE,\n              code: api_1.DEFAULT_ERROR_CODE\n            };\n          })));\n        } else {\n          this.rootNames.push(indexName);\n          this.host = bundleHost;\n        }\n      }\n\n      this.loweringMetadataTransform = new lower_expressions_1.LowerMetadataTransform(options.enableIvy !== false ? R3_LOWER_FIELDS : LOWER_FIELDS);\n      this.metadataCache = this.createMetadataCache([this.loweringMetadataTransform]);\n    }\n\n    AngularCompilerProgram.prototype.createMetadataCache = function (transformers) {\n      return new metadata_cache_1.MetadataCache(new metadata_1.MetadataCollector({\n        quotedNames: true\n      }), !!this.options.strictMetadataEmit, transformers);\n    };\n\n    AngularCompilerProgram.prototype.getLibrarySummaries = function () {\n      var result = new Map();\n\n      if (this.oldProgramLibrarySummaries) {\n        this.oldProgramLibrarySummaries.forEach(function (summary, fileName) {\n          return result.set(fileName, summary);\n        });\n      }\n\n      if (this.emittedLibrarySummaries) {\n        this.emittedLibrarySummaries.forEach(function (summary, fileName) {\n          return result.set(summary.fileName, summary);\n        });\n      }\n\n      return result;\n    };\n\n    AngularCompilerProgram.prototype.getEmittedGeneratedFiles = function () {\n      var result = new Map();\n\n      if (this.oldProgramEmittedGeneratedFiles) {\n        this.oldProgramEmittedGeneratedFiles.forEach(function (genFile, fileName) {\n          return result.set(fileName, genFile);\n        });\n      }\n\n      if (this.emittedGeneratedFiles) {\n        this.emittedGeneratedFiles.forEach(function (genFile) {\n          return result.set(genFile.genFileUrl, genFile);\n        });\n      }\n\n      return result;\n    };\n\n    AngularCompilerProgram.prototype.getEmittedSourceFiles = function () {\n      var result = new Map();\n\n      if (this.oldProgramEmittedSourceFiles) {\n        this.oldProgramEmittedSourceFiles.forEach(function (sf, fileName) {\n          return result.set(fileName, sf);\n        });\n      }\n\n      if (this.emittedSourceFiles) {\n        this.emittedSourceFiles.forEach(function (sf) {\n          return result.set(sf.fileName, sf);\n        });\n      }\n\n      return result;\n    };\n\n    AngularCompilerProgram.prototype.getTsProgram = function () {\n      return this.tsProgram;\n    };\n\n    AngularCompilerProgram.prototype.getTsOptionDiagnostics = function (cancellationToken) {\n      return this.tsProgram.getOptionsDiagnostics(cancellationToken);\n    };\n\n    AngularCompilerProgram.prototype.getNgOptionDiagnostics = function (cancellationToken) {\n      return tslib_1.__spread(this._optionsDiagnostics, getNgOptionDiagnostics(this.options));\n    };\n\n    AngularCompilerProgram.prototype.getTsSyntacticDiagnostics = function (sourceFile, cancellationToken) {\n      return this.tsProgram.getSyntacticDiagnostics(sourceFile, cancellationToken);\n    };\n\n    AngularCompilerProgram.prototype.getNgStructuralDiagnostics = function (cancellationToken) {\n      return this.structuralDiagnostics;\n    };\n\n    AngularCompilerProgram.prototype.getTsSemanticDiagnostics = function (sourceFile, cancellationToken) {\n      var _this = this;\n\n      var sourceFiles = sourceFile ? [sourceFile] : this.tsProgram.getSourceFiles();\n      var diags = [];\n      sourceFiles.forEach(function (sf) {\n        if (!util_1.GENERATED_FILES.test(sf.fileName)) {\n          diags.push.apply(diags, tslib_1.__spread(_this.tsProgram.getSemanticDiagnostics(sf, cancellationToken)));\n        }\n      });\n      return diags;\n    };\n\n    AngularCompilerProgram.prototype.getNgSemanticDiagnostics = function (fileName, cancellationToken) {\n      var _this = this;\n\n      var diags = [];\n      this.tsProgram.getSourceFiles().forEach(function (sf) {\n        if (util_1.GENERATED_FILES.test(sf.fileName) && !sf.isDeclarationFile) {\n          diags.push.apply(diags, tslib_1.__spread(_this.tsProgram.getSemanticDiagnostics(sf, cancellationToken)));\n        }\n      });\n      var ng = translate_diagnostics_1.translateDiagnostics(this.hostAdapter, diags).ng;\n      return ng;\n    };\n\n    AngularCompilerProgram.prototype.loadNgStructureAsync = function () {\n      var _this = this;\n\n      if (this._analyzedModules) {\n        throw new Error('Angular structure already loaded');\n      }\n\n      return Promise.resolve().then(function () {\n        var _a = _this._createProgramWithBasicStubs(),\n            tmpProgram = _a.tmpProgram,\n            sourceFiles = _a.sourceFiles,\n            tsFiles = _a.tsFiles,\n            rootNames = _a.rootNames;\n\n        return _this.compiler.loadFilesAsync(sourceFiles, tsFiles).then(function (_a) {\n          var analyzedModules = _a.analyzedModules,\n              analyzedInjectables = _a.analyzedInjectables;\n\n          if (_this._analyzedModules) {\n            throw new Error('Angular structure loaded both synchronously and asynchronously');\n          }\n\n          _this._updateProgramWithTypeCheckStubs(tmpProgram, analyzedModules, analyzedInjectables, rootNames);\n        });\n      }).catch(function (e) {\n        return _this._createProgramOnError(e);\n      });\n    };\n\n    AngularCompilerProgram.prototype.listLazyRoutes = function (route) {\n      // Note: Don't analyzedModules if a route is given\n      // to be fast enough.\n      return this.compiler.listLazyRoutes(route, route ? undefined : this.analyzedModules);\n    };\n\n    AngularCompilerProgram.prototype.emit = function (parameters) {\n      if (parameters === void 0) {\n        parameters = {};\n      }\n\n      if (this.options.enableIvy !== false) {\n        throw new Error('Cannot run legacy compiler in ngtsc mode');\n      }\n\n      return this._emitRender2(parameters);\n    };\n\n    AngularCompilerProgram.prototype._emitRender2 = function (_a) {\n      var e_1, _b, e_2, _c;\n\n      var _this = this;\n\n      var _d = _a === void 0 ? {} : _a,\n          _e = _d.emitFlags,\n          emitFlags = _e === void 0 ? api_1.EmitFlags.Default : _e,\n          cancellationToken = _d.cancellationToken,\n          customTransformers = _d.customTransformers,\n          _f = _d.emitCallback,\n          emitCallback = _f === void 0 ? defaultEmitCallback : _f,\n          _g = _d.mergeEmitResultsCallback,\n          mergeEmitResultsCallback = _g === void 0 ? mergeEmitResults : _g;\n\n      var emitStart = Date.now();\n\n      if (emitFlags & api_1.EmitFlags.I18nBundle) {\n        var locale = this.options.i18nOutLocale || null;\n        var file = this.options.i18nOutFile || null;\n        var format = this.options.i18nOutFormat || null;\n        var bundle = this.compiler.emitMessageBundle(this.analyzedModules, locale);\n        i18nExtract(format, file, this.host, this.options, bundle);\n      }\n\n      if ((emitFlags & (api_1.EmitFlags.JS | api_1.EmitFlags.DTS | api_1.EmitFlags.Metadata | api_1.EmitFlags.Codegen)) === 0) {\n        return {\n          emitSkipped: true,\n          diagnostics: [],\n          emittedFiles: []\n        };\n      }\n\n      var _h = this.generateFilesForEmit(emitFlags),\n          genFiles = _h.genFiles,\n          genDiags = _h.genDiags;\n\n      if (genDiags.length) {\n        return {\n          diagnostics: genDiags,\n          emitSkipped: true,\n          emittedFiles: []\n        };\n      }\n\n      this.emittedGeneratedFiles = genFiles;\n      var outSrcMapping = [];\n      var genFileByFileName = new Map();\n      genFiles.forEach(function (genFile) {\n        return genFileByFileName.set(genFile.genFileUrl, genFile);\n      });\n      this.emittedLibrarySummaries = [];\n      this._transformTsDiagnostics = [];\n      var emittedSourceFiles = [];\n\n      var writeTsFile = function writeTsFile(outFileName, outData, writeByteOrderMark, onError, sourceFiles) {\n        var sourceFile = sourceFiles && sourceFiles.length == 1 ? sourceFiles[0] : null;\n        var genFile;\n\n        if (sourceFile) {\n          outSrcMapping.push({\n            outFileName: outFileName,\n            sourceFile: sourceFile\n          });\n          genFile = genFileByFileName.get(sourceFile.fileName);\n\n          if (!sourceFile.isDeclarationFile && !util_1.GENERATED_FILES.test(sourceFile.fileName)) {\n            // Note: sourceFile is the transformed sourcefile, not the original one!\n            var originalFile = _this.tsProgram.getSourceFile(sourceFile.fileName);\n\n            if (originalFile) {\n              emittedSourceFiles.push(originalFile);\n            }\n          }\n        }\n\n        _this.writeFile(outFileName, outData, writeByteOrderMark, onError, genFile, sourceFiles);\n      };\n\n      var modules = this._analyzedInjectables && this.compiler.emitAllPartialModules2(this._analyzedInjectables);\n      var tsCustomTransformers = this.calculateTransforms(genFileByFileName, modules, customTransformers);\n      var emitOnlyDtsFiles = (emitFlags & (api_1.EmitFlags.DTS | api_1.EmitFlags.JS)) == api_1.EmitFlags.DTS; // Restore the original references before we emit so TypeScript doesn't emit\n      // a reference to the .d.ts file.\n\n      var augmentedReferences = new Map();\n\n      try {\n        for (var _j = tslib_1.__values(this.tsProgram.getSourceFiles()), _k = _j.next(); !_k.done; _k = _j.next()) {\n          var sourceFile = _k.value;\n          var originalReferences = compiler_host_1.getOriginalReferences(sourceFile);\n\n          if (originalReferences) {\n            augmentedReferences.set(sourceFile, sourceFile.referencedFiles);\n            sourceFile.referencedFiles = originalReferences;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_k && !_k.done && (_b = _j.return)) _b.call(_j);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      var genTsFiles = [];\n      var genJsonFiles = [];\n      genFiles.forEach(function (gf) {\n        if (gf.stmts) {\n          genTsFiles.push(gf);\n        }\n\n        if (gf.source) {\n          genJsonFiles.push(gf);\n        }\n      });\n      var emitResult;\n      var emittedUserTsCount;\n\n      try {\n        var sourceFilesToEmit = this.getSourceFilesForEmit();\n\n        if (sourceFilesToEmit && sourceFilesToEmit.length + genTsFiles.length < MAX_FILE_COUNT_FOR_SINGLE_FILE_EMIT) {\n          var fileNamesToEmit = tslib_1.__spread(sourceFilesToEmit.map(function (sf) {\n            return sf.fileName;\n          }), genTsFiles.map(function (gf) {\n            return gf.genFileUrl;\n          }));\n\n          emitResult = mergeEmitResultsCallback(fileNamesToEmit.map(function (fileName) {\n            return emitResult = emitCallback({\n              program: _this.tsProgram,\n              host: _this.host,\n              options: _this.options,\n              writeFile: writeTsFile,\n              emitOnlyDtsFiles: emitOnlyDtsFiles,\n              customTransformers: tsCustomTransformers,\n              targetSourceFile: _this.tsProgram.getSourceFile(fileName)\n            });\n          }));\n          emittedUserTsCount = sourceFilesToEmit.length;\n        } else {\n          emitResult = emitCallback({\n            program: this.tsProgram,\n            host: this.host,\n            options: this.options,\n            writeFile: writeTsFile,\n            emitOnlyDtsFiles: emitOnlyDtsFiles,\n            customTransformers: tsCustomTransformers\n          });\n          emittedUserTsCount = this.tsProgram.getSourceFiles().length - genTsFiles.length;\n        }\n      } finally {\n        try {\n          // Restore the references back to the augmented value to ensure that the\n          // checks that TypeScript makes for project structure reuse will succeed.\n          for (var _l = tslib_1.__values(Array.from(augmentedReferences)), _m = _l.next(); !_m.done; _m = _l.next()) {\n            var _o = tslib_1.__read(_m.value, 2),\n                sourceFile = _o[0],\n                references = _o[1]; // TODO(chuckj): Remove any cast after updating build to 2.6\n\n\n            sourceFile.referencedFiles = references;\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_m && !_m.done && (_c = _l.return)) _c.call(_l);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n\n      this.emittedSourceFiles = emittedSourceFiles; // Match behavior of tsc: only produce emit diagnostics if it would block\n      // emit. If noEmitOnError is false, the emit will happen in spite of any\n      // errors, so we should not report them.\n\n      if (emitResult && this.options.noEmitOnError === true) {\n        // translate the diagnostics in the emitResult as well.\n        var translatedEmitDiags = translate_diagnostics_1.translateDiagnostics(this.hostAdapter, emitResult.diagnostics);\n        emitResult.diagnostics = translatedEmitDiags.ts.concat(this.structuralDiagnostics.concat(translatedEmitDiags.ng).map(util_1.ngToTsDiagnostic));\n      }\n\n      if (emitResult && !outSrcMapping.length) {\n        // if no files were emitted by TypeScript, also don't emit .json files\n        emitResult.diagnostics = emitResult.diagnostics.concat([util_1.createMessageDiagnostic(\"Emitted no files.\")]);\n        return emitResult;\n      }\n\n      var sampleSrcFileName;\n      var sampleOutFileName;\n\n      if (outSrcMapping.length) {\n        sampleSrcFileName = outSrcMapping[0].sourceFile.fileName;\n        sampleOutFileName = outSrcMapping[0].outFileName;\n      }\n\n      var srcToOutPath = createSrcToOutPathMapper(this.options.outDir, sampleSrcFileName, sampleOutFileName);\n\n      if (emitFlags & api_1.EmitFlags.Codegen) {\n        genJsonFiles.forEach(function (gf) {\n          var outFileName = srcToOutPath(gf.genFileUrl);\n\n          _this.writeFile(outFileName, gf.source, false, undefined, gf);\n        });\n      }\n\n      var metadataJsonCount = 0;\n\n      if (emitFlags & api_1.EmitFlags.Metadata) {\n        this.tsProgram.getSourceFiles().forEach(function (sf) {\n          if (!sf.isDeclarationFile && !util_1.GENERATED_FILES.test(sf.fileName)) {\n            metadataJsonCount++;\n\n            var metadata = _this.metadataCache.getMetadata(sf);\n\n            if (metadata) {\n              var metadataText = JSON.stringify([metadata]);\n              var outFileName = srcToOutPath(sf.fileName.replace(/\\.tsx?$/, '.metadata.json'));\n\n              _this.writeFile(outFileName, metadataText, false, undefined, undefined, [sf]);\n            }\n          }\n        });\n      }\n\n      var emitEnd = Date.now();\n\n      if (emitResult && this.options.diagnostics) {\n        emitResult.diagnostics = emitResult.diagnostics.concat([util_1.createMessageDiagnostic([\"Emitted in \" + (emitEnd - emitStart) + \"ms\", \"- \" + emittedUserTsCount + \" user ts files\", \"- \" + genTsFiles.length + \" generated ts files\", \"- \" + (genJsonFiles.length + metadataJsonCount) + \" generated json files\"].join('\\n'))]);\n      }\n\n      return emitResult;\n    };\n\n    Object.defineProperty(AngularCompilerProgram.prototype, \"compiler\", {\n      // Private members\n      get: function get() {\n        if (!this._compiler) {\n          this._createCompiler();\n        }\n\n        return this._compiler;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(AngularCompilerProgram.prototype, \"hostAdapter\", {\n      get: function get() {\n        if (!this._hostAdapter) {\n          this._createCompiler();\n        }\n\n        return this._hostAdapter;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(AngularCompilerProgram.prototype, \"analyzedModules\", {\n      get: function get() {\n        if (!this._analyzedModules) {\n          this.initSync();\n        }\n\n        return this._analyzedModules;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(AngularCompilerProgram.prototype, \"structuralDiagnostics\", {\n      get: function get() {\n        var diagnostics = this._structuralDiagnostics;\n\n        if (!diagnostics) {\n          this.initSync();\n          diagnostics = this._structuralDiagnostics = this._structuralDiagnostics || [];\n        }\n\n        return diagnostics;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(AngularCompilerProgram.prototype, \"tsProgram\", {\n      get: function get() {\n        if (!this._tsProgram) {\n          this.initSync();\n        }\n\n        return this._tsProgram;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(AngularCompilerProgram.prototype, \"isCompilingAngularCore\", {\n      /** Whether the program is compiling the Angular core package. */\n      get: function get() {\n        if (this._isCompilingAngularCore !== null) {\n          return this._isCompilingAngularCore;\n        }\n\n        return this._isCompilingAngularCore = compiler_2.isAngularCorePackage(this.tsProgram);\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    AngularCompilerProgram.prototype.calculateTransforms = function (genFiles, partialModules, customTransformers) {\n      var beforeTs = [];\n      var metadataTransforms = [];\n      var flatModuleMetadataTransforms = [];\n      var annotateForClosureCompiler = this.options.annotateForClosureCompiler || false;\n\n      if (this.options.enableResourceInlining) {\n        beforeTs.push(inline_resources_1.getInlineResourcesTransformFactory(this.tsProgram, this.hostAdapter));\n        var transformer = new inline_resources_1.InlineResourcesMetadataTransformer(this.hostAdapter);\n        metadataTransforms.push(transformer);\n        flatModuleMetadataTransforms.push(transformer);\n      }\n\n      if (!this.options.disableExpressionLowering) {\n        beforeTs.push(lower_expressions_1.getExpressionLoweringTransformFactory(this.loweringMetadataTransform, this.tsProgram));\n        metadataTransforms.push(this.loweringMetadataTransform);\n      }\n\n      if (genFiles) {\n        beforeTs.push(node_emitter_transform_1.getAngularEmitterTransformFactory(genFiles, this.getTsProgram(), annotateForClosureCompiler));\n      }\n\n      if (partialModules) {\n        beforeTs.push(r3_transform_1.getAngularClassTransformerFactory(partialModules, annotateForClosureCompiler)); // If we have partial modules, the cached metadata might be incorrect as it doesn't reflect\n        // the partial module transforms.\n\n        var transformer = new r3_metadata_transform_1.PartialModuleMetadataTransformer(partialModules);\n        metadataTransforms.push(transformer);\n        flatModuleMetadataTransforms.push(transformer);\n      }\n\n      if (customTransformers && customTransformers.beforeTs) {\n        beforeTs.push.apply(beforeTs, tslib_1.__spread(customTransformers.beforeTs));\n      } // If decorators should be converted to static fields (enabled by default), we set up\n      // the decorator downlevel transform. Note that we set it up as last transform as that\n      // allows custom transformers to strip Angular decorators without having to deal with\n      // identifying static properties. e.g. it's more difficult handling `<..>.decorators`\n      // or `<..>.ctorParameters` compared to the `ts.Decorator` AST nodes.\n\n\n      if (this.options.annotationsAs !== 'decorators') {\n        var typeChecker = this.getTsProgram().getTypeChecker();\n        var reflectionHost = new reflection_1.TypeScriptReflectionHost(typeChecker); // Similarly to how we handled tsickle decorator downleveling in the past, we just\n        // ignore diagnostics that have been collected by the transformer. These are\n        // non-significant failures that shouldn't prevent apps from compiling.\n\n        beforeTs.push(downlevel_decorators_transform_1.getDownlevelDecoratorsTransform(typeChecker, reflectionHost, [], this.isCompilingAngularCore, annotateForClosureCompiler,\n        /* skipClassDecorators */\n        false));\n      }\n\n      if (metadataTransforms.length > 0) {\n        this.metadataCache = this.createMetadataCache(metadataTransforms);\n      }\n\n      if (flatModuleMetadataTransforms.length > 0) {\n        this.flatModuleMetadataCache = this.createMetadataCache(flatModuleMetadataTransforms);\n      }\n\n      var afterTs = customTransformers ? customTransformers.afterTs : undefined;\n      return {\n        before: beforeTs,\n        after: afterTs\n      };\n    };\n\n    AngularCompilerProgram.prototype.initSync = function () {\n      if (this._analyzedModules) {\n        return;\n      }\n\n      try {\n        var _a = this._createProgramWithBasicStubs(),\n            tmpProgram = _a.tmpProgram,\n            sourceFiles = _a.sourceFiles,\n            tsFiles = _a.tsFiles,\n            rootNames = _a.rootNames;\n\n        var _b = this.compiler.loadFilesSync(sourceFiles, tsFiles),\n            analyzedModules = _b.analyzedModules,\n            analyzedInjectables = _b.analyzedInjectables;\n\n        this._updateProgramWithTypeCheckStubs(tmpProgram, analyzedModules, analyzedInjectables, rootNames);\n      } catch (e) {\n        this._createProgramOnError(e);\n      }\n    };\n\n    AngularCompilerProgram.prototype._createCompiler = function () {\n      var _this = this;\n\n      var codegen = {\n        generateFile: function generateFile(genFileName, baseFileName) {\n          return _this._compiler.emitBasicStub(genFileName, baseFileName);\n        },\n        findGeneratedFileNames: function findGeneratedFileNames(fileName) {\n          return _this._compiler.findGeneratedFileNames(fileName);\n        }\n      };\n      this._hostAdapter = new compiler_host_1.TsCompilerAotCompilerTypeCheckHostAdapter(this.rootNames, this.options, this.host, this.metadataCache, codegen, this.oldProgramLibrarySummaries);\n      var aotOptions = getAotCompilerOptions(this.options);\n      var errorCollector = this.options.collectAllErrors || this.options.fullTemplateTypeCheck ? function (err) {\n        return _this._addStructuralDiagnostics(err);\n      } : undefined;\n      this._compiler = compiler_1.createAotCompiler(this._hostAdapter, aotOptions, errorCollector).compiler;\n    };\n\n    AngularCompilerProgram.prototype._createProgramWithBasicStubs = function () {\n      var _this = this;\n\n      if (this._analyzedModules) {\n        throw new Error(\"Internal Error: already initialized!\");\n      } // Note: This is important to not produce a memory leak!\n\n\n      var oldTsProgram = this.oldTsProgram;\n      this.oldTsProgram = undefined;\n      var codegen = {\n        generateFile: function generateFile(genFileName, baseFileName) {\n          return _this.compiler.emitBasicStub(genFileName, baseFileName);\n        },\n        findGeneratedFileNames: function findGeneratedFileNames(fileName) {\n          return _this.compiler.findGeneratedFileNames(fileName);\n        }\n      };\n\n      var rootNames = tslib_1.__spread(this.rootNames);\n\n      if (this.options.generateCodeForLibraries !== false) {\n        // if we should generateCodeForLibraries, never include\n        // generated files in the program as otherwise we will\n        // overwrite them and typescript will report the error\n        // TS5055: Cannot write file ... because it would overwrite input file.\n        rootNames = rootNames.filter(function (fn) {\n          return !util_1.GENERATED_FILES.test(fn);\n        });\n      }\n\n      if (this.options.noResolve) {\n        this.rootNames.forEach(function (rootName) {\n          if (_this.hostAdapter.shouldGenerateFilesFor(rootName)) {\n            rootNames.push.apply(rootNames, tslib_1.__spread(_this.compiler.findGeneratedFileNames(rootName)));\n          }\n        });\n      }\n\n      var tmpProgram = ts.createProgram(rootNames, this.options, this.hostAdapter, oldTsProgram);\n\n      if (tempProgramHandlerForTest !== null) {\n        tempProgramHandlerForTest(tmpProgram);\n      }\n\n      var sourceFiles = [];\n      var tsFiles = [];\n      tmpProgram.getSourceFiles().forEach(function (sf) {\n        if (_this.hostAdapter.isSourceFile(sf.fileName)) {\n          sourceFiles.push(sf.fileName);\n        }\n\n        if (util_1.TS.test(sf.fileName) && !util_1.DTS.test(sf.fileName)) {\n          tsFiles.push(sf.fileName);\n        }\n      });\n      return {\n        tmpProgram: tmpProgram,\n        sourceFiles: sourceFiles,\n        tsFiles: tsFiles,\n        rootNames: rootNames\n      };\n    };\n\n    AngularCompilerProgram.prototype._updateProgramWithTypeCheckStubs = function (tmpProgram, analyzedModules, analyzedInjectables, rootNames) {\n      var _this = this;\n\n      this._analyzedModules = analyzedModules;\n      this._analyzedInjectables = analyzedInjectables;\n      tmpProgram.getSourceFiles().forEach(function (sf) {\n        if (sf.fileName.endsWith('.ngfactory.ts')) {\n          var _a = _this.hostAdapter.shouldGenerateFile(sf.fileName),\n              generate = _a.generate,\n              baseFileName = _a.baseFileName;\n\n          if (generate) {\n            // Note: ! is ok as hostAdapter.shouldGenerateFile will always return a baseFileName\n            // for .ngfactory.ts files.\n            var genFile = _this.compiler.emitTypeCheckStub(sf.fileName, baseFileName);\n\n            if (genFile) {\n              _this.hostAdapter.updateGeneratedFile(genFile);\n            }\n          }\n        }\n      });\n      this._tsProgram = ts.createProgram(rootNames, this.options, this.hostAdapter, tmpProgram); // Note: the new ts program should be completely reusable by TypeScript as:\n      // - we cache all the files in the hostAdapter\n      // - new new stubs use the exactly same imports/exports as the old once (we assert that in\n      // hostAdapter.updateGeneratedFile).\n      // TS 4.1+ stores the reuse state in the new program\n\n      var checkReuseProgram = ts.versionMajorMinor === '4.0' ? tmpProgram : this._tsProgram;\n\n      if (util_1.tsStructureIsReused(checkReuseProgram) !== 2\n      /* Completely */\n      ) {\n          throw new Error(\"Internal Error: The structure of the program changed during codegen.\");\n        }\n    };\n\n    AngularCompilerProgram.prototype._createProgramOnError = function (e) {\n      // Still fill the analyzedModules and the tsProgram\n      // so that we don't cause other errors for users who e.g. want to emit the ngProgram.\n      this._analyzedModules = emptyModules;\n      this.oldTsProgram = undefined;\n\n      this._hostAdapter.isSourceFile = function () {\n        return false;\n      };\n\n      this._tsProgram = ts.createProgram(this.rootNames, this.options, this.hostAdapter);\n\n      if (compiler_1.isSyntaxError(e)) {\n        this._addStructuralDiagnostics(e);\n\n        return;\n      }\n\n      throw e;\n    };\n\n    AngularCompilerProgram.prototype._addStructuralDiagnostics = function (error) {\n      var diagnostics = this._structuralDiagnostics || (this._structuralDiagnostics = []);\n\n      if (compiler_1.isSyntaxError(error)) {\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(syntaxErrorToDiagnostics(error, this.tsProgram)));\n      } else {\n        diagnostics.push({\n          messageText: error.toString(),\n          category: ts.DiagnosticCategory.Error,\n          source: api_1.SOURCE,\n          code: api_1.DEFAULT_ERROR_CODE\n        });\n      }\n    }; // Note: this returns a ts.Diagnostic so that we\n    // can return errors in a ts.EmitResult\n\n\n    AngularCompilerProgram.prototype.generateFilesForEmit = function (emitFlags) {\n      var _this = this;\n\n      try {\n        if (!(emitFlags & api_1.EmitFlags.Codegen)) {\n          return {\n            genFiles: [],\n            genDiags: []\n          };\n        } // TODO(tbosch): allow generating files that are not in the rootDir\n        // See https://github.com/angular/angular/issues/19337\n\n\n        var genFiles = this.compiler.emitAllImpls(this.analyzedModules).filter(function (genFile) {\n          return util_1.isInRootDir(genFile.genFileUrl, _this.options);\n        });\n\n        if (this.oldProgramEmittedGeneratedFiles) {\n          var oldProgramEmittedGeneratedFiles_1 = this.oldProgramEmittedGeneratedFiles;\n          genFiles = genFiles.filter(function (genFile) {\n            var oldGenFile = oldProgramEmittedGeneratedFiles_1.get(genFile.genFileUrl);\n            return !oldGenFile || !genFile.isEquivalent(oldGenFile);\n          });\n        }\n\n        return {\n          genFiles: genFiles,\n          genDiags: []\n        };\n      } catch (e) {\n        // TODO(tbosch): check whether we can actually have syntax errors here,\n        // as we already parsed the metadata and templates before to create the type check block.\n        if (compiler_1.isSyntaxError(e)) {\n          var genDiags = [{\n            file: undefined,\n            start: undefined,\n            length: undefined,\n            messageText: e.message,\n            category: ts.DiagnosticCategory.Error,\n            source: api_1.SOURCE,\n            code: api_1.DEFAULT_ERROR_CODE\n          }];\n          return {\n            genFiles: [],\n            genDiags: genDiags\n          };\n        }\n\n        throw e;\n      }\n    };\n    /**\n     * Returns undefined if all files should be emitted.\n     */\n\n\n    AngularCompilerProgram.prototype.getSourceFilesForEmit = function () {\n      var _this = this; // TODO(tbosch): if one of the files contains a `const enum`\n      // always emit all files -> return undefined!\n\n\n      var sourceFilesToEmit = this.tsProgram.getSourceFiles().filter(function (sf) {\n        return !sf.isDeclarationFile && !util_1.GENERATED_FILES.test(sf.fileName);\n      });\n\n      if (this.oldProgramEmittedSourceFiles) {\n        sourceFilesToEmit = sourceFilesToEmit.filter(function (sf) {\n          var oldFile = _this.oldProgramEmittedSourceFiles.get(sf.fileName);\n\n          return sf !== oldFile;\n        });\n      }\n\n      return sourceFilesToEmit;\n    };\n\n    AngularCompilerProgram.prototype.writeFile = function (outFileName, outData, writeByteOrderMark, onError, genFile, sourceFiles) {\n      // collect emittedLibrarySummaries\n      var baseFile;\n\n      if (genFile) {\n        baseFile = this.tsProgram.getSourceFile(genFile.srcFileUrl);\n\n        if (baseFile) {\n          if (!this.emittedLibrarySummaries) {\n            this.emittedLibrarySummaries = [];\n          }\n\n          if (genFile.genFileUrl.endsWith('.ngsummary.json') && baseFile.fileName.endsWith('.d.ts')) {\n            this.emittedLibrarySummaries.push({\n              fileName: baseFile.fileName,\n              text: baseFile.text,\n              sourceFile: baseFile\n            });\n            this.emittedLibrarySummaries.push({\n              fileName: genFile.genFileUrl,\n              text: outData\n            });\n\n            if (!this.options.declaration) {\n              // If we don't emit declarations, still record an empty .ngfactory.d.ts file,\n              // as we might need it later on for resolving module names from summaries.\n              var ngFactoryDts = genFile.genFileUrl.substring(0, genFile.genFileUrl.length - 15) + '.ngfactory.d.ts';\n              this.emittedLibrarySummaries.push({\n                fileName: ngFactoryDts,\n                text: ''\n              });\n            }\n          } else if (outFileName.endsWith('.d.ts') && baseFile.fileName.endsWith('.d.ts')) {\n            var dtsSourceFilePath = genFile.genFileUrl.replace(/\\.ts$/, '.d.ts'); // Note: Don't use sourceFiles here as the created .d.ts has a path in the outDir,\n            // but we need one that is next to the .ts file\n\n            this.emittedLibrarySummaries.push({\n              fileName: dtsSourceFilePath,\n              text: outData\n            });\n          }\n        }\n      } // Filter out generated files for which we didn't generate code.\n      // This can happen as the stub calculation is not completely exact.\n      // Note: sourceFile refers to the .ngfactory.ts / .ngsummary.ts file\n      // node_emitter_transform already set the file contents to be empty,\n      //  so this code only needs to skip the file if !allowEmptyCodegenFiles.\n\n\n      var isGenerated = util_1.GENERATED_FILES.test(outFileName);\n\n      if (isGenerated && !this.options.allowEmptyCodegenFiles && (!genFile || !genFile.stmts || genFile.stmts.length === 0)) {\n        return;\n      }\n\n      if (baseFile) {\n        sourceFiles = sourceFiles ? tslib_1.__spread(sourceFiles, [baseFile]) : [baseFile];\n      } // TODO: remove any when TS 2.4 support is removed.\n\n\n      this.host.writeFile(outFileName, outData, writeByteOrderMark, onError, sourceFiles);\n    };\n\n    return AngularCompilerProgram;\n  }();\n\n  function createProgram(_a) {\n    var rootNames = _a.rootNames,\n        options = _a.options,\n        host = _a.host,\n        oldProgram = _a.oldProgram;\n\n    if (options.enableIvy !== false) {\n      return new program_1.NgtscProgram(rootNames, options, host, oldProgram);\n    } else {\n      return new AngularCompilerProgram(rootNames, options, host, oldProgram);\n    }\n  }\n\n  exports.createProgram = createProgram; // Compute the AotCompiler options\n\n  function getAotCompilerOptions(options) {\n    var missingTranslation = compiler_1.core.MissingTranslationStrategy.Warning;\n\n    switch (options.i18nInMissingTranslations) {\n      case 'ignore':\n        missingTranslation = compiler_1.core.MissingTranslationStrategy.Ignore;\n        break;\n\n      case 'error':\n        missingTranslation = compiler_1.core.MissingTranslationStrategy.Error;\n        break;\n    }\n\n    var translations = '';\n\n    if (options.i18nInFile) {\n      if (!options.i18nInLocale) {\n        throw new Error(\"The translation file (\" + options.i18nInFile + \") locale must be provided.\");\n      }\n\n      translations = fs.readFileSync(options.i18nInFile, 'utf8');\n    } else {\n      // No translations are provided, ignore any errors\n      // We still go through i18n to remove i18n attributes\n      missingTranslation = compiler_1.core.MissingTranslationStrategy.Ignore;\n    }\n\n    return {\n      locale: options.i18nInLocale,\n      i18nFormat: options.i18nInFormat || options.i18nOutFormat,\n      i18nUseExternalIds: options.i18nUseExternalIds,\n      translations: translations,\n      missingTranslation: missingTranslation,\n      enableSummariesForJit: options.enableSummariesForJit,\n      preserveWhitespaces: options.preserveWhitespaces,\n      fullTemplateTypeCheck: options.fullTemplateTypeCheck,\n      allowEmptyCodegenFiles: options.allowEmptyCodegenFiles,\n      enableIvy: options.enableIvy,\n      createExternalSymbolFactoryReexports: options.createExternalSymbolFactoryReexports\n    };\n  }\n\n  function getNgOptionDiagnostics(options) {\n    if (options.annotationsAs) {\n      switch (options.annotationsAs) {\n        case 'decorators':\n        case 'static fields':\n          break;\n\n        default:\n          return [{\n            messageText: 'Angular compiler options \"annotationsAs\" only supports \"static fields\" and \"decorators\"',\n            category: ts.DiagnosticCategory.Error,\n            source: api_1.SOURCE,\n            code: api_1.DEFAULT_ERROR_CODE\n          }];\n      }\n    }\n\n    return [];\n  }\n\n  function normalizeSeparators(path) {\n    return path.replace(/\\\\/g, '/');\n  }\n  /**\n   * Returns a function that can adjust a path from source path to out path,\n   * based on an existing mapping from source to out path.\n   *\n   * TODO(tbosch): talk to the TypeScript team to expose their logic for calculating the `rootDir`\n   * if none was specified.\n   *\n   * Note: This function works on normalized paths from typescript but should always return\n   * POSIX normalized paths for output paths.\n   */\n\n\n  function createSrcToOutPathMapper(outDir, sampleSrcFileName, sampleOutFileName, host) {\n    if (host === void 0) {\n      host = path;\n    }\n\n    if (outDir) {\n      var path_1 = {}; // Ensure we error if we use `path` instead of `host`.\n\n      if (sampleSrcFileName == null || sampleOutFileName == null) {\n        throw new Error(\"Can't calculate the rootDir without a sample srcFileName / outFileName. \");\n      }\n\n      var srcFileDir = normalizeSeparators(host.dirname(sampleSrcFileName));\n      var outFileDir = normalizeSeparators(host.dirname(sampleOutFileName));\n\n      if (srcFileDir === outFileDir) {\n        return function (srcFileName) {\n          return srcFileName;\n        };\n      } // calculate the common suffix, stopping\n      // at `outDir`.\n\n\n      var srcDirParts = srcFileDir.split('/');\n      var outDirParts = normalizeSeparators(host.relative(outDir, outFileDir)).split('/');\n      var i = 0;\n\n      while (i < Math.min(srcDirParts.length, outDirParts.length) && srcDirParts[srcDirParts.length - 1 - i] === outDirParts[outDirParts.length - 1 - i]) {\n        i++;\n      }\n\n      var rootDir_1 = srcDirParts.slice(0, srcDirParts.length - i).join('/');\n      return function (srcFileName) {\n        // Note: Before we return the mapped output path, we need to normalize the path delimiters\n        // because the output path is usually passed to TypeScript which sometimes only expects\n        // posix normalized paths (e.g. if a custom compiler host is used)\n        return normalizeSeparators(host.resolve(outDir, host.relative(rootDir_1, srcFileName)));\n      };\n    } else {\n      // Note: Before we return the output path, we need to normalize the path delimiters because\n      // the output path is usually passed to TypeScript which only passes around posix\n      // normalized paths (e.g. if a custom compiler host is used)\n      return function (srcFileName) {\n        return normalizeSeparators(srcFileName);\n      };\n    }\n  }\n\n  exports.createSrcToOutPathMapper = createSrcToOutPathMapper;\n\n  function i18nExtract(formatName, outFile, host, options, bundle) {\n    formatName = formatName || 'xlf'; // Checks the format and returns the extension\n\n    var ext = i18nGetExtension(formatName);\n    var content = i18nSerialize(bundle, formatName, options);\n    var dstFile = outFile || \"messages.\" + ext;\n    var dstPath = path.resolve(options.outDir || options.basePath, dstFile);\n    host.writeFile(dstPath, content, false, undefined, []);\n    return [dstPath];\n  }\n\n  exports.i18nExtract = i18nExtract;\n\n  function i18nSerialize(bundle, formatName, options) {\n    var format = formatName.toLowerCase();\n    var serializer;\n\n    switch (format) {\n      case 'xmb':\n        serializer = new compiler_1.Xmb();\n        break;\n\n      case 'xliff2':\n      case 'xlf2':\n        serializer = new compiler_1.Xliff2();\n        break;\n\n      case 'xlf':\n      case 'xliff':\n      default:\n        serializer = new compiler_1.Xliff();\n    }\n\n    return bundle.write(serializer, getPathNormalizer(options.basePath));\n  }\n\n  exports.i18nSerialize = i18nSerialize;\n\n  function getPathNormalizer(basePath) {\n    // normalize source paths by removing the base path and always using \"/\" as a separator\n    return function (sourcePath) {\n      sourcePath = basePath ? path.relative(basePath, sourcePath) : sourcePath;\n      return sourcePath.split(path.sep).join('/');\n    };\n  }\n\n  function i18nGetExtension(formatName) {\n    var format = formatName.toLowerCase();\n\n    switch (format) {\n      case 'xmb':\n        return 'xmb';\n\n      case 'xlf':\n      case 'xlif':\n      case 'xliff':\n      case 'xlf2':\n      case 'xliff2':\n        return 'xlf';\n    }\n\n    throw new Error(\"Unsupported format \\\"\" + formatName + \"\\\"\");\n  }\n\n  exports.i18nGetExtension = i18nGetExtension;\n\n  function mergeEmitResults(emitResults) {\n    var e_3, _a;\n\n    var diagnostics = [];\n    var emitSkipped = false;\n    var emittedFiles = [];\n\n    try {\n      for (var emitResults_1 = tslib_1.__values(emitResults), emitResults_1_1 = emitResults_1.next(); !emitResults_1_1.done; emitResults_1_1 = emitResults_1.next()) {\n        var er = emitResults_1_1.value;\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(er.diagnostics));\n        emitSkipped = emitSkipped || er.emitSkipped;\n        emittedFiles.push.apply(emittedFiles, tslib_1.__spread(er.emittedFiles || []));\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (emitResults_1_1 && !emitResults_1_1.done && (_a = emitResults_1.return)) _a.call(emitResults_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return {\n      diagnostics: diagnostics,\n      emitSkipped: emitSkipped,\n      emittedFiles: emittedFiles\n    };\n  }\n\n  function diagnosticSourceOfSpan(span) {\n    // For diagnostics, TypeScript only uses the fileName and text properties.\n    // The redundant '()' are here is to avoid having clang-format breaking the line incorrectly.\n    return {\n      fileName: span.start.file.url,\n      text: span.start.file.content\n    };\n  }\n\n  function diagnosticSourceOfFileName(fileName, program) {\n    var sourceFile = program.getSourceFile(fileName);\n    if (sourceFile) return sourceFile; // If we are reporting diagnostics for a source file that is not in the project then we need\n    // to fake a source file so the diagnostic formatting routines can emit the file name.\n    // The redundant '()' are here is to avoid having clang-format breaking the line incorrectly.\n\n    return {\n      fileName: fileName,\n      text: ''\n    };\n  }\n\n  function diagnosticChainFromFormattedDiagnosticChain(chain) {\n    return {\n      messageText: chain.message,\n      next: chain.next && chain.next.map(diagnosticChainFromFormattedDiagnosticChain),\n      position: chain.position\n    };\n  }\n\n  function syntaxErrorToDiagnostics(error, program) {\n    var parserErrors = compiler_1.getParseErrors(error);\n\n    if (parserErrors && parserErrors.length) {\n      return parserErrors.map(function (e) {\n        return {\n          messageText: e.contextualMessage(),\n          file: diagnosticSourceOfSpan(e.span),\n          start: e.span.start.offset,\n          length: e.span.end.offset - e.span.start.offset,\n          category: ts.DiagnosticCategory.Error,\n          source: api_1.SOURCE,\n          code: api_1.DEFAULT_ERROR_CODE\n        };\n      });\n    } else if (compiler_1.isFormattedError(error)) {\n      return [{\n        messageText: error.message,\n        chain: error.chain && diagnosticChainFromFormattedDiagnosticChain(error.chain),\n        category: ts.DiagnosticCategory.Error,\n        source: api_1.SOURCE,\n        code: api_1.DEFAULT_ERROR_CODE,\n        position: error.position\n      }];\n    }\n\n    var ngModuleErrorData = compiler_1.getMissingNgModuleMetadataErrorData(error);\n\n    if (ngModuleErrorData !== null) {\n      // This error represents the import or export of an `NgModule` that didn't have valid metadata.\n      // This _might_ happen because the NgModule in question is an Ivy-compiled library, and we want\n      // to show a more useful error if that's the case.\n      var ngModuleClass = getDtsClass(program, ngModuleErrorData.fileName, ngModuleErrorData.className);\n\n      if (ngModuleClass !== null && isIvyNgModule(ngModuleClass)) {\n        return [{\n          messageText: \"The NgModule '\" + ngModuleErrorData.className + \"' in '\" + ngModuleErrorData.fileName + \"' is imported by this compilation, but appears to be part of a library compiled for Angular Ivy. This may occur because:\\n\\n  1) the library was processed with 'ngcc'. Removing and reinstalling node_modules may fix this problem.\\n\\n  2) the library was published for Angular Ivy and v12+ applications only. Check its peer dependencies carefully and ensure that you're using a compatible version of Angular.\\n\\nSee https://angular.io/errors/NG6999 for more information.\\n\",\n          category: ts.DiagnosticCategory.Error,\n          code: api_1.DEFAULT_ERROR_CODE,\n          source: api_1.SOURCE\n        }];\n      }\n    } // Produce a Diagnostic anyway since we know for sure `error` is a SyntaxError\n\n\n    return [{\n      messageText: error.message,\n      category: ts.DiagnosticCategory.Error,\n      code: api_1.DEFAULT_ERROR_CODE,\n      source: api_1.SOURCE\n    }];\n  }\n\n  function getDtsClass(program, fileName, className) {\n    var e_4, _a;\n\n    var sf = program.getSourceFile(fileName);\n\n    if (sf === undefined || !sf.isDeclarationFile) {\n      return null;\n    }\n\n    try {\n      for (var _b = tslib_1.__values(sf.statements), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var stmt = _c.value;\n\n        if (!ts.isClassDeclaration(stmt)) {\n          continue;\n        }\n\n        if (stmt.name === undefined || stmt.name.text !== className) {\n          continue;\n        }\n\n        return stmt;\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    } // No classes found that matched the given name.\n\n\n    return null;\n  }\n\n  function isIvyNgModule(clazz) {\n    var e_5, _a;\n\n    try {\n      for (var _b = tslib_1.__values(clazz.members), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var member = _c.value;\n\n        if (!ts.isPropertyDeclaration(member)) {\n          continue;\n        }\n\n        if (ts.isIdentifier(member.name) && member.name.text === 'mod') {\n          return true;\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    } // No Ivy 'mod' property found.\n\n\n    return false;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/transformers/program.ts"],"names":[],"mappings":"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","sourcesContent":["\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AotCompiler, AotCompilerOptions, core, createAotCompiler, FormattedMessageChain, GeneratedFile, getMissingNgModuleMetadataErrorData, getParseErrors, isFormattedError, isSyntaxError, MessageBundle, NgAnalyzedFileWithInjectables, NgAnalyzedModules, ParseSourceSpan, PartialModule, Serializer, Xliff, Xliff2, Xmb} from '@angular/compiler';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nimport {translateDiagnostics} from '../diagnostics/translate_diagnostics';\nimport {createBundleIndexHost, MetadataCollector} from '../metadata';\nimport {isAngularCorePackage} from '../ngtsc/core/src/compiler';\nimport {NgtscProgram} from '../ngtsc/program';\nimport {TypeScriptReflectionHost} from '../ngtsc/reflection';\nimport {verifySupportedTypeScriptVersion} from '../typescript_support';\n\nimport {CompilerHost, CompilerOptions, CustomTransformers, DEFAULT_ERROR_CODE, Diagnostic, DiagnosticMessageChain, EmitFlags, LazyRoute, LibrarySummary, Program, SOURCE, TsEmitCallback, TsMergeEmitResultsCallback} from './api';\nimport {CodeGenerator, getOriginalReferences, TsCompilerAotCompilerTypeCheckHostAdapter} from './compiler_host';\nimport {getDownlevelDecoratorsTransform} from './downlevel_decorators_transform';\nimport {getInlineResourcesTransformFactory, InlineResourcesMetadataTransformer} from './inline_resources';\nimport {getExpressionLoweringTransformFactory, LowerMetadataTransform} from './lower_expressions';\nimport {MetadataCache, MetadataTransformer} from './metadata_cache';\nimport {getAngularEmitterTransformFactory} from './node_emitter_transform';\nimport {PartialModuleMetadataTransformer} from './r3_metadata_transform';\nimport {getAngularClassTransformerFactory} from './r3_transform';\nimport {createMessageDiagnostic, DTS, GENERATED_FILES, isInRootDir, ngToTsDiagnostic, StructureIsReused, TS, tsStructureIsReused} from './util';\n\n\n/**\n * Maximum number of files that are emitable via calling ts.Program.emit\n * passing individual targetSourceFiles.\n */\nconst MAX_FILE_COUNT_FOR_SINGLE_FILE_EMIT = 20;\n\n\n/**\n * Fields to lower within metadata in render2 mode.\n */\nconst LOWER_FIELDS = ['useValue', 'useFactory', 'data', 'id', 'loadChildren'];\n\n/**\n * Fields to lower within metadata in render3 mode.\n */\nconst R3_LOWER_FIELDS = [...LOWER_FIELDS, 'providers', 'imports', 'exports'];\n\n/**\n * Installs a handler for testing purposes to allow inspection of the temporary program.\n */\nlet tempProgramHandlerForTest: ((program: ts.Program) => void)|null = null;\nexport function setTempProgramHandlerForTest(handler: (program: ts.Program) => void): void {\n  tempProgramHandlerForTest = handler;\n}\nexport function resetTempProgramHandlerForTest(): void {\n  tempProgramHandlerForTest = null;\n}\n\nconst emptyModules: NgAnalyzedModules = {\n  ngModules: [],\n  ngModuleByPipeOrDirective: new Map(),\n  files: []\n};\n\nconst defaultEmitCallback: TsEmitCallback = ({\n  program,\n  targetSourceFile,\n  writeFile,\n  cancellationToken,\n  emitOnlyDtsFiles,\n  customTransformers\n}) =>\n    program.emit(\n        targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);\n\nclass AngularCompilerProgram implements Program {\n  private rootNames: string[];\n  private metadataCache: MetadataCache;\n  // Metadata cache used exclusively for the flat module index\n  // TODO(issue/24571): remove '!'.\n  private flatModuleMetadataCache!: MetadataCache;\n  private loweringMetadataTransform: LowerMetadataTransform;\n  private oldProgramLibrarySummaries: Map<string, LibrarySummary>|undefined;\n  private oldProgramEmittedGeneratedFiles: Map<string, GeneratedFile>|undefined;\n  private oldProgramEmittedSourceFiles: Map<string, ts.SourceFile>|undefined;\n  // Note: This will be cleared out as soon as we create the _tsProgram\n  private oldTsProgram: ts.Program|undefined;\n  private emittedLibrarySummaries: LibrarySummary[]|undefined;\n  private emittedGeneratedFiles: GeneratedFile[]|undefined;\n  private emittedSourceFiles: ts.SourceFile[]|undefined;\n\n  // Lazily initialized fields\n  // TODO(issue/24571): remove '!'.\n  private _compiler!: AotCompiler;\n  // TODO(issue/24571): remove '!'.\n  private _hostAdapter!: TsCompilerAotCompilerTypeCheckHostAdapter;\n  // TODO(issue/24571): remove '!'.\n  private _tsProgram!: ts.Program;\n  private _analyzedModules: NgAnalyzedModules|undefined;\n  private _analyzedInjectables: NgAnalyzedFileWithInjectables[]|undefined;\n  private _structuralDiagnostics: Diagnostic[]|undefined;\n  private _programWithStubs: ts.Program|undefined;\n  private _optionsDiagnostics: Diagnostic[] = [];\n  private _transformTsDiagnostics: ts.Diagnostic[] = [];\n\n  constructor(\n      rootNames: ReadonlyArray<string>, private options: CompilerOptions,\n      private host: CompilerHost, oldProgram?: Program) {\n    this.rootNames = [...rootNames];\n\n    if (!options.disableTypeScriptVersionCheck) {\n      verifySupportedTypeScriptVersion();\n    }\n\n    this.oldTsProgram = oldProgram ? oldProgram.getTsProgram() : undefined;\n    if (oldProgram) {\n      this.oldProgramLibrarySummaries = oldProgram.getLibrarySummaries();\n      this.oldProgramEmittedGeneratedFiles = oldProgram.getEmittedGeneratedFiles();\n      this.oldProgramEmittedSourceFiles = oldProgram.getEmittedSourceFiles();\n    }\n\n    if (options.flatModuleOutFile) {\n      const {host: bundleHost, indexName, errors} =\n          createBundleIndexHost(options, this.rootNames, host, () => this.flatModuleMetadataCache);\n      if (errors) {\n        this._optionsDiagnostics.push(...errors.map(e => ({\n                                                      category: e.category,\n                                                      messageText: e.messageText as string,\n                                                      source: SOURCE,\n                                                      code: DEFAULT_ERROR_CODE\n                                                    })));\n      } else {\n        this.rootNames.push(indexName!);\n        this.host = bundleHost;\n      }\n    }\n\n    this.loweringMetadataTransform =\n        new LowerMetadataTransform(options.enableIvy !== false ? R3_LOWER_FIELDS : LOWER_FIELDS);\n    this.metadataCache = this.createMetadataCache([this.loweringMetadataTransform]);\n  }\n\n  private createMetadataCache(transformers: MetadataTransformer[]) {\n    return new MetadataCache(\n        new MetadataCollector({quotedNames: true}), !!this.options.strictMetadataEmit,\n        transformers);\n  }\n\n  getLibrarySummaries(): Map<string, LibrarySummary> {\n    const result = new Map<string, LibrarySummary>();\n    if (this.oldProgramLibrarySummaries) {\n      this.oldProgramLibrarySummaries.forEach((summary, fileName) => result.set(fileName, summary));\n    }\n    if (this.emittedLibrarySummaries) {\n      this.emittedLibrarySummaries.forEach(\n          (summary, fileName) => result.set(summary.fileName, summary));\n    }\n    return result;\n  }\n\n  getEmittedGeneratedFiles(): Map<string, GeneratedFile> {\n    const result = new Map<string, GeneratedFile>();\n    if (this.oldProgramEmittedGeneratedFiles) {\n      this.oldProgramEmittedGeneratedFiles.forEach(\n          (genFile, fileName) => result.set(fileName, genFile));\n    }\n    if (this.emittedGeneratedFiles) {\n      this.emittedGeneratedFiles.forEach((genFile) => result.set(genFile.genFileUrl, genFile));\n    }\n    return result;\n  }\n\n  getEmittedSourceFiles(): Map<string, ts.SourceFile> {\n    const result = new Map<string, ts.SourceFile>();\n    if (this.oldProgramEmittedSourceFiles) {\n      this.oldProgramEmittedSourceFiles.forEach((sf, fileName) => result.set(fileName, sf));\n    }\n    if (this.emittedSourceFiles) {\n      this.emittedSourceFiles.forEach((sf) => result.set(sf.fileName, sf));\n    }\n    return result;\n  }\n\n  getTsProgram(): ts.Program {\n    return this.tsProgram;\n  }\n\n  getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken) {\n    return this.tsProgram.getOptionsDiagnostics(cancellationToken);\n  }\n\n  getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<Diagnostic> {\n    return [...this._optionsDiagnostics, ...getNgOptionDiagnostics(this.options)];\n  }\n\n  getTsSyntacticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken):\n      ReadonlyArray<ts.Diagnostic> {\n    return this.tsProgram.getSyntacticDiagnostics(sourceFile, cancellationToken);\n  }\n\n  getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<Diagnostic> {\n    return this.structuralDiagnostics;\n  }\n\n  getTsSemanticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken):\n      ReadonlyArray<ts.Diagnostic> {\n    const sourceFiles = sourceFile ? [sourceFile] : this.tsProgram.getSourceFiles();\n    let diags: ts.Diagnostic[] = [];\n    sourceFiles.forEach(sf => {\n      if (!GENERATED_FILES.test(sf.fileName)) {\n        diags.push(...this.tsProgram.getSemanticDiagnostics(sf, cancellationToken));\n      }\n    });\n    return diags;\n  }\n\n  getNgSemanticDiagnostics(fileName?: string, cancellationToken?: ts.CancellationToken):\n      ReadonlyArray<Diagnostic> {\n    let diags: ts.Diagnostic[] = [];\n    this.tsProgram.getSourceFiles().forEach(sf => {\n      if (GENERATED_FILES.test(sf.fileName) && !sf.isDeclarationFile) {\n        diags.push(...this.tsProgram.getSemanticDiagnostics(sf, cancellationToken));\n      }\n    });\n    const {ng} = translateDiagnostics(this.hostAdapter, diags);\n    return ng;\n  }\n\n  loadNgStructureAsync(): Promise<void> {\n    if (this._analyzedModules) {\n      throw new Error('Angular structure already loaded');\n    }\n    return Promise.resolve()\n        .then(() => {\n          const {tmpProgram, sourceFiles, tsFiles, rootNames} = this._createProgramWithBasicStubs();\n          return this.compiler.loadFilesAsync(sourceFiles, tsFiles)\n              .then(({analyzedModules, analyzedInjectables}) => {\n                if (this._analyzedModules) {\n                  throw new Error('Angular structure loaded both synchronously and asynchronously');\n                }\n                this._updateProgramWithTypeCheckStubs(\n                    tmpProgram, analyzedModules, analyzedInjectables, rootNames);\n              });\n        })\n        .catch(e => this._createProgramOnError(e));\n  }\n\n  listLazyRoutes(route?: string): LazyRoute[] {\n    // Note: Don't analyzedModules if a route is given\n    // to be fast enough.\n    return this.compiler.listLazyRoutes(route, route ? undefined : this.analyzedModules);\n  }\n\n  emit(parameters: {\n    emitFlags?: EmitFlags,\n    cancellationToken?: ts.CancellationToken,\n    customTransformers?: CustomTransformers,\n    emitCallback?: TsEmitCallback,\n    mergeEmitResultsCallback?: TsMergeEmitResultsCallback,\n  } = {}): ts.EmitResult {\n    if (this.options.enableIvy !== false) {\n      throw new Error('Cannot run legacy compiler in ngtsc mode');\n    }\n    return this._emitRender2(parameters);\n  }\n\n  private _emitRender2({\n    emitFlags = EmitFlags.Default,\n    cancellationToken,\n    customTransformers,\n    emitCallback = defaultEmitCallback,\n    mergeEmitResultsCallback = mergeEmitResults,\n  }: {\n    emitFlags?: EmitFlags,\n    cancellationToken?: ts.CancellationToken,\n    customTransformers?: CustomTransformers,\n    emitCallback?: TsEmitCallback,\n    mergeEmitResultsCallback?: TsMergeEmitResultsCallback,\n  } = {}): ts.EmitResult {\n    const emitStart = Date.now();\n    if (emitFlags & EmitFlags.I18nBundle) {\n      const locale = this.options.i18nOutLocale || null;\n      const file = this.options.i18nOutFile || null;\n      const format = this.options.i18nOutFormat || null;\n      const bundle = this.compiler.emitMessageBundle(this.analyzedModules, locale);\n      i18nExtract(format, file, this.host, this.options, bundle);\n    }\n    if ((emitFlags & (EmitFlags.JS | EmitFlags.DTS | EmitFlags.Metadata | EmitFlags.Codegen)) ===\n        0) {\n      return {emitSkipped: true, diagnostics: [], emittedFiles: []};\n    }\n    let {genFiles, genDiags} = this.generateFilesForEmit(emitFlags);\n    if (genDiags.length) {\n      return {\n        diagnostics: genDiags,\n        emitSkipped: true,\n        emittedFiles: [],\n      };\n    }\n    this.emittedGeneratedFiles = genFiles;\n    const outSrcMapping: Array<{sourceFile: ts.SourceFile, outFileName: string}> = [];\n    const genFileByFileName = new Map<string, GeneratedFile>();\n    genFiles.forEach(genFile => genFileByFileName.set(genFile.genFileUrl, genFile));\n    this.emittedLibrarySummaries = [];\n    this._transformTsDiagnostics = [];\n    const emittedSourceFiles = [] as ts.SourceFile[];\n    const writeTsFile: ts.WriteFileCallback =\n        (outFileName, outData, writeByteOrderMark, onError?, sourceFiles?) => {\n          const sourceFile = sourceFiles && sourceFiles.length == 1 ? sourceFiles[0] : null;\n          let genFile: GeneratedFile|undefined;\n          if (sourceFile) {\n            outSrcMapping.push({outFileName: outFileName, sourceFile});\n            genFile = genFileByFileName.get(sourceFile.fileName);\n            if (!sourceFile.isDeclarationFile && !GENERATED_FILES.test(sourceFile.fileName)) {\n              // Note: sourceFile is the transformed sourcefile, not the original one!\n              const originalFile = this.tsProgram.getSourceFile(sourceFile.fileName);\n              if (originalFile) {\n                emittedSourceFiles.push(originalFile);\n              }\n            }\n          }\n          this.writeFile(outFileName, outData, writeByteOrderMark, onError, genFile, sourceFiles);\n        };\n\n    const modules = this._analyzedInjectables &&\n        this.compiler.emitAllPartialModules2(this._analyzedInjectables);\n\n    const tsCustomTransformers =\n        this.calculateTransforms(genFileByFileName, modules, customTransformers);\n    const emitOnlyDtsFiles = (emitFlags & (EmitFlags.DTS | EmitFlags.JS)) == EmitFlags.DTS;\n    // Restore the original references before we emit so TypeScript doesn't emit\n    // a reference to the .d.ts file.\n    const augmentedReferences = new Map<ts.SourceFile, ReadonlyArray<ts.FileReference>>();\n    for (const sourceFile of this.tsProgram.getSourceFiles()) {\n      const originalReferences = getOriginalReferences(sourceFile);\n      if (originalReferences) {\n        augmentedReferences.set(sourceFile, sourceFile.referencedFiles);\n        sourceFile.referencedFiles = originalReferences;\n      }\n    }\n    const genTsFiles: GeneratedFile[] = [];\n    const genJsonFiles: GeneratedFile[] = [];\n    genFiles.forEach(gf => {\n      if (gf.stmts) {\n        genTsFiles.push(gf);\n      }\n      if (gf.source) {\n        genJsonFiles.push(gf);\n      }\n    });\n    let emitResult: ts.EmitResult;\n    let emittedUserTsCount: number;\n    try {\n      const sourceFilesToEmit = this.getSourceFilesForEmit();\n      if (sourceFilesToEmit &&\n          (sourceFilesToEmit.length + genTsFiles.length) < MAX_FILE_COUNT_FOR_SINGLE_FILE_EMIT) {\n        const fileNamesToEmit =\n            [...sourceFilesToEmit.map(sf => sf.fileName), ...genTsFiles.map(gf => gf.genFileUrl)];\n        emitResult = mergeEmitResultsCallback(\n            fileNamesToEmit.map((fileName) => emitResult = emitCallback({\n                                  program: this.tsProgram,\n                                  host: this.host,\n                                  options: this.options,\n                                  writeFile: writeTsFile,\n                                  emitOnlyDtsFiles,\n                                  customTransformers: tsCustomTransformers,\n                                  targetSourceFile: this.tsProgram.getSourceFile(fileName),\n                                })));\n        emittedUserTsCount = sourceFilesToEmit.length;\n      } else {\n        emitResult = emitCallback({\n          program: this.tsProgram,\n          host: this.host,\n          options: this.options,\n          writeFile: writeTsFile,\n          emitOnlyDtsFiles,\n          customTransformers: tsCustomTransformers\n        });\n        emittedUserTsCount = this.tsProgram.getSourceFiles().length - genTsFiles.length;\n      }\n    } finally {\n      // Restore the references back to the augmented value to ensure that the\n      // checks that TypeScript makes for project structure reuse will succeed.\n      for (const [sourceFile, references] of Array.from(augmentedReferences)) {\n        // TODO(chuckj): Remove any cast after updating build to 2.6\n        (sourceFile as any).referencedFiles = references;\n      }\n    }\n    this.emittedSourceFiles = emittedSourceFiles;\n\n    // Match behavior of tsc: only produce emit diagnostics if it would block\n    // emit. If noEmitOnError is false, the emit will happen in spite of any\n    // errors, so we should not report them.\n    if (emitResult && this.options.noEmitOnError === true) {\n      // translate the diagnostics in the emitResult as well.\n      const translatedEmitDiags = translateDiagnostics(this.hostAdapter, emitResult.diagnostics);\n      emitResult.diagnostics = translatedEmitDiags.ts.concat(\n          this.structuralDiagnostics.concat(translatedEmitDiags.ng).map(ngToTsDiagnostic));\n    }\n\n    if (emitResult && !outSrcMapping.length) {\n      // if no files were emitted by TypeScript, also don't emit .json files\n      emitResult.diagnostics =\n          emitResult.diagnostics.concat([createMessageDiagnostic(`Emitted no files.`)]);\n      return emitResult;\n    }\n\n    let sampleSrcFileName: string|undefined;\n    let sampleOutFileName: string|undefined;\n    if (outSrcMapping.length) {\n      sampleSrcFileName = outSrcMapping[0].sourceFile.fileName;\n      sampleOutFileName = outSrcMapping[0].outFileName;\n    }\n    const srcToOutPath =\n        createSrcToOutPathMapper(this.options.outDir, sampleSrcFileName, sampleOutFileName);\n    if (emitFlags & EmitFlags.Codegen) {\n      genJsonFiles.forEach(gf => {\n        const outFileName = srcToOutPath(gf.genFileUrl);\n        this.writeFile(outFileName, gf.source!, false, undefined, gf);\n      });\n    }\n    let metadataJsonCount = 0;\n    if (emitFlags & EmitFlags.Metadata) {\n      this.tsProgram.getSourceFiles().forEach(sf => {\n        if (!sf.isDeclarationFile && !GENERATED_FILES.test(sf.fileName)) {\n          metadataJsonCount++;\n          const metadata = this.metadataCache.getMetadata(sf);\n          if (metadata) {\n            const metadataText = JSON.stringify([metadata]);\n            const outFileName = srcToOutPath(sf.fileName.replace(/\\.tsx?$/, '.metadata.json'));\n            this.writeFile(outFileName, metadataText, false, undefined, undefined, [sf]);\n          }\n        }\n      });\n    }\n    const emitEnd = Date.now();\n    if (emitResult && this.options.diagnostics) {\n      emitResult.diagnostics = emitResult.diagnostics.concat([createMessageDiagnostic([\n        `Emitted in ${emitEnd - emitStart}ms`,\n        `- ${emittedUserTsCount} user ts files`,\n        `- ${genTsFiles.length} generated ts files`,\n        `- ${genJsonFiles.length + metadataJsonCount} generated json files`,\n      ].join('\\n'))]);\n    }\n\n    return emitResult;\n  }\n\n  // Private members\n  private get compiler(): AotCompiler {\n    if (!this._compiler) {\n      this._createCompiler();\n    }\n    return this._compiler!;\n  }\n\n  private get hostAdapter(): TsCompilerAotCompilerTypeCheckHostAdapter {\n    if (!this._hostAdapter) {\n      this._createCompiler();\n    }\n    return this._hostAdapter!;\n  }\n\n  private get analyzedModules(): NgAnalyzedModules {\n    if (!this._analyzedModules) {\n      this.initSync();\n    }\n    return this._analyzedModules!;\n  }\n\n  private get structuralDiagnostics(): ReadonlyArray<Diagnostic> {\n    let diagnostics = this._structuralDiagnostics;\n    if (!diagnostics) {\n      this.initSync();\n      diagnostics = (this._structuralDiagnostics = this._structuralDiagnostics || []);\n    }\n    return diagnostics;\n  }\n\n  private get tsProgram(): ts.Program {\n    if (!this._tsProgram) {\n      this.initSync();\n    }\n    return this._tsProgram!;\n  }\n\n  /** Whether the program is compiling the Angular core package. */\n  private get isCompilingAngularCore(): boolean {\n    if (this._isCompilingAngularCore !== null) {\n      return this._isCompilingAngularCore;\n    }\n    return this._isCompilingAngularCore = isAngularCorePackage(this.tsProgram);\n  }\n  private _isCompilingAngularCore: boolean|null = null;\n\n  private calculateTransforms(\n      genFiles: Map<string, GeneratedFile>|undefined, partialModules: PartialModule[]|undefined,\n      customTransformers?: CustomTransformers): ts.CustomTransformers {\n    const beforeTs: Array<ts.TransformerFactory<ts.SourceFile>> = [];\n    const metadataTransforms: MetadataTransformer[] = [];\n    const flatModuleMetadataTransforms: MetadataTransformer[] = [];\n    const annotateForClosureCompiler = this.options.annotateForClosureCompiler || false;\n\n    if (this.options.enableResourceInlining) {\n      beforeTs.push(getInlineResourcesTransformFactory(this.tsProgram, this.hostAdapter));\n      const transformer = new InlineResourcesMetadataTransformer(this.hostAdapter);\n      metadataTransforms.push(transformer);\n      flatModuleMetadataTransforms.push(transformer);\n    }\n\n    if (!this.options.disableExpressionLowering) {\n      beforeTs.push(\n          getExpressionLoweringTransformFactory(this.loweringMetadataTransform, this.tsProgram));\n      metadataTransforms.push(this.loweringMetadataTransform);\n    }\n    if (genFiles) {\n      beforeTs.push(getAngularEmitterTransformFactory(\n          genFiles, this.getTsProgram(), annotateForClosureCompiler));\n    }\n    if (partialModules) {\n      beforeTs.push(getAngularClassTransformerFactory(partialModules, annotateForClosureCompiler));\n\n      // If we have partial modules, the cached metadata might be incorrect as it doesn't reflect\n      // the partial module transforms.\n      const transformer = new PartialModuleMetadataTransformer(partialModules);\n      metadataTransforms.push(transformer);\n      flatModuleMetadataTransforms.push(transformer);\n    }\n\n    if (customTransformers && customTransformers.beforeTs) {\n      beforeTs.push(...customTransformers.beforeTs);\n    }\n\n    // If decorators should be converted to static fields (enabled by default), we set up\n    // the decorator downlevel transform. Note that we set it up as last transform as that\n    // allows custom transformers to strip Angular decorators without having to deal with\n    // identifying static properties. e.g. it's more difficult handling `<..>.decorators`\n    // or `<..>.ctorParameters` compared to the `ts.Decorator` AST nodes.\n    if (this.options.annotationsAs !== 'decorators') {\n      const typeChecker = this.getTsProgram().getTypeChecker();\n      const reflectionHost = new TypeScriptReflectionHost(typeChecker);\n      // Similarly to how we handled tsickle decorator downleveling in the past, we just\n      // ignore diagnostics that have been collected by the transformer. These are\n      // non-significant failures that shouldn't prevent apps from compiling.\n      beforeTs.push(getDownlevelDecoratorsTransform(\n          typeChecker, reflectionHost, [], this.isCompilingAngularCore, annotateForClosureCompiler,\n          /* skipClassDecorators */ false));\n    }\n\n    if (metadataTransforms.length > 0) {\n      this.metadataCache = this.createMetadataCache(metadataTransforms);\n    }\n    if (flatModuleMetadataTransforms.length > 0) {\n      this.flatModuleMetadataCache = this.createMetadataCache(flatModuleMetadataTransforms);\n    }\n    const afterTs = customTransformers ? customTransformers.afterTs : undefined;\n    return {before: beforeTs, after: afterTs};\n  }\n\n  private initSync() {\n    if (this._analyzedModules) {\n      return;\n    }\n    try {\n      const {tmpProgram, sourceFiles, tsFiles, rootNames} = this._createProgramWithBasicStubs();\n      const {analyzedModules, analyzedInjectables} =\n          this.compiler.loadFilesSync(sourceFiles, tsFiles);\n      this._updateProgramWithTypeCheckStubs(\n          tmpProgram, analyzedModules, analyzedInjectables, rootNames);\n    } catch (e) {\n      this._createProgramOnError(e);\n    }\n  }\n\n  private _createCompiler() {\n    const codegen: CodeGenerator = {\n      generateFile: (genFileName, baseFileName) =>\n          this._compiler.emitBasicStub(genFileName, baseFileName),\n      findGeneratedFileNames: (fileName) => this._compiler.findGeneratedFileNames(fileName),\n    };\n\n    this._hostAdapter = new TsCompilerAotCompilerTypeCheckHostAdapter(\n        this.rootNames, this.options, this.host, this.metadataCache, codegen,\n        this.oldProgramLibrarySummaries);\n    const aotOptions = getAotCompilerOptions(this.options);\n    const errorCollector = (this.options.collectAllErrors || this.options.fullTemplateTypeCheck) ?\n        (err: any) => this._addStructuralDiagnostics(err) :\n        undefined;\n    this._compiler = createAotCompiler(this._hostAdapter, aotOptions, errorCollector).compiler;\n  }\n\n  private _createProgramWithBasicStubs(): {\n    tmpProgram: ts.Program,\n    rootNames: string[],\n    sourceFiles: string[],\n    tsFiles: string[],\n  } {\n    if (this._analyzedModules) {\n      throw new Error(`Internal Error: already initialized!`);\n    }\n    // Note: This is important to not produce a memory leak!\n    const oldTsProgram = this.oldTsProgram;\n    this.oldTsProgram = undefined;\n\n    const codegen: CodeGenerator = {\n      generateFile: (genFileName, baseFileName) =>\n          this.compiler.emitBasicStub(genFileName, baseFileName),\n      findGeneratedFileNames: (fileName) => this.compiler.findGeneratedFileNames(fileName),\n    };\n\n\n    let rootNames = [...this.rootNames];\n    if (this.options.generateCodeForLibraries !== false) {\n      // if we should generateCodeForLibraries, never include\n      // generated files in the program as otherwise we will\n      // overwrite them and typescript will report the error\n      // TS5055: Cannot write file ... because it would overwrite input file.\n      rootNames = rootNames.filter(fn => !GENERATED_FILES.test(fn));\n    }\n    if (this.options.noResolve) {\n      this.rootNames.forEach(rootName => {\n        if (this.hostAdapter.shouldGenerateFilesFor(rootName)) {\n          rootNames.push(...this.compiler.findGeneratedFileNames(rootName));\n        }\n      });\n    }\n\n    const tmpProgram = ts.createProgram(rootNames, this.options, this.hostAdapter, oldTsProgram);\n    if (tempProgramHandlerForTest !== null) {\n      tempProgramHandlerForTest(tmpProgram);\n    }\n    const sourceFiles: string[] = [];\n    const tsFiles: string[] = [];\n    tmpProgram.getSourceFiles().forEach(sf => {\n      if (this.hostAdapter.isSourceFile(sf.fileName)) {\n        sourceFiles.push(sf.fileName);\n      }\n      if (TS.test(sf.fileName) && !DTS.test(sf.fileName)) {\n        tsFiles.push(sf.fileName);\n      }\n    });\n    return {tmpProgram, sourceFiles, tsFiles, rootNames};\n  }\n\n  private _updateProgramWithTypeCheckStubs(\n      tmpProgram: ts.Program, analyzedModules: NgAnalyzedModules,\n      analyzedInjectables: NgAnalyzedFileWithInjectables[], rootNames: string[]) {\n    this._analyzedModules = analyzedModules;\n    this._analyzedInjectables = analyzedInjectables;\n    tmpProgram.getSourceFiles().forEach(sf => {\n      if (sf.fileName.endsWith('.ngfactory.ts')) {\n        const {generate, baseFileName} = this.hostAdapter.shouldGenerateFile(sf.fileName);\n        if (generate) {\n          // Note: ! is ok as hostAdapter.shouldGenerateFile will always return a baseFileName\n          // for .ngfactory.ts files.\n          const genFile = this.compiler.emitTypeCheckStub(sf.fileName, baseFileName!);\n          if (genFile) {\n            this.hostAdapter.updateGeneratedFile(genFile);\n          }\n        }\n      }\n    });\n    this._tsProgram = ts.createProgram(rootNames, this.options, this.hostAdapter, tmpProgram);\n    // Note: the new ts program should be completely reusable by TypeScript as:\n    // - we cache all the files in the hostAdapter\n    // - new new stubs use the exactly same imports/exports as the old once (we assert that in\n    // hostAdapter.updateGeneratedFile).\n    // TS 4.1+ stores the reuse state in the new program\n    const checkReuseProgram =\n        (ts.versionMajorMinor as string) === '4.0' ? tmpProgram : this._tsProgram;\n    if (tsStructureIsReused(checkReuseProgram) !== StructureIsReused.Completely) {\n      throw new Error(`Internal Error: The structure of the program changed during codegen.`);\n    }\n  }\n\n  private _createProgramOnError(e: any) {\n    // Still fill the analyzedModules and the tsProgram\n    // so that we don't cause other errors for users who e.g. want to emit the ngProgram.\n    this._analyzedModules = emptyModules;\n    this.oldTsProgram = undefined;\n    this._hostAdapter.isSourceFile = () => false;\n    this._tsProgram = ts.createProgram(this.rootNames, this.options, this.hostAdapter);\n    if (isSyntaxError(e)) {\n      this._addStructuralDiagnostics(e);\n      return;\n    }\n    throw e;\n  }\n\n  private _addStructuralDiagnostics(error: Error) {\n    const diagnostics = this._structuralDiagnostics || (this._structuralDiagnostics = []);\n    if (isSyntaxError(error)) {\n      diagnostics.push(...syntaxErrorToDiagnostics(error, this.tsProgram));\n    } else {\n      diagnostics.push({\n        messageText: error.toString(),\n        category: ts.DiagnosticCategory.Error,\n        source: SOURCE,\n        code: DEFAULT_ERROR_CODE\n      });\n    }\n  }\n\n  // Note: this returns a ts.Diagnostic so that we\n  // can return errors in a ts.EmitResult\n  private generateFilesForEmit(emitFlags: EmitFlags):\n      {genFiles: GeneratedFile[], genDiags: ts.Diagnostic[]} {\n    try {\n      if (!(emitFlags & EmitFlags.Codegen)) {\n        return {genFiles: [], genDiags: []};\n      }\n      // TODO(tbosch): allow generating files that are not in the rootDir\n      // See https://github.com/angular/angular/issues/19337\n      let genFiles = this.compiler.emitAllImpls(this.analyzedModules)\n                         .filter(genFile => isInRootDir(genFile.genFileUrl, this.options));\n      if (this.oldProgramEmittedGeneratedFiles) {\n        const oldProgramEmittedGeneratedFiles = this.oldProgramEmittedGeneratedFiles;\n        genFiles = genFiles.filter(genFile => {\n          const oldGenFile = oldProgramEmittedGeneratedFiles.get(genFile.genFileUrl);\n          return !oldGenFile || !genFile.isEquivalent(oldGenFile);\n        });\n      }\n      return {genFiles, genDiags: []};\n    } catch (e) {\n      // TODO(tbosch): check whether we can actually have syntax errors here,\n      // as we already parsed the metadata and templates before to create the type check block.\n      if (isSyntaxError(e)) {\n        const genDiags: ts.Diagnostic[] = [{\n          file: undefined,\n          start: undefined,\n          length: undefined,\n          messageText: e.message,\n          category: ts.DiagnosticCategory.Error,\n          source: SOURCE,\n          code: DEFAULT_ERROR_CODE\n        }];\n        return {genFiles: [], genDiags};\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Returns undefined if all files should be emitted.\n   */\n  private getSourceFilesForEmit(): ts.SourceFile[]|undefined {\n    // TODO(tbosch): if one of the files contains a `const enum`\n    // always emit all files -> return undefined!\n    let sourceFilesToEmit = this.tsProgram.getSourceFiles().filter(sf => {\n      return !sf.isDeclarationFile && !GENERATED_FILES.test(sf.fileName);\n    });\n    if (this.oldProgramEmittedSourceFiles) {\n      sourceFilesToEmit = sourceFilesToEmit.filter(sf => {\n        const oldFile = this.oldProgramEmittedSourceFiles!.get(sf.fileName);\n        return sf !== oldFile;\n      });\n    }\n    return sourceFilesToEmit;\n  }\n\n  private writeFile(\n      outFileName: string, outData: string, writeByteOrderMark: boolean,\n      onError?: (message: string) => void, genFile?: GeneratedFile,\n      sourceFiles?: ReadonlyArray<ts.SourceFile>) {\n    // collect emittedLibrarySummaries\n    let baseFile: ts.SourceFile|undefined;\n    if (genFile) {\n      baseFile = this.tsProgram.getSourceFile(genFile.srcFileUrl);\n      if (baseFile) {\n        if (!this.emittedLibrarySummaries) {\n          this.emittedLibrarySummaries = [];\n        }\n        if (genFile.genFileUrl.endsWith('.ngsummary.json') && baseFile.fileName.endsWith('.d.ts')) {\n          this.emittedLibrarySummaries.push({\n            fileName: baseFile.fileName,\n            text: baseFile.text,\n            sourceFile: baseFile,\n          });\n          this.emittedLibrarySummaries.push({fileName: genFile.genFileUrl, text: outData});\n          if (!this.options.declaration) {\n            // If we don't emit declarations, still record an empty .ngfactory.d.ts file,\n            // as we might need it later on for resolving module names from summaries.\n            const ngFactoryDts =\n                genFile.genFileUrl.substring(0, genFile.genFileUrl.length - 15) + '.ngfactory.d.ts';\n            this.emittedLibrarySummaries.push({fileName: ngFactoryDts, text: ''});\n          }\n        } else if (outFileName.endsWith('.d.ts') && baseFile.fileName.endsWith('.d.ts')) {\n          const dtsSourceFilePath = genFile.genFileUrl.replace(/\\.ts$/, '.d.ts');\n          // Note: Don't use sourceFiles here as the created .d.ts has a path in the outDir,\n          // but we need one that is next to the .ts file\n          this.emittedLibrarySummaries.push({fileName: dtsSourceFilePath, text: outData});\n        }\n      }\n    }\n    // Filter out generated files for which we didn't generate code.\n    // This can happen as the stub calculation is not completely exact.\n    // Note: sourceFile refers to the .ngfactory.ts / .ngsummary.ts file\n    // node_emitter_transform already set the file contents to be empty,\n    //  so this code only needs to skip the file if !allowEmptyCodegenFiles.\n    const isGenerated = GENERATED_FILES.test(outFileName);\n    if (isGenerated && !this.options.allowEmptyCodegenFiles &&\n        (!genFile || !genFile.stmts || genFile.stmts.length === 0)) {\n      return;\n    }\n    if (baseFile) {\n      sourceFiles = sourceFiles ? [...sourceFiles, baseFile] : [baseFile];\n    }\n    // TODO: remove any when TS 2.4 support is removed.\n    this.host.writeFile(outFileName, outData, writeByteOrderMark, onError, sourceFiles as any);\n  }\n}\n\n\nexport function createProgram({rootNames, options, host, oldProgram}: {\n  rootNames: ReadonlyArray<string>,\n  options: CompilerOptions,\n  host: CompilerHost,\n  oldProgram?: Program\n}): Program {\n  if (options.enableIvy !== false) {\n    return new NgtscProgram(rootNames, options, host, oldProgram as NgtscProgram | undefined);\n  } else {\n    return new AngularCompilerProgram(rootNames, options, host, oldProgram);\n  }\n}\n\n// Compute the AotCompiler options\nfunction getAotCompilerOptions(options: CompilerOptions): AotCompilerOptions {\n  let missingTranslation = core.MissingTranslationStrategy.Warning;\n\n  switch (options.i18nInMissingTranslations) {\n    case 'ignore':\n      missingTranslation = core.MissingTranslationStrategy.Ignore;\n      break;\n    case 'error':\n      missingTranslation = core.MissingTranslationStrategy.Error;\n      break;\n  }\n\n  let translations: string = '';\n\n  if (options.i18nInFile) {\n    if (!options.i18nInLocale) {\n      throw new Error(`The translation file (${options.i18nInFile}) locale must be provided.`);\n    }\n    translations = fs.readFileSync(options.i18nInFile, 'utf8');\n  } else {\n    // No translations are provided, ignore any errors\n    // We still go through i18n to remove i18n attributes\n    missingTranslation = core.MissingTranslationStrategy.Ignore;\n  }\n\n  return {\n    locale: options.i18nInLocale,\n    i18nFormat: options.i18nInFormat || options.i18nOutFormat,\n    i18nUseExternalIds: options.i18nUseExternalIds,\n    translations,\n    missingTranslation,\n    enableSummariesForJit: options.enableSummariesForJit,\n    preserveWhitespaces: options.preserveWhitespaces,\n    fullTemplateTypeCheck: options.fullTemplateTypeCheck,\n    allowEmptyCodegenFiles: options.allowEmptyCodegenFiles,\n    enableIvy: options.enableIvy,\n    createExternalSymbolFactoryReexports: options.createExternalSymbolFactoryReexports,\n  };\n}\n\nfunction getNgOptionDiagnostics(options: CompilerOptions): ReadonlyArray<Diagnostic> {\n  if (options.annotationsAs) {\n    switch (options.annotationsAs) {\n      case 'decorators':\n      case 'static fields':\n        break;\n      default:\n        return [{\n          messageText:\n              'Angular compiler options \"annotationsAs\" only supports \"static fields\" and \"decorators\"',\n          category: ts.DiagnosticCategory.Error,\n          source: SOURCE,\n          code: DEFAULT_ERROR_CODE\n        }];\n    }\n  }\n  return [];\n}\n\nfunction normalizeSeparators(path: string): string {\n  return path.replace(/\\\\/g, '/');\n}\n\n/**\n * Returns a function that can adjust a path from source path to out path,\n * based on an existing mapping from source to out path.\n *\n * TODO(tbosch): talk to the TypeScript team to expose their logic for calculating the `rootDir`\n * if none was specified.\n *\n * Note: This function works on normalized paths from typescript but should always return\n * POSIX normalized paths for output paths.\n */\nexport function createSrcToOutPathMapper(\n    outDir: string|undefined, sampleSrcFileName: string|undefined,\n    sampleOutFileName: string|undefined, host: {\n      dirname: typeof path.dirname,\n      resolve: typeof path.resolve,\n      relative: typeof path.relative\n    } = path): (srcFileName: string) => string {\n  if (outDir) {\n    let path: {} = {};  // Ensure we error if we use `path` instead of `host`.\n    if (sampleSrcFileName == null || sampleOutFileName == null) {\n      throw new Error(`Can't calculate the rootDir without a sample srcFileName / outFileName. `);\n    }\n    const srcFileDir = normalizeSeparators(host.dirname(sampleSrcFileName));\n    const outFileDir = normalizeSeparators(host.dirname(sampleOutFileName));\n    if (srcFileDir === outFileDir) {\n      return (srcFileName) => srcFileName;\n    }\n    // calculate the common suffix, stopping\n    // at `outDir`.\n    const srcDirParts = srcFileDir.split('/');\n    const outDirParts = normalizeSeparators(host.relative(outDir, outFileDir)).split('/');\n    let i = 0;\n    while (i < Math.min(srcDirParts.length, outDirParts.length) &&\n           srcDirParts[srcDirParts.length - 1 - i] === outDirParts[outDirParts.length - 1 - i])\n      i++;\n    const rootDir = srcDirParts.slice(0, srcDirParts.length - i).join('/');\n    return (srcFileName) => {\n      // Note: Before we return the mapped output path, we need to normalize the path delimiters\n      // because the output path is usually passed to TypeScript which sometimes only expects\n      // posix normalized paths (e.g. if a custom compiler host is used)\n      return normalizeSeparators(host.resolve(outDir, host.relative(rootDir, srcFileName)));\n    };\n  } else {\n    // Note: Before we return the output path, we need to normalize the path delimiters because\n    // the output path is usually passed to TypeScript which only passes around posix\n    // normalized paths (e.g. if a custom compiler host is used)\n    return (srcFileName) => normalizeSeparators(srcFileName);\n  }\n}\n\nexport function i18nExtract(\n    formatName: string|null, outFile: string|null, host: ts.CompilerHost, options: CompilerOptions,\n    bundle: MessageBundle): string[] {\n  formatName = formatName || 'xlf';\n  // Checks the format and returns the extension\n  const ext = i18nGetExtension(formatName);\n  const content = i18nSerialize(bundle, formatName, options);\n  const dstFile = outFile || `messages.${ext}`;\n  const dstPath = path.resolve(options.outDir || options.basePath!, dstFile);\n  host.writeFile(dstPath, content, false, undefined, []);\n  return [dstPath];\n}\n\nexport function i18nSerialize(\n    bundle: MessageBundle, formatName: string, options: CompilerOptions): string {\n  const format = formatName.toLowerCase();\n  let serializer: Serializer;\n\n  switch (format) {\n    case 'xmb':\n      serializer = new Xmb();\n      break;\n    case 'xliff2':\n    case 'xlf2':\n      serializer = new Xliff2();\n      break;\n    case 'xlf':\n    case 'xliff':\n    default:\n      serializer = new Xliff();\n  }\n\n  return bundle.write(serializer, getPathNormalizer(options.basePath));\n}\n\nfunction getPathNormalizer(basePath?: string) {\n  // normalize source paths by removing the base path and always using \"/\" as a separator\n  return (sourcePath: string) => {\n    sourcePath = basePath ? path.relative(basePath, sourcePath) : sourcePath;\n    return sourcePath.split(path.sep).join('/');\n  };\n}\n\nexport function i18nGetExtension(formatName: string): string {\n  const format = formatName.toLowerCase();\n\n  switch (format) {\n    case 'xmb':\n      return 'xmb';\n    case 'xlf':\n    case 'xlif':\n    case 'xliff':\n    case 'xlf2':\n    case 'xliff2':\n      return 'xlf';\n  }\n\n  throw new Error(`Unsupported format \"${formatName}\"`);\n}\n\nfunction mergeEmitResults(emitResults: ts.EmitResult[]): ts.EmitResult {\n  const diagnostics: ts.Diagnostic[] = [];\n  let emitSkipped = false;\n  const emittedFiles: string[] = [];\n  for (const er of emitResults) {\n    diagnostics.push(...er.diagnostics);\n    emitSkipped = emitSkipped || er.emitSkipped;\n    emittedFiles.push(...(er.emittedFiles || []));\n  }\n  return {diagnostics, emitSkipped, emittedFiles};\n}\n\nfunction diagnosticSourceOfSpan(span: ParseSourceSpan): ts.SourceFile {\n  // For diagnostics, TypeScript only uses the fileName and text properties.\n  // The redundant '()' are here is to avoid having clang-format breaking the line incorrectly.\n  return ({fileName: span.start.file.url, text: span.start.file.content} as any);\n}\n\nfunction diagnosticSourceOfFileName(fileName: string, program: ts.Program): ts.SourceFile {\n  const sourceFile = program.getSourceFile(fileName);\n  if (sourceFile) return sourceFile;\n\n  // If we are reporting diagnostics for a source file that is not in the project then we need\n  // to fake a source file so the diagnostic formatting routines can emit the file name.\n  // The redundant '()' are here is to avoid having clang-format breaking the line incorrectly.\n  return ({fileName, text: ''} as any);\n}\n\n\nfunction diagnosticChainFromFormattedDiagnosticChain(chain: FormattedMessageChain):\n    DiagnosticMessageChain {\n  return {\n    messageText: chain.message,\n    next: chain.next && chain.next.map(diagnosticChainFromFormattedDiagnosticChain),\n    position: chain.position\n  };\n}\n\nfunction syntaxErrorToDiagnostics(error: Error, program: ts.Program): Diagnostic[] {\n  const parserErrors = getParseErrors(error);\n  if (parserErrors && parserErrors.length) {\n    return parserErrors.map<Diagnostic>(e => ({\n                                          messageText: e.contextualMessage(),\n                                          file: diagnosticSourceOfSpan(e.span),\n                                          start: e.span.start.offset,\n                                          length: e.span.end.offset - e.span.start.offset,\n                                          category: ts.DiagnosticCategory.Error,\n                                          source: SOURCE,\n                                          code: DEFAULT_ERROR_CODE\n                                        }));\n  } else if (isFormattedError(error)) {\n    return [{\n      messageText: error.message,\n      chain: error.chain && diagnosticChainFromFormattedDiagnosticChain(error.chain),\n      category: ts.DiagnosticCategory.Error,\n      source: SOURCE,\n      code: DEFAULT_ERROR_CODE,\n      position: error.position\n    }];\n  }\n\n  const ngModuleErrorData = getMissingNgModuleMetadataErrorData(error);\n  if (ngModuleErrorData !== null) {\n    // This error represents the import or export of an `NgModule` that didn't have valid metadata.\n    // This _might_ happen because the NgModule in question is an Ivy-compiled library, and we want\n    // to show a more useful error if that's the case.\n    const ngModuleClass =\n        getDtsClass(program, ngModuleErrorData.fileName, ngModuleErrorData.className);\n    if (ngModuleClass !== null && isIvyNgModule(ngModuleClass)) {\n      return [{\n        messageText: `The NgModule '${ngModuleErrorData.className}' in '${\n            ngModuleErrorData\n                .fileName}' is imported by this compilation, but appears to be part of a library compiled for Angular Ivy. This may occur because:\n\n  1) the library was processed with 'ngcc'. Removing and reinstalling node_modules may fix this problem.\n\n  2) the library was published for Angular Ivy and v12+ applications only. Check its peer dependencies carefully and ensure that you're using a compatible version of Angular.\n\nSee https://angular.io/errors/NG6999 for more information.\n`,\n        category: ts.DiagnosticCategory.Error,\n        code: DEFAULT_ERROR_CODE,\n        source: SOURCE,\n      }];\n    }\n  }\n\n  // Produce a Diagnostic anyway since we know for sure `error` is a SyntaxError\n  return [{\n    messageText: error.message,\n    category: ts.DiagnosticCategory.Error,\n    code: DEFAULT_ERROR_CODE,\n    source: SOURCE,\n  }];\n}\n\nfunction getDtsClass(program: ts.Program, fileName: string, className: string): ts.ClassDeclaration|\n    null {\n  const sf = program.getSourceFile(fileName);\n  if (sf === undefined || !sf.isDeclarationFile) {\n    return null;\n  }\n  for (const stmt of sf.statements) {\n    if (!ts.isClassDeclaration(stmt)) {\n      continue;\n    }\n    if (stmt.name === undefined || stmt.name.text !== className) {\n      continue;\n    }\n\n    return stmt;\n  }\n\n  // No classes found that matched the given name.\n  return null;\n}\n\nfunction isIvyNgModule(clazz: ts.ClassDeclaration): boolean {\n  for (const member of clazz.members) {\n    if (!ts.isPropertyDeclaration(member)) {\n      continue;\n    }\n    if (ts.isIdentifier(member.name) && member.name.text === 'mod') {\n      return true;\n    }\n  }\n\n  // No Ivy 'mod' property found.\n  return false;\n}"],"sourceRoot":""},"metadata":{},"sourceType":"script"}