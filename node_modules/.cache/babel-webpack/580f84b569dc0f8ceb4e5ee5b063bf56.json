{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/annotations/src/directive\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"@angular/compiler/src/core\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph\", \"@angular/compiler-cli/src/ngtsc/metadata\", \"@angular/compiler-cli/src/ngtsc/metadata/src/util\", \"@angular/compiler-cli/src/ngtsc/partial_evaluator\", \"@angular/compiler-cli/src/ngtsc/perf\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/src/ngtsc/transform\", \"@angular/compiler-cli/src/ngtsc/annotations/src/diagnostics\", \"@angular/compiler-cli/src/ngtsc/annotations/src/factory\", \"@angular/compiler-cli/src/ngtsc/annotations/src/metadata\", \"@angular/compiler-cli/src/ngtsc/annotations/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.extractHostBindings = exports.queriesFromFields = exports.parseFieldArrayValue = exports.extractQueriesFromDecorator = exports.extractQueryMetadata = exports.extractDirectiveMetadata = exports.DirectiveDecoratorHandler = exports.DirectiveSymbol = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var core_1 = require(\"@angular/compiler/src/core\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var semantic_graph_1 = require(\"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph\");\n\n  var metadata_1 = require(\"@angular/compiler-cli/src/ngtsc/metadata\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/metadata/src/util\");\n\n  var partial_evaluator_1 = require(\"@angular/compiler-cli/src/ngtsc/partial_evaluator\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var transform_1 = require(\"@angular/compiler-cli/src/ngtsc/transform\");\n\n  var diagnostics_2 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/diagnostics\");\n\n  var factory_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/factory\");\n\n  var metadata_2 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/metadata\");\n\n  var util_2 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/util\");\n\n  var EMPTY_OBJECT = {};\n  var FIELD_DECORATORS = ['Input', 'Output', 'ViewChild', 'ViewChildren', 'ContentChild', 'ContentChildren', 'HostBinding', 'HostListener'];\n  var LIFECYCLE_HOOKS = new Set(['ngOnChanges', 'ngOnInit', 'ngOnDestroy', 'ngDoCheck', 'ngAfterViewInit', 'ngAfterViewChecked', 'ngAfterContentInit', 'ngAfterContentChecked']);\n  /**\n   * Represents an Angular directive. Components are represented by `ComponentSymbol`, which inherits\n   * from this symbol.\n   */\n\n  var DirectiveSymbol =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(DirectiveSymbol, _super);\n\n    function DirectiveSymbol(decl, selector, inputs, outputs, exportAs, typeCheckMeta, typeParameters) {\n      var _this = _super.call(this, decl) || this;\n\n      _this.selector = selector;\n      _this.inputs = inputs;\n      _this.outputs = outputs;\n      _this.exportAs = exportAs;\n      _this.typeCheckMeta = typeCheckMeta;\n      _this.typeParameters = typeParameters;\n      _this.baseClass = null;\n      return _this;\n    }\n\n    DirectiveSymbol.prototype.isPublicApiAffected = function (previousSymbol) {\n      // Note: since components and directives have exactly the same items contributing to their\n      // public API, it is okay for a directive to change into a component and vice versa without\n      // the API being affected.\n      if (!(previousSymbol instanceof DirectiveSymbol)) {\n        return true;\n      } // Directives and components have a public API of:\n      //  1. Their selector.\n      //  2. The binding names of their inputs and outputs; a change in ordering is also considered\n      //     to be a change in public API.\n      //  3. The list of exportAs names and its ordering.\n\n\n      return this.selector !== previousSymbol.selector || !semantic_graph_1.isArrayEqual(this.inputs.propertyNames, previousSymbol.inputs.propertyNames) || !semantic_graph_1.isArrayEqual(this.outputs.propertyNames, previousSymbol.outputs.propertyNames) || !semantic_graph_1.isArrayEqual(this.exportAs, previousSymbol.exportAs);\n    };\n\n    DirectiveSymbol.prototype.isTypeCheckApiAffected = function (previousSymbol) {\n      // If the public API of the directive has changed, then so has its type-check API.\n      if (this.isPublicApiAffected(previousSymbol)) {\n        return true;\n      }\n\n      if (!(previousSymbol instanceof DirectiveSymbol)) {\n        return true;\n      } // The type-check block also depends on the class property names, as writes property bindings\n      // directly into the backing fields.\n\n\n      if (!semantic_graph_1.isArrayEqual(Array.from(this.inputs), Array.from(previousSymbol.inputs), isInputMappingEqual) || !semantic_graph_1.isArrayEqual(Array.from(this.outputs), Array.from(previousSymbol.outputs), isInputMappingEqual)) {\n        return true;\n      } // The type parameters of a directive are emitted into the type constructors in the type-check\n      // block of a component, so if the type parameters are not considered equal then consider the\n      // type-check API of this directive to be affected.\n\n\n      if (!semantic_graph_1.areTypeParametersEqual(this.typeParameters, previousSymbol.typeParameters)) {\n        return true;\n      } // The type-check metadata is used during TCB code generation, so any changes should invalidate\n      // prior type-check files.\n\n\n      if (!isTypeCheckMetaEqual(this.typeCheckMeta, previousSymbol.typeCheckMeta)) {\n        return true;\n      } // Changing the base class of a directive means that its inputs/outputs etc may have changed,\n      // so the type-check block of components that use this directive needs to be regenerated.\n\n\n      if (!isBaseClassEqual(this.baseClass, previousSymbol.baseClass)) {\n        return true;\n      }\n\n      return false;\n    };\n\n    return DirectiveSymbol;\n  }(semantic_graph_1.SemanticSymbol);\n\n  exports.DirectiveSymbol = DirectiveSymbol;\n\n  function isInputMappingEqual(current, previous) {\n    return current[0] === previous[0] && current[1] === previous[1];\n  }\n\n  function isTypeCheckMetaEqual(current, previous) {\n    if (current.hasNgTemplateContextGuard !== previous.hasNgTemplateContextGuard) {\n      return false;\n    }\n\n    if (current.isGeneric !== previous.isGeneric) {\n      // Note: changes in the number of type parameters is also considered in `areTypeParametersEqual`\n      // so this check is technically not needed; it is done anyway for completeness in terms of\n      // whether the `DirectiveTypeCheckMeta` struct itself compares equal or not.\n      return false;\n    }\n\n    if (!semantic_graph_1.isArrayEqual(current.ngTemplateGuards, previous.ngTemplateGuards, isTemplateGuardEqual)) {\n      return false;\n    }\n\n    if (!semantic_graph_1.isSetEqual(current.coercedInputFields, previous.coercedInputFields)) {\n      return false;\n    }\n\n    if (!semantic_graph_1.isSetEqual(current.restrictedInputFields, previous.restrictedInputFields)) {\n      return false;\n    }\n\n    if (!semantic_graph_1.isSetEqual(current.stringLiteralInputFields, previous.stringLiteralInputFields)) {\n      return false;\n    }\n\n    if (!semantic_graph_1.isSetEqual(current.undeclaredInputFields, previous.undeclaredInputFields)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function isTemplateGuardEqual(current, previous) {\n    return current.inputName === previous.inputName && current.type === previous.type;\n  }\n\n  function isBaseClassEqual(current, previous) {\n    if (current === null || previous === null) {\n      return current === previous;\n    }\n\n    return semantic_graph_1.isSymbolEqual(current, previous);\n  }\n\n  var DirectiveDecoratorHandler =\n  /** @class */\n  function () {\n    function DirectiveDecoratorHandler(reflector, evaluator, metaRegistry, scopeRegistry, metaReader, injectableRegistry, isCore, semanticDepGraphUpdater, annotateForClosureCompiler, compileUndecoratedClassesWithAngularFeatures, perf) {\n      this.reflector = reflector;\n      this.evaluator = evaluator;\n      this.metaRegistry = metaRegistry;\n      this.scopeRegistry = scopeRegistry;\n      this.metaReader = metaReader;\n      this.injectableRegistry = injectableRegistry;\n      this.isCore = isCore;\n      this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n      this.annotateForClosureCompiler = annotateForClosureCompiler;\n      this.compileUndecoratedClassesWithAngularFeatures = compileUndecoratedClassesWithAngularFeatures;\n      this.perf = perf;\n      this.precedence = transform_1.HandlerPrecedence.PRIMARY;\n      this.name = DirectiveDecoratorHandler.name;\n    }\n\n    DirectiveDecoratorHandler.prototype.detect = function (node, decorators) {\n      // If a class is undecorated but uses Angular features, we detect it as an\n      // abstract directive. This is an unsupported pattern as of v10, but we want\n      // to still detect these patterns so that we can report diagnostics, or compile\n      // them for backwards compatibility in ngcc.\n      if (!decorators) {\n        var angularField = this.findClassFieldWithAngularFeatures(node);\n        return angularField ? {\n          trigger: angularField.node,\n          decorator: null,\n          metadata: null\n        } : undefined;\n      } else {\n        var decorator = util_2.findAngularDecorator(decorators, 'Directive', this.isCore);\n        return decorator ? {\n          trigger: decorator.node,\n          decorator: decorator,\n          metadata: decorator\n        } : undefined;\n      }\n    };\n\n    DirectiveDecoratorHandler.prototype.analyze = function (node, decorator, flags) {\n      if (flags === void 0) {\n        flags = transform_1.HandlerFlags.NONE;\n      } // Skip processing of the class declaration if compilation of undecorated classes\n      // with Angular features is disabled. Previously in ngtsc, such classes have always\n      // been processed, but we want to enforce a consistent decorator mental model.\n      // See: https://v9.angular.io/guide/migration-undecorated-classes.\n\n\n      if (this.compileUndecoratedClassesWithAngularFeatures === false && decorator === null) {\n        return {\n          diagnostics: [diagnostics_2.getUndecoratedClassWithAngularFeaturesDiagnostic(node)]\n        };\n      }\n\n      this.perf.eventCount(perf_1.PerfEvent.AnalyzeDirective);\n      var directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.isCore, flags, this.annotateForClosureCompiler);\n\n      if (directiveResult === undefined) {\n        return {};\n      }\n\n      var analysis = directiveResult.metadata;\n      var providersRequiringFactory = null;\n\n      if (directiveResult !== undefined && directiveResult.decorator.has('providers')) {\n        providersRequiringFactory = util_2.resolveProvidersRequiringFactory(directiveResult.decorator.get('providers'), this.reflector, this.evaluator);\n      }\n\n      return {\n        analysis: {\n          inputs: directiveResult.inputs,\n          outputs: directiveResult.outputs,\n          meta: analysis,\n          metadataStmt: metadata_2.generateSetClassMetadataCall(node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n          baseClass: util_2.readBaseClass(node, this.reflector, this.evaluator),\n          typeCheckMeta: util_1.extractDirectiveTypeCheckMeta(node, directiveResult.inputs, this.reflector),\n          providersRequiringFactory: providersRequiringFactory,\n          isPoisoned: false,\n          isStructural: directiveResult.isStructural\n        }\n      };\n    };\n\n    DirectiveDecoratorHandler.prototype.symbol = function (node, analysis) {\n      var typeParameters = semantic_graph_1.extractSemanticTypeParameters(node);\n      return new DirectiveSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);\n    };\n\n    DirectiveDecoratorHandler.prototype.register = function (node, analysis) {\n      // Register this directive's information with the `MetadataRegistry`. This ensures that\n      // the information about the directive is available during the compile() phase.\n      var ref = new imports_1.Reference(node);\n      this.metaRegistry.registerDirectiveMetadata(tslib_1.__assign(tslib_1.__assign({\n        ref: ref,\n        name: node.name.text,\n        selector: analysis.meta.selector,\n        exportAs: analysis.meta.exportAs,\n        inputs: analysis.inputs,\n        outputs: analysis.outputs,\n        queries: analysis.meta.queries.map(function (query) {\n          return query.propertyName;\n        }),\n        isComponent: false,\n        baseClass: analysis.baseClass\n      }, analysis.typeCheckMeta), {\n        isPoisoned: analysis.isPoisoned,\n        isStructural: analysis.isStructural\n      }));\n      this.injectableRegistry.registerInjectable(node);\n    };\n\n    DirectiveDecoratorHandler.prototype.resolve = function (node, analysis, symbol) {\n      if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof imports_1.Reference) {\n        symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n      }\n\n      var diagnostics = [];\n\n      if (analysis.providersRequiringFactory !== null && analysis.meta.providers instanceof compiler_1.WrappedNodeExpr) {\n        var providerDiagnostics = diagnostics_2.getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(providerDiagnostics));\n      }\n\n      var directiveDiagnostics = diagnostics_2.getDirectiveDiagnostics(node, this.metaReader, this.evaluator, this.reflector, this.scopeRegistry, 'Directive');\n\n      if (directiveDiagnostics !== null) {\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(directiveDiagnostics));\n      }\n\n      return {\n        diagnostics: diagnostics.length > 0 ? diagnostics : undefined\n      };\n    };\n\n    DirectiveDecoratorHandler.prototype.compileFull = function (node, analysis, resolution, pool) {\n      var def = compiler_1.compileDirectiveFromMetadata(analysis.meta, pool, compiler_1.makeBindingParser());\n      return this.compileDirective(analysis, def);\n    };\n\n    DirectiveDecoratorHandler.prototype.compilePartial = function (node, analysis, resolution) {\n      var def = compiler_1.compileDeclareDirectiveFromMetadata(analysis.meta);\n      return this.compileDirective(analysis, def);\n    };\n\n    DirectiveDecoratorHandler.prototype.compileDirective = function (analysis, _a) {\n      var initializer = _a.expression,\n          type = _a.type;\n      var factoryRes = factory_1.compileNgFactoryDefField(tslib_1.__assign(tslib_1.__assign({}, analysis.meta), {\n        injectFn: compiler_1.Identifiers.directiveInject,\n        target: compiler_1.R3FactoryTarget.Directive\n      }));\n\n      if (analysis.metadataStmt !== null) {\n        factoryRes.statements.push(analysis.metadataStmt);\n      }\n\n      return [factoryRes, {\n        name: 'Éµdir',\n        initializer: initializer,\n        statements: [],\n        type: type\n      }];\n    };\n    /**\n     * Checks if a given class uses Angular features and returns the TypeScript node\n     * that indicated the usage. Classes are considered using Angular features if they\n     * contain class members that are either decorated with a known Angular decorator,\n     * or if they correspond to a known Angular lifecycle hook.\n     */\n\n\n    DirectiveDecoratorHandler.prototype.findClassFieldWithAngularFeatures = function (node) {\n      var _this = this;\n\n      return this.reflector.getMembersOfClass(node).find(function (member) {\n        if (!member.isStatic && member.kind === reflection_1.ClassMemberKind.Method && LIFECYCLE_HOOKS.has(member.name)) {\n          return true;\n        }\n\n        if (member.decorators) {\n          return member.decorators.some(function (decorator) {\n            return FIELD_DECORATORS.some(function (decoratorName) {\n              return util_2.isAngularDecorator(decorator, decoratorName, _this.isCore);\n            });\n          });\n        }\n\n        return false;\n      });\n    };\n\n    return DirectiveDecoratorHandler;\n  }();\n\n  exports.DirectiveDecoratorHandler = DirectiveDecoratorHandler;\n  /**\n   * Helper function to extract metadata from a `Directive` or `Component`. `Directive`s without a\n   * selector are allowed to be used for abstract base classes. These abstract directives should not\n   * appear in the declarations of an `NgModule` and additional verification is done when processing\n   * the module.\n   */\n\n  function extractDirectiveMetadata(clazz, decorator, reflector, evaluator, isCore, flags, annotateForClosureCompiler, defaultSelector) {\n    if (defaultSelector === void 0) {\n      defaultSelector = null;\n    }\n\n    var directive;\n\n    if (decorator === null || decorator.args === null || decorator.args.length === 0) {\n      directive = new Map();\n    } else if (decorator.args.length !== 1) {\n      throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARITY_WRONG, reflection_1.Decorator.nodeForError(decorator), \"Incorrect number of arguments to @\" + decorator.name + \" decorator\");\n    } else {\n      var meta = util_2.unwrapExpression(decorator.args[0]);\n\n      if (!ts.isObjectLiteralExpression(meta)) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, \"@\" + decorator.name + \" argument must be an object literal\");\n      }\n\n      directive = reflection_1.reflectObjectLiteral(meta);\n    }\n\n    if (directive.has('jit')) {\n      // The only allowed value is true, so there's no need to expand further.\n      return undefined;\n    }\n\n    var members = reflector.getMembersOfClass(clazz); // Precompute a list of ts.ClassElements that have decorators. This includes things like @Input,\n    // @Output, @HostBinding, etc.\n\n    var decoratedElements = members.filter(function (member) {\n      return !member.isStatic && member.decorators !== null;\n    });\n    var coreModule = isCore ? undefined : '@angular/core'; // Construct the map of inputs both from the @Directive/@Component\n    // decorator, and the decorated\n    // fields.\n\n    var inputsFromMeta = parseFieldToPropertyMapping(directive, 'inputs', evaluator);\n    var inputsFromFields = parseDecoratedFields(reflection_1.filterToMembersWithDecorator(decoratedElements, 'Input', coreModule), evaluator, resolveInput); // And outputs.\n\n    var outputsFromMeta = parseFieldToPropertyMapping(directive, 'outputs', evaluator);\n    var outputsFromFields = parseDecoratedFields(reflection_1.filterToMembersWithDecorator(decoratedElements, 'Output', coreModule), evaluator, resolveOutput); // Construct the list of queries.\n\n    var contentChildFromFields = queriesFromFields(reflection_1.filterToMembersWithDecorator(decoratedElements, 'ContentChild', coreModule), reflector, evaluator);\n    var contentChildrenFromFields = queriesFromFields(reflection_1.filterToMembersWithDecorator(decoratedElements, 'ContentChildren', coreModule), reflector, evaluator);\n\n    var queries = tslib_1.__spread(contentChildFromFields, contentChildrenFromFields); // Construct the list of view queries.\n\n\n    var viewChildFromFields = queriesFromFields(reflection_1.filterToMembersWithDecorator(decoratedElements, 'ViewChild', coreModule), reflector, evaluator);\n    var viewChildrenFromFields = queriesFromFields(reflection_1.filterToMembersWithDecorator(decoratedElements, 'ViewChildren', coreModule), reflector, evaluator);\n\n    var viewQueries = tslib_1.__spread(viewChildFromFields, viewChildrenFromFields);\n\n    if (directive.has('queries')) {\n      var queriesFromDecorator = extractQueriesFromDecorator(directive.get('queries'), reflector, evaluator, isCore);\n      queries.push.apply(queries, tslib_1.__spread(queriesFromDecorator.content));\n      viewQueries.push.apply(viewQueries, tslib_1.__spread(queriesFromDecorator.view));\n    } // Parse the selector.\n\n\n    var selector = defaultSelector;\n\n    if (directive.has('selector')) {\n      var expr = directive.get('selector');\n      var resolved = evaluator.evaluate(expr);\n\n      if (typeof resolved !== 'string') {\n        throw diagnostics_2.createValueHasWrongTypeError(expr, resolved, \"selector must be a string\");\n      } // use default selector in case selector is an empty string\n\n\n      selector = resolved === '' ? defaultSelector : resolved;\n\n      if (!selector) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DIRECTIVE_MISSING_SELECTOR, expr, \"Directive \" + clazz.name.text + \" has no selector, please add it!\");\n      }\n    }\n\n    var host = extractHostBindings(decoratedElements, evaluator, coreModule, directive);\n    var providers = directive.has('providers') ? new compiler_1.WrappedNodeExpr(annotateForClosureCompiler ? util_2.wrapFunctionExpressionsInParens(directive.get('providers')) : directive.get('providers')) : null; // Determine if `ngOnChanges` is a lifecycle hook defined on the component.\n\n    var usesOnChanges = members.some(function (member) {\n      return !member.isStatic && member.kind === reflection_1.ClassMemberKind.Method && member.name === 'ngOnChanges';\n    }); // Parse exportAs.\n\n    var exportAs = null;\n\n    if (directive.has('exportAs')) {\n      var expr = directive.get('exportAs');\n      var resolved = evaluator.evaluate(expr);\n\n      if (typeof resolved !== 'string') {\n        throw diagnostics_2.createValueHasWrongTypeError(expr, resolved, \"exportAs must be a string\");\n      }\n\n      exportAs = resolved.split(',').map(function (part) {\n        return part.trim();\n      });\n    }\n\n    var rawCtorDeps = util_2.getConstructorDependencies(clazz, reflector, isCore);\n    var ctorDeps; // Non-abstract directives (those with a selector) require valid constructor dependencies, whereas\n    // abstract directives are allowed to have invalid dependencies, given that a subclass may call\n    // the constructor explicitly.\n\n    if (selector !== null) {\n      ctorDeps = util_2.validateConstructorDependencies(clazz, rawCtorDeps);\n    } else {\n      ctorDeps = util_2.unwrapConstructorDependencies(rawCtorDeps);\n    }\n\n    var isStructural = ctorDeps !== null && ctorDeps !== 'invalid' && ctorDeps.some(function (dep) {\n      if (dep.resolved !== compiler_1.R3ResolvedDependencyType.Token || !(dep.token instanceof compiler_1.ExternalExpr)) {\n        return false;\n      }\n\n      if (dep.token.value.moduleName !== '@angular/core' || dep.token.value.name !== 'TemplateRef') {\n        return false;\n      }\n\n      return true;\n    }); // Detect if the component inherits from another class\n\n    var usesInheritance = reflector.hasBaseClass(clazz);\n    var type = util_2.wrapTypeReference(reflector, clazz);\n    var internalType = new compiler_1.WrappedNodeExpr(reflector.getInternalNameOfClass(clazz));\n    var inputs = metadata_1.ClassPropertyMapping.fromMappedObject(tslib_1.__assign(tslib_1.__assign({}, inputsFromMeta), inputsFromFields));\n    var outputs = metadata_1.ClassPropertyMapping.fromMappedObject(tslib_1.__assign(tslib_1.__assign({}, outputsFromMeta), outputsFromFields));\n    var metadata = {\n      name: clazz.name.text,\n      deps: ctorDeps,\n      host: host,\n      lifecycle: {\n        usesOnChanges: usesOnChanges\n      },\n      inputs: inputs.toJointMappedObject(),\n      outputs: outputs.toDirectMappedObject(),\n      queries: queries,\n      viewQueries: viewQueries,\n      selector: selector,\n      fullInheritance: !!(flags & transform_1.HandlerFlags.FULL_INHERITANCE),\n      type: type,\n      internalType: internalType,\n      typeArgumentCount: reflector.getGenericArityOfClass(clazz) || 0,\n      typeSourceSpan: util_2.createSourceSpan(clazz.name),\n      usesInheritance: usesInheritance,\n      exportAs: exportAs,\n      providers: providers\n    };\n    return {\n      decorator: directive,\n      metadata: metadata,\n      inputs: inputs,\n      outputs: outputs,\n      isStructural: isStructural\n    };\n  }\n\n  exports.extractDirectiveMetadata = extractDirectiveMetadata;\n\n  function extractQueryMetadata(exprNode, name, args, propertyName, reflector, evaluator) {\n    if (args.length === 0) {\n      throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARITY_WRONG, exprNode, \"@\" + name + \" must have arguments\");\n    }\n\n    var first = name === 'ViewChild' || name === 'ContentChild';\n    var node = util_2.unwrapForwardRef(args[0], reflector);\n    var arg = evaluator.evaluate(node);\n    /** Whether or not this query should collect only static results (see view/api.ts)  */\n\n    var isStatic = false; // Extract the predicate\n\n    var predicate = null;\n\n    if (arg instanceof imports_1.Reference || arg instanceof partial_evaluator_1.DynamicValue) {\n      // References and predicates that could not be evaluated statically are emitted as is.\n      predicate = new compiler_1.WrappedNodeExpr(node);\n    } else if (typeof arg === 'string') {\n      predicate = [arg];\n    } else if (isStringArrayOrDie(arg, \"@\" + name + \" predicate\", node)) {\n      predicate = arg;\n    } else {\n      throw diagnostics_2.createValueHasWrongTypeError(node, arg, \"@\" + name + \" predicate cannot be interpreted\");\n    } // Extract the read and descendants options.\n\n\n    var read = null; // The default value for descendants is true for every decorator except @ContentChildren.\n\n    var descendants = name !== 'ContentChildren';\n    var emitDistinctChangesOnly = core_1.emitDistinctChangesOnlyDefaultValue;\n\n    if (args.length === 2) {\n      var optionsExpr = util_2.unwrapExpression(args[1]);\n\n      if (!ts.isObjectLiteralExpression(optionsExpr)) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARG_NOT_LITERAL, optionsExpr, \"@\" + name + \" options must be an object literal\");\n      }\n\n      var options = reflection_1.reflectObjectLiteral(optionsExpr);\n\n      if (options.has('read')) {\n        read = new compiler_1.WrappedNodeExpr(options.get('read'));\n      }\n\n      if (options.has('descendants')) {\n        var descendantsExpr = options.get('descendants');\n        var descendantsValue = evaluator.evaluate(descendantsExpr);\n\n        if (typeof descendantsValue !== 'boolean') {\n          throw diagnostics_2.createValueHasWrongTypeError(descendantsExpr, descendantsValue, \"@\" + name + \" options.descendants must be a boolean\");\n        }\n\n        descendants = descendantsValue;\n      }\n\n      if (options.has('emitDistinctChangesOnly')) {\n        var emitDistinctChangesOnlyExpr = options.get('emitDistinctChangesOnly');\n        var emitDistinctChangesOnlyValue = evaluator.evaluate(emitDistinctChangesOnlyExpr);\n\n        if (typeof emitDistinctChangesOnlyValue !== 'boolean') {\n          throw diagnostics_2.createValueHasWrongTypeError(emitDistinctChangesOnlyExpr, emitDistinctChangesOnlyValue, \"@\" + name + \" options.emitDistinctChangesOnlys must be a boolean\");\n        }\n\n        emitDistinctChangesOnly = emitDistinctChangesOnlyValue;\n      }\n\n      if (options.has('static')) {\n        var staticValue = evaluator.evaluate(options.get('static'));\n\n        if (typeof staticValue !== 'boolean') {\n          throw diagnostics_2.createValueHasWrongTypeError(node, staticValue, \"@\" + name + \" options.static must be a boolean\");\n        }\n\n        isStatic = staticValue;\n      }\n    } else if (args.length > 2) {\n      // Too many arguments.\n      throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARITY_WRONG, node, \"@\" + name + \" has too many arguments\");\n    }\n\n    return {\n      propertyName: propertyName,\n      predicate: predicate,\n      first: first,\n      descendants: descendants,\n      read: read,\n      static: isStatic,\n      emitDistinctChangesOnly: emitDistinctChangesOnly\n    };\n  }\n\n  exports.extractQueryMetadata = extractQueryMetadata;\n\n  function extractQueriesFromDecorator(queryData, reflector, evaluator, isCore) {\n    var content = [],\n        view = [];\n\n    if (!ts.isObjectLiteralExpression(queryData)) {\n      throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator queries metadata must be an object literal');\n    }\n\n    reflection_1.reflectObjectLiteral(queryData).forEach(function (queryExpr, propertyName) {\n      queryExpr = util_2.unwrapExpression(queryExpr);\n\n      if (!ts.isNewExpression(queryExpr)) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator query metadata must be an instance of a query type');\n      }\n\n      var queryType = ts.isPropertyAccessExpression(queryExpr.expression) ? queryExpr.expression.name : queryExpr.expression;\n\n      if (!ts.isIdentifier(queryType)) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator query metadata must be an instance of a query type');\n      }\n\n      var type = reflector.getImportOfIdentifier(queryType);\n\n      if (type === null || !isCore && type.from !== '@angular/core' || !QUERY_TYPES.has(type.name)) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator query metadata must be an instance of a query type');\n      }\n\n      var query = extractQueryMetadata(queryExpr, type.name, queryExpr.arguments || [], propertyName, reflector, evaluator);\n\n      if (type.name.startsWith('Content')) {\n        content.push(query);\n      } else {\n        view.push(query);\n      }\n    });\n    return {\n      content: content,\n      view: view\n    };\n  }\n\n  exports.extractQueriesFromDecorator = extractQueriesFromDecorator;\n\n  function isStringArrayOrDie(value, name, node) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n\n    for (var i = 0; i < value.length; i++) {\n      if (typeof value[i] !== 'string') {\n        throw diagnostics_2.createValueHasWrongTypeError(node, value[i], \"Failed to resolve \" + name + \" at position \" + i + \" to a string\");\n      }\n    }\n\n    return true;\n  }\n\n  function parseFieldArrayValue(directive, field, evaluator) {\n    if (!directive.has(field)) {\n      return null;\n    } // Resolve the field of interest from the directive metadata to a string[].\n\n\n    var expression = directive.get(field);\n    var value = evaluator.evaluate(expression);\n\n    if (!isStringArrayOrDie(value, field, expression)) {\n      throw diagnostics_2.createValueHasWrongTypeError(expression, value, \"Failed to resolve @Directive.\" + field + \" to a string array\");\n    }\n\n    return value;\n  }\n\n  exports.parseFieldArrayValue = parseFieldArrayValue;\n  /**\n   * Interpret property mapping fields on the decorator (e.g. inputs or outputs) and return the\n   * correctly shaped metadata object.\n   */\n\n  function parseFieldToPropertyMapping(directive, field, evaluator) {\n    var metaValues = parseFieldArrayValue(directive, field, evaluator);\n\n    if (!metaValues) {\n      return EMPTY_OBJECT;\n    }\n\n    return metaValues.reduce(function (results, value) {\n      // Either the value is 'field' or 'field: property'. In the first case, `property` will\n      // be undefined, in which case the field name should also be used as the property name.\n      var _a = tslib_1.__read(value.split(':', 2).map(function (str) {\n        return str.trim();\n      }), 2),\n          field = _a[0],\n          property = _a[1];\n\n      results[field] = property || field;\n      return results;\n    }, {});\n  }\n  /**\n   * Parse property decorators (e.g. `Input` or `Output`) and return the correctly shaped metadata\n   * object.\n   */\n\n\n  function parseDecoratedFields(fields, evaluator, mapValueResolver) {\n    return fields.reduce(function (results, field) {\n      var fieldName = field.member.name;\n      field.decorators.forEach(function (decorator) {\n        // The decorator either doesn't have an argument (@Input()) in which case the property\n        // name is used, or it has one argument (@Output('named')).\n        if (decorator.args == null || decorator.args.length === 0) {\n          results[fieldName] = fieldName;\n        } else if (decorator.args.length === 1) {\n          var property = evaluator.evaluate(decorator.args[0]);\n\n          if (typeof property !== 'string') {\n            throw diagnostics_2.createValueHasWrongTypeError(reflection_1.Decorator.nodeForError(decorator), property, \"@\" + decorator.name + \" decorator argument must resolve to a string\");\n          }\n\n          results[fieldName] = mapValueResolver(property, fieldName);\n        } else {\n          // Too many arguments.\n          throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARITY_WRONG, reflection_1.Decorator.nodeForError(decorator), \"@\" + decorator.name + \" can have at most one argument, got \" + decorator.args.length + \" argument(s)\");\n        }\n      });\n      return results;\n    }, {});\n  }\n\n  function resolveInput(publicName, internalName) {\n    return [publicName, internalName];\n  }\n\n  function resolveOutput(publicName, internalName) {\n    return publicName;\n  }\n\n  function queriesFromFields(fields, reflector, evaluator) {\n    return fields.map(function (_a) {\n      var member = _a.member,\n          decorators = _a.decorators;\n      var decorator = decorators[0];\n      var node = member.node || reflection_1.Decorator.nodeForError(decorator); // Throw in case of `@Input() @ContentChild('foo') foo: any`, which is not supported in Ivy\n\n      if (member.decorators.some(function (v) {\n        return v.name === 'Input';\n      })) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_COLLISION, node, 'Cannot combine @Input decorators with query decorators');\n      }\n\n      if (decorators.length !== 1) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_COLLISION, node, 'Cannot have multiple query decorators on the same class member');\n      } else if (!isPropertyTypeMember(member)) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_UNEXPECTED, node, 'Query decorator must go on a property-type member');\n      }\n\n      return extractQueryMetadata(node, decorator.name, decorator.args || [], member.name, reflector, evaluator);\n    });\n  }\n\n  exports.queriesFromFields = queriesFromFields;\n\n  function isPropertyTypeMember(member) {\n    return member.kind === reflection_1.ClassMemberKind.Getter || member.kind === reflection_1.ClassMemberKind.Setter || member.kind === reflection_1.ClassMemberKind.Property;\n  }\n\n  function evaluateHostExpressionBindings(hostExpr, evaluator) {\n    var hostMetaMap = evaluator.evaluate(hostExpr);\n\n    if (!(hostMetaMap instanceof Map)) {\n      throw diagnostics_2.createValueHasWrongTypeError(hostExpr, hostMetaMap, \"Decorator host metadata must be an object\");\n    }\n\n    var hostMetadata = {};\n    hostMetaMap.forEach(function (value, key) {\n      // Resolve Enum references to their declared value.\n      if (value instanceof partial_evaluator_1.EnumValue) {\n        value = value.resolved;\n      }\n\n      if (typeof key !== 'string') {\n        throw diagnostics_2.createValueHasWrongTypeError(hostExpr, key, \"Decorator host metadata must be a string -> string object, but found unparseable key\");\n      }\n\n      if (typeof value == 'string') {\n        hostMetadata[key] = value;\n      } else if (value instanceof partial_evaluator_1.DynamicValue) {\n        hostMetadata[key] = new compiler_1.WrappedNodeExpr(value.node);\n      } else {\n        throw diagnostics_2.createValueHasWrongTypeError(hostExpr, value, \"Decorator host metadata must be a string -> string object, but found unparseable value\");\n      }\n    });\n    var bindings = compiler_1.parseHostBindings(hostMetadata);\n    var errors = compiler_1.verifyHostBindings(bindings, util_2.createSourceSpan(hostExpr));\n\n    if (errors.length > 0) {\n      throw new diagnostics_1.FatalDiagnosticError( // TODO: provide more granular diagnostic and output specific host expression that\n      // triggered an error instead of the whole host object.\n      diagnostics_1.ErrorCode.HOST_BINDING_PARSE_ERROR, hostExpr, errors.map(function (error) {\n        return error.msg;\n      }).join('\\n'));\n    }\n\n    return bindings;\n  }\n\n  function extractHostBindings(members, evaluator, coreModule, metadata) {\n    var bindings;\n\n    if (metadata && metadata.has('host')) {\n      bindings = evaluateHostExpressionBindings(metadata.get('host'), evaluator);\n    } else {\n      bindings = compiler_1.parseHostBindings({});\n    }\n\n    reflection_1.filterToMembersWithDecorator(members, 'HostBinding', coreModule).forEach(function (_a) {\n      var member = _a.member,\n          decorators = _a.decorators;\n      decorators.forEach(function (decorator) {\n        var hostPropertyName = member.name;\n\n        if (decorator.args !== null && decorator.args.length > 0) {\n          if (decorator.args.length !== 1) {\n            throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARITY_WRONG, reflection_1.Decorator.nodeForError(decorator), \"@HostBinding can have at most one argument, got \" + decorator.args.length + \" argument(s)\");\n          }\n\n          var resolved = evaluator.evaluate(decorator.args[0]);\n\n          if (typeof resolved !== 'string') {\n            throw diagnostics_2.createValueHasWrongTypeError(reflection_1.Decorator.nodeForError(decorator), resolved, \"@HostBinding's argument must be a string\");\n          }\n\n          hostPropertyName = resolved;\n        } // Since this is a decorator, we know that the value is a class member. Always access it\n        // through `this` so that further down the line it can't be confused for a literal value\n        // (e.g. if there's a property called `true`). There is no size penalty, because all\n        // values (except literals) are converted to `ctx.propName` eventually.\n\n\n        bindings.properties[hostPropertyName] = compiler_1.getSafePropertyAccessString('this', member.name);\n      });\n    });\n    reflection_1.filterToMembersWithDecorator(members, 'HostListener', coreModule).forEach(function (_a) {\n      var member = _a.member,\n          decorators = _a.decorators;\n      decorators.forEach(function (decorator) {\n        var eventName = member.name;\n        var args = [];\n\n        if (decorator.args !== null && decorator.args.length > 0) {\n          if (decorator.args.length > 2) {\n            throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], \"@HostListener can have at most two arguments\");\n          }\n\n          var resolved = evaluator.evaluate(decorator.args[0]);\n\n          if (typeof resolved !== 'string') {\n            throw diagnostics_2.createValueHasWrongTypeError(decorator.args[0], resolved, \"@HostListener's event name argument must be a string\");\n          }\n\n          eventName = resolved;\n\n          if (decorator.args.length === 2) {\n            var expression = decorator.args[1];\n            var resolvedArgs = evaluator.evaluate(decorator.args[1]);\n\n            if (!isStringArrayOrDie(resolvedArgs, '@HostListener.args', expression)) {\n              throw diagnostics_2.createValueHasWrongTypeError(decorator.args[1], resolvedArgs, \"@HostListener's second argument must be a string array\");\n            }\n\n            args = resolvedArgs;\n          }\n        }\n\n        bindings.listeners[eventName] = member.name + \"(\" + args.join(',') + \")\";\n      });\n    });\n    return bindings;\n  }\n\n  exports.extractHostBindings = extractHostBindings;\n  var QUERY_TYPES = new Set(['ContentChild', 'ContentChildren', 'ViewChild', 'ViewChildren']);\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/directive.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {compileDeclareDirectiveFromMetadata, compileDirectiveFromMetadata, ConstantPool, Expression, ExternalExpr, getSafePropertyAccessString, Identifiers, makeBindingParser, ParsedHostBindings, ParseError, parseHostBindings, R3DependencyMetadata, R3DirectiveDef, R3DirectiveMetadata, R3FactoryTarget, R3QueryMetadata, R3ResolvedDependencyType, Statement, verifyHostBindings, WrappedNodeExpr} from '@angular/compiler';\nimport {emitDistinctChangesOnlyDefaultValue} from '@angular/compiler/src/core';\nimport * as ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\nimport {absoluteFromSourceFile} from '../../file_system';\nimport {Reference} from '../../imports';\nimport {areTypeParametersEqual, extractSemanticTypeParameters, isArrayEqual, isSetEqual, isSymbolEqual, SemanticDepGraphUpdater, SemanticSymbol, SemanticTypeParameter} from '../../incremental/semantic_graph';\nimport {BindingPropertyName, ClassPropertyMapping, ClassPropertyName, DirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry, TemplateGuardMeta} from '../../metadata';\nimport {extractDirectiveTypeCheckMeta} from '../../metadata/src/util';\nimport {DynamicValue, EnumValue, PartialEvaluator} from '../../partial_evaluator';\nimport {PerfEvent, PerfRecorder} from '../../perf';\nimport {ClassDeclaration, ClassMember, ClassMemberKind, Decorator, filterToMembersWithDecorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\nimport {LocalModuleScopeRegistry} from '../../scope';\nimport {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerFlags, HandlerPrecedence, ResolveResult} from '../../transform';\n\nimport {createValueHasWrongTypeError, getDirectiveDiagnostics, getProviderDiagnostics, getUndecoratedClassWithAngularFeaturesDiagnostic} from './diagnostics';\nimport {compileNgFactoryDefField} from './factory';\nimport {generateSetClassMetadataCall} from './metadata';\nimport {createSourceSpan, findAngularDecorator, getConstructorDependencies, isAngularDecorator, readBaseClass, resolveProvidersRequiringFactory, unwrapConstructorDependencies, unwrapExpression, unwrapForwardRef, validateConstructorDependencies, wrapFunctionExpressionsInParens, wrapTypeReference} from './util';\n\nconst EMPTY_OBJECT: {[key: string]: string} = {};\nconst FIELD_DECORATORS = [\n  'Input', 'Output', 'ViewChild', 'ViewChildren', 'ContentChild', 'ContentChildren', 'HostBinding',\n  'HostListener'\n];\nconst LIFECYCLE_HOOKS = new Set([\n  'ngOnChanges', 'ngOnInit', 'ngOnDestroy', 'ngDoCheck', 'ngAfterViewInit', 'ngAfterViewChecked',\n  'ngAfterContentInit', 'ngAfterContentChecked'\n]);\n\nexport interface DirectiveHandlerData {\n  baseClass: Reference<ClassDeclaration>|'dynamic'|null;\n  typeCheckMeta: DirectiveTypeCheckMeta;\n  meta: R3DirectiveMetadata;\n  metadataStmt: Statement|null;\n  providersRequiringFactory: Set<Reference<ClassDeclaration>>|null;\n  inputs: ClassPropertyMapping;\n  outputs: ClassPropertyMapping;\n  isPoisoned: boolean;\n  isStructural: boolean;\n}\n\n/**\n * Represents an Angular directive. Components are represented by `ComponentSymbol`, which inherits\n * from this symbol.\n */\nexport class DirectiveSymbol extends SemanticSymbol {\n  baseClass: SemanticSymbol|null = null;\n\n  constructor(\n      decl: ClassDeclaration, public readonly selector: string|null,\n      public readonly inputs: ClassPropertyMapping, public readonly outputs: ClassPropertyMapping,\n      public readonly exportAs: string[]|null,\n      public readonly typeCheckMeta: DirectiveTypeCheckMeta,\n      public readonly typeParameters: SemanticTypeParameter[]|null) {\n    super(decl);\n  }\n\n  isPublicApiAffected(previousSymbol: SemanticSymbol): boolean {\n    // Note: since components and directives have exactly the same items contributing to their\n    // public API, it is okay for a directive to change into a component and vice versa without\n    // the API being affected.\n    if (!(previousSymbol instanceof DirectiveSymbol)) {\n      return true;\n    }\n\n    // Directives and components have a public API of:\n    //  1. Their selector.\n    //  2. The binding names of their inputs and outputs; a change in ordering is also considered\n    //     to be a change in public API.\n    //  3. The list of exportAs names and its ordering.\n    return this.selector !== previousSymbol.selector ||\n        !isArrayEqual(this.inputs.propertyNames, previousSymbol.inputs.propertyNames) ||\n        !isArrayEqual(this.outputs.propertyNames, previousSymbol.outputs.propertyNames) ||\n        !isArrayEqual(this.exportAs, previousSymbol.exportAs);\n  }\n\n  isTypeCheckApiAffected(previousSymbol: SemanticSymbol): boolean {\n    // If the public API of the directive has changed, then so has its type-check API.\n    if (this.isPublicApiAffected(previousSymbol)) {\n      return true;\n    }\n\n    if (!(previousSymbol instanceof DirectiveSymbol)) {\n      return true;\n    }\n\n    // The type-check block also depends on the class property names, as writes property bindings\n    // directly into the backing fields.\n    if (!isArrayEqual(\n            Array.from(this.inputs), Array.from(previousSymbol.inputs), isInputMappingEqual) ||\n        !isArrayEqual(\n            Array.from(this.outputs), Array.from(previousSymbol.outputs), isInputMappingEqual)) {\n      return true;\n    }\n\n    // The type parameters of a directive are emitted into the type constructors in the type-check\n    // block of a component, so if the type parameters are not considered equal then consider the\n    // type-check API of this directive to be affected.\n    if (!areTypeParametersEqual(this.typeParameters, previousSymbol.typeParameters)) {\n      return true;\n    }\n\n    // The type-check metadata is used during TCB code generation, so any changes should invalidate\n    // prior type-check files.\n    if (!isTypeCheckMetaEqual(this.typeCheckMeta, previousSymbol.typeCheckMeta)) {\n      return true;\n    }\n\n    // Changing the base class of a directive means that its inputs/outputs etc may have changed,\n    // so the type-check block of components that use this directive needs to be regenerated.\n    if (!isBaseClassEqual(this.baseClass, previousSymbol.baseClass)) {\n      return true;\n    }\n\n    return false;\n  }\n}\n\nfunction isInputMappingEqual(\n    current: [ClassPropertyName, BindingPropertyName],\n    previous: [ClassPropertyName, BindingPropertyName]): boolean {\n  return current[0] === previous[0] && current[1] === previous[1];\n}\n\nfunction isTypeCheckMetaEqual(\n    current: DirectiveTypeCheckMeta, previous: DirectiveTypeCheckMeta): boolean {\n  if (current.hasNgTemplateContextGuard !== previous.hasNgTemplateContextGuard) {\n    return false;\n  }\n  if (current.isGeneric !== previous.isGeneric) {\n    // Note: changes in the number of type parameters is also considered in `areTypeParametersEqual`\n    // so this check is technically not needed; it is done anyway for completeness in terms of\n    // whether the `DirectiveTypeCheckMeta` struct itself compares equal or not.\n    return false;\n  }\n  if (!isArrayEqual(current.ngTemplateGuards, previous.ngTemplateGuards, isTemplateGuardEqual)) {\n    return false;\n  }\n  if (!isSetEqual(current.coercedInputFields, previous.coercedInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.restrictedInputFields, previous.restrictedInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.stringLiteralInputFields, previous.stringLiteralInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.undeclaredInputFields, previous.undeclaredInputFields)) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTemplateGuardEqual(current: TemplateGuardMeta, previous: TemplateGuardMeta): boolean {\n  return current.inputName === previous.inputName && current.type === previous.type;\n}\n\nfunction isBaseClassEqual(current: SemanticSymbol|null, previous: SemanticSymbol|null): boolean {\n  if (current === null || previous === null) {\n    return current === previous;\n  }\n\n  return isSymbolEqual(current, previous);\n}\n\nexport class DirectiveDecoratorHandler implements\n    DecoratorHandler<Decorator|null, DirectiveHandlerData, DirectiveSymbol, unknown> {\n  constructor(\n      private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n      private metaRegistry: MetadataRegistry, private scopeRegistry: LocalModuleScopeRegistry,\n      private metaReader: MetadataReader, private injectableRegistry: InjectableClassRegistry,\n      private isCore: boolean, private semanticDepGraphUpdater: SemanticDepGraphUpdater|null,\n      private annotateForClosureCompiler: boolean,\n      private compileUndecoratedClassesWithAngularFeatures: boolean, private perf: PerfRecorder) {}\n\n  readonly precedence = HandlerPrecedence.PRIMARY;\n  readonly name = DirectiveDecoratorHandler.name;\n\n  detect(node: ClassDeclaration, decorators: Decorator[]|null):\n      DetectResult<Decorator|null>|undefined {\n    // If a class is undecorated but uses Angular features, we detect it as an\n    // abstract directive. This is an unsupported pattern as of v10, but we want\n    // to still detect these patterns so that we can report diagnostics, or compile\n    // them for backwards compatibility in ngcc.\n    if (!decorators) {\n      const angularField = this.findClassFieldWithAngularFeatures(node);\n      return angularField ? {trigger: angularField.node, decorator: null, metadata: null} :\n                            undefined;\n    } else {\n      const decorator = findAngularDecorator(decorators, 'Directive', this.isCore);\n      return decorator ? {trigger: decorator.node, decorator, metadata: decorator} : undefined;\n    }\n  }\n\n  analyze(node: ClassDeclaration, decorator: Readonly<Decorator|null>, flags = HandlerFlags.NONE):\n      AnalysisOutput<DirectiveHandlerData> {\n    // Skip processing of the class declaration if compilation of undecorated classes\n    // with Angular features is disabled. Previously in ngtsc, such classes have always\n    // been processed, but we want to enforce a consistent decorator mental model.\n    // See: https://v9.angular.io/guide/migration-undecorated-classes.\n    if (this.compileUndecoratedClassesWithAngularFeatures === false && decorator === null) {\n      return {diagnostics: [getUndecoratedClassWithAngularFeaturesDiagnostic(node)]};\n    }\n\n    this.perf.eventCount(PerfEvent.AnalyzeDirective);\n\n    const directiveResult = extractDirectiveMetadata(\n        node, decorator, this.reflector, this.evaluator, this.isCore, flags,\n        this.annotateForClosureCompiler);\n    if (directiveResult === undefined) {\n      return {};\n    }\n    const analysis = directiveResult.metadata;\n\n    let providersRequiringFactory: Set<Reference<ClassDeclaration>>|null = null;\n    if (directiveResult !== undefined && directiveResult.decorator.has('providers')) {\n      providersRequiringFactory = resolveProvidersRequiringFactory(\n          directiveResult.decorator.get('providers')!, this.reflector, this.evaluator);\n    }\n\n    return {\n      analysis: {\n        inputs: directiveResult.inputs,\n        outputs: directiveResult.outputs,\n        meta: analysis,\n        metadataStmt: generateSetClassMetadataCall(\n            node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n        baseClass: readBaseClass(node, this.reflector, this.evaluator),\n        typeCheckMeta: extractDirectiveTypeCheckMeta(node, directiveResult.inputs, this.reflector),\n        providersRequiringFactory,\n        isPoisoned: false,\n        isStructural: directiveResult.isStructural,\n      }\n    };\n  }\n\n  symbol(node: ClassDeclaration, analysis: Readonly<DirectiveHandlerData>): DirectiveSymbol {\n    const typeParameters = extractSemanticTypeParameters(node);\n\n    return new DirectiveSymbol(\n        node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs,\n        analysis.typeCheckMeta, typeParameters);\n  }\n\n  register(node: ClassDeclaration, analysis: Readonly<DirectiveHandlerData>): void {\n    // Register this directive's information with the `MetadataRegistry`. This ensures that\n    // the information about the directive is available during the compile() phase.\n    const ref = new Reference(node);\n    this.metaRegistry.registerDirectiveMetadata({\n      ref,\n      name: node.name.text,\n      selector: analysis.meta.selector,\n      exportAs: analysis.meta.exportAs,\n      inputs: analysis.inputs,\n      outputs: analysis.outputs,\n      queries: analysis.meta.queries.map(query => query.propertyName),\n      isComponent: false,\n      baseClass: analysis.baseClass,\n      ...analysis.typeCheckMeta,\n      isPoisoned: analysis.isPoisoned,\n      isStructural: analysis.isStructural,\n    });\n\n    this.injectableRegistry.registerInjectable(node);\n  }\n\n  resolve(node: ClassDeclaration, analysis: DirectiveHandlerData, symbol: DirectiveSymbol):\n      ResolveResult<unknown> {\n    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n    }\n\n    const diagnostics: ts.Diagnostic[] = [];\n    if (analysis.providersRequiringFactory !== null &&\n        analysis.meta.providers instanceof WrappedNodeExpr) {\n      const providerDiagnostics = getProviderDiagnostics(\n          analysis.providersRequiringFactory, analysis.meta.providers!.node,\n          this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n\n    const directiveDiagnostics = getDirectiveDiagnostics(\n        node, this.metaReader, this.evaluator, this.reflector, this.scopeRegistry, 'Directive');\n    if (directiveDiagnostics !== null) {\n      diagnostics.push(...directiveDiagnostics);\n    }\n\n    return {diagnostics: diagnostics.length > 0 ? diagnostics : undefined};\n  }\n\n  compileFull(\n      node: ClassDeclaration, analysis: Readonly<DirectiveHandlerData>,\n      resolution: Readonly<unknown>, pool: ConstantPool): CompileResult[] {\n    const def = compileDirectiveFromMetadata(analysis.meta, pool, makeBindingParser());\n    return this.compileDirective(analysis, def);\n  }\n\n  compilePartial(\n      node: ClassDeclaration, analysis: Readonly<DirectiveHandlerData>,\n      resolution: Readonly<unknown>): CompileResult[] {\n    const def = compileDeclareDirectiveFromMetadata(analysis.meta);\n    return this.compileDirective(analysis, def);\n  }\n\n  private compileDirective(\n      analysis: Readonly<DirectiveHandlerData>,\n      {expression: initializer, type}: R3DirectiveDef): CompileResult[] {\n    const factoryRes = compileNgFactoryDefField({\n      ...analysis.meta,\n      injectFn: Identifiers.directiveInject,\n      target: R3FactoryTarget.Directive,\n    });\n    if (analysis.metadataStmt !== null) {\n      factoryRes.statements.push(analysis.metadataStmt);\n    }\n    return [\n      factoryRes, {\n        name: 'Éµdir',\n        initializer,\n        statements: [],\n        type,\n      }\n    ];\n  }\n\n  /**\n   * Checks if a given class uses Angular features and returns the TypeScript node\n   * that indicated the usage. Classes are considered using Angular features if they\n   * contain class members that are either decorated with a known Angular decorator,\n   * or if they correspond to a known Angular lifecycle hook.\n   */\n  private findClassFieldWithAngularFeatures(node: ClassDeclaration): ClassMember|undefined {\n    return this.reflector.getMembersOfClass(node).find(member => {\n      if (!member.isStatic && member.kind === ClassMemberKind.Method &&\n          LIFECYCLE_HOOKS.has(member.name)) {\n        return true;\n      }\n      if (member.decorators) {\n        return member.decorators.some(\n            decorator => FIELD_DECORATORS.some(\n                decoratorName => isAngularDecorator(decorator, decoratorName, this.isCore)));\n      }\n      return false;\n    });\n  }\n}\n\n/**\n * Helper function to extract metadata from a `Directive` or `Component`. `Directive`s without a\n * selector are allowed to be used for abstract base classes. These abstract directives should not\n * appear in the declarations of an `NgModule` and additional verification is done when processing\n * the module.\n */\nexport function extractDirectiveMetadata(\n    clazz: ClassDeclaration, decorator: Readonly<Decorator|null>, reflector: ReflectionHost,\n    evaluator: PartialEvaluator, isCore: boolean, flags: HandlerFlags,\n    annotateForClosureCompiler: boolean, defaultSelector: string|null = null): {\n  decorator: Map<string, ts.Expression>,\n  metadata: R3DirectiveMetadata,\n  inputs: ClassPropertyMapping,\n  outputs: ClassPropertyMapping,\n  isStructural: boolean;\n}|undefined {\n  let directive: Map<string, ts.Expression>;\n  if (decorator === null || decorator.args === null || decorator.args.length === 0) {\n    directive = new Map<string, ts.Expression>();\n  } else if (decorator.args.length !== 1) {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator),\n        `Incorrect number of arguments to @${decorator.name} decorator`);\n  } else {\n    const meta = unwrapExpression(decorator.args[0]);\n    if (!ts.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta,\n          `@${decorator.name} argument must be an object literal`);\n    }\n    directive = reflectObjectLiteral(meta);\n  }\n\n  if (directive.has('jit')) {\n    // The only allowed value is true, so there's no need to expand further.\n    return undefined;\n  }\n\n  const members = reflector.getMembersOfClass(clazz);\n\n  // Precompute a list of ts.ClassElements that have decorators. This includes things like @Input,\n  // @Output, @HostBinding, etc.\n  const decoratedElements =\n      members.filter(member => !member.isStatic && member.decorators !== null);\n\n  const coreModule = isCore ? undefined : '@angular/core';\n\n  // Construct the map of inputs both from the @Directive/@Component\n  // decorator, and the decorated\n  // fields.\n  const inputsFromMeta = parseFieldToPropertyMapping(directive, 'inputs', evaluator);\n  const inputsFromFields = parseDecoratedFields(\n      filterToMembersWithDecorator(decoratedElements, 'Input', coreModule), evaluator,\n      resolveInput);\n\n  // And outputs.\n  const outputsFromMeta = parseFieldToPropertyMapping(directive, 'outputs', evaluator);\n  const outputsFromFields =\n      parseDecoratedFields(\n          filterToMembersWithDecorator(decoratedElements, 'Output', coreModule), evaluator,\n          resolveOutput) as {[field: string]: string};\n  // Construct the list of queries.\n  const contentChildFromFields = queriesFromFields(\n      filterToMembersWithDecorator(decoratedElements, 'ContentChild', coreModule), reflector,\n      evaluator);\n  const contentChildrenFromFields = queriesFromFields(\n      filterToMembersWithDecorator(decoratedElements, 'ContentChildren', coreModule), reflector,\n      evaluator);\n\n  const queries = [...contentChildFromFields, ...contentChildrenFromFields];\n\n  // Construct the list of view queries.\n  const viewChildFromFields = queriesFromFields(\n      filterToMembersWithDecorator(decoratedElements, 'ViewChild', coreModule), reflector,\n      evaluator);\n  const viewChildrenFromFields = queriesFromFields(\n      filterToMembersWithDecorator(decoratedElements, 'ViewChildren', coreModule), reflector,\n      evaluator);\n  const viewQueries = [...viewChildFromFields, ...viewChildrenFromFields];\n\n  if (directive.has('queries')) {\n    const queriesFromDecorator =\n        extractQueriesFromDecorator(directive.get('queries')!, reflector, evaluator, isCore);\n    queries.push(...queriesFromDecorator.content);\n    viewQueries.push(...queriesFromDecorator.view);\n  }\n\n  // Parse the selector.\n  let selector = defaultSelector;\n  if (directive.has('selector')) {\n    const expr = directive.get('selector')!;\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== 'string') {\n      throw createValueHasWrongTypeError(expr, resolved, `selector must be a string`);\n    }\n    // use default selector in case selector is an empty string\n    selector = resolved === '' ? defaultSelector : resolved;\n    if (!selector) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DIRECTIVE_MISSING_SELECTOR, expr,\n          `Directive ${clazz.name.text} has no selector, please add it!`);\n    }\n  }\n\n  const host = extractHostBindings(decoratedElements, evaluator, coreModule, directive);\n\n  const providers: Expression|null = directive.has('providers') ?\n      new WrappedNodeExpr(\n          annotateForClosureCompiler ?\n              wrapFunctionExpressionsInParens(directive.get('providers')!) :\n              directive.get('providers')!) :\n      null;\n\n  // Determine if `ngOnChanges` is a lifecycle hook defined on the component.\n  const usesOnChanges = members.some(\n      member => !member.isStatic && member.kind === ClassMemberKind.Method &&\n          member.name === 'ngOnChanges');\n\n  // Parse exportAs.\n  let exportAs: string[]|null = null;\n  if (directive.has('exportAs')) {\n    const expr = directive.get('exportAs')!;\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== 'string') {\n      throw createValueHasWrongTypeError(expr, resolved, `exportAs must be a string`);\n    }\n    exportAs = resolved.split(',').map(part => part.trim());\n  }\n\n  const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);\n  let ctorDeps: R3DependencyMetadata[]|'invalid'|null;\n\n  // Non-abstract directives (those with a selector) require valid constructor dependencies, whereas\n  // abstract directives are allowed to have invalid dependencies, given that a subclass may call\n  // the constructor explicitly.\n  if (selector !== null) {\n    ctorDeps = validateConstructorDependencies(clazz, rawCtorDeps);\n  } else {\n    ctorDeps = unwrapConstructorDependencies(rawCtorDeps);\n  }\n\n  const isStructural = ctorDeps !== null && ctorDeps !== 'invalid' && ctorDeps.some(dep => {\n    if (dep.resolved !== R3ResolvedDependencyType.Token || !(dep.token instanceof ExternalExpr)) {\n      return false;\n    }\n    if (dep.token.value.moduleName !== '@angular/core' || dep.token.value.name !== 'TemplateRef') {\n      return false;\n    }\n\n    return true;\n  });\n\n  // Detect if the component inherits from another class\n  const usesInheritance = reflector.hasBaseClass(clazz);\n  const type = wrapTypeReference(reflector, clazz);\n  const internalType = new WrappedNodeExpr(reflector.getInternalNameOfClass(clazz));\n\n  const inputs = ClassPropertyMapping.fromMappedObject({...inputsFromMeta, ...inputsFromFields});\n  const outputs = ClassPropertyMapping.fromMappedObject({...outputsFromMeta, ...outputsFromFields});\n\n  const metadata: R3DirectiveMetadata = {\n    name: clazz.name.text,\n    deps: ctorDeps,\n    host,\n    lifecycle: {\n      usesOnChanges,\n    },\n    inputs: inputs.toJointMappedObject(),\n    outputs: outputs.toDirectMappedObject(),\n    queries,\n    viewQueries,\n    selector,\n    fullInheritance: !!(flags & HandlerFlags.FULL_INHERITANCE),\n    type,\n    internalType,\n    typeArgumentCount: reflector.getGenericArityOfClass(clazz) || 0,\n    typeSourceSpan: createSourceSpan(clazz.name),\n    usesInheritance,\n    exportAs,\n    providers\n  };\n  return {\n    decorator: directive,\n    metadata,\n    inputs,\n    outputs,\n    isStructural,\n  };\n}\n\nexport function extractQueryMetadata(\n    exprNode: ts.Node, name: string, args: ReadonlyArray<ts.Expression>, propertyName: string,\n    reflector: ReflectionHost, evaluator: PartialEvaluator): R3QueryMetadata {\n  if (args.length === 0) {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_ARITY_WRONG, exprNode, `@${name} must have arguments`);\n  }\n  const first = name === 'ViewChild' || name === 'ContentChild';\n  const node = unwrapForwardRef(args[0], reflector);\n  const arg = evaluator.evaluate(node);\n\n  /** Whether or not this query should collect only static results (see view/api.ts)  */\n  let isStatic: boolean = false;\n\n  // Extract the predicate\n  let predicate: Expression|string[]|null = null;\n  if (arg instanceof Reference || arg instanceof DynamicValue) {\n    // References and predicates that could not be evaluated statically are emitted as is.\n    predicate = new WrappedNodeExpr(node);\n  } else if (typeof arg === 'string') {\n    predicate = [arg];\n  } else if (isStringArrayOrDie(arg, `@${name} predicate`, node)) {\n    predicate = arg;\n  } else {\n    throw createValueHasWrongTypeError(node, arg, `@${name} predicate cannot be interpreted`);\n  }\n\n  // Extract the read and descendants options.\n  let read: Expression|null = null;\n  // The default value for descendants is true for every decorator except @ContentChildren.\n  let descendants: boolean = name !== 'ContentChildren';\n  let emitDistinctChangesOnly: boolean = emitDistinctChangesOnlyDefaultValue;\n  if (args.length === 2) {\n    const optionsExpr = unwrapExpression(args[1]);\n    if (!ts.isObjectLiteralExpression(optionsExpr)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARG_NOT_LITERAL, optionsExpr,\n          `@${name} options must be an object literal`);\n    }\n    const options = reflectObjectLiteral(optionsExpr);\n    if (options.has('read')) {\n      read = new WrappedNodeExpr(options.get('read')!);\n    }\n\n    if (options.has('descendants')) {\n      const descendantsExpr = options.get('descendants')!;\n      const descendantsValue = evaluator.evaluate(descendantsExpr);\n      if (typeof descendantsValue !== 'boolean') {\n        throw createValueHasWrongTypeError(\n            descendantsExpr, descendantsValue, `@${name} options.descendants must be a boolean`);\n      }\n      descendants = descendantsValue;\n    }\n\n    if (options.has('emitDistinctChangesOnly')) {\n      const emitDistinctChangesOnlyExpr = options.get('emitDistinctChangesOnly')!;\n      const emitDistinctChangesOnlyValue = evaluator.evaluate(emitDistinctChangesOnlyExpr);\n      if (typeof emitDistinctChangesOnlyValue !== 'boolean') {\n        throw createValueHasWrongTypeError(\n            emitDistinctChangesOnlyExpr, emitDistinctChangesOnlyValue,\n            `@${name} options.emitDistinctChangesOnlys must be a boolean`);\n      }\n      emitDistinctChangesOnly = emitDistinctChangesOnlyValue;\n    }\n\n    if (options.has('static')) {\n      const staticValue = evaluator.evaluate(options.get('static')!);\n      if (typeof staticValue !== 'boolean') {\n        throw createValueHasWrongTypeError(\n            node, staticValue, `@${name} options.static must be a boolean`);\n      }\n      isStatic = staticValue;\n    }\n\n  } else if (args.length > 2) {\n    // Too many arguments.\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_ARITY_WRONG, node, `@${name} has too many arguments`);\n  }\n\n  return {\n    propertyName,\n    predicate,\n    first,\n    descendants,\n    read,\n    static: isStatic,\n    emitDistinctChangesOnly,\n  };\n}\n\nexport function extractQueriesFromDecorator(\n    queryData: ts.Expression, reflector: ReflectionHost, evaluator: PartialEvaluator,\n    isCore: boolean): {\n  content: R3QueryMetadata[],\n  view: R3QueryMetadata[],\n} {\n  const content: R3QueryMetadata[] = [], view: R3QueryMetadata[] = [];\n  if (!ts.isObjectLiteralExpression(queryData)) {\n    throw new FatalDiagnosticError(\n        ErrorCode.VALUE_HAS_WRONG_TYPE, queryData,\n        'Decorator queries metadata must be an object literal');\n  }\n  reflectObjectLiteral(queryData).forEach((queryExpr, propertyName) => {\n    queryExpr = unwrapExpression(queryExpr);\n    if (!ts.isNewExpression(queryExpr)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.VALUE_HAS_WRONG_TYPE, queryData,\n          'Decorator query metadata must be an instance of a query type');\n    }\n    const queryType = ts.isPropertyAccessExpression(queryExpr.expression) ?\n        queryExpr.expression.name :\n        queryExpr.expression;\n    if (!ts.isIdentifier(queryType)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.VALUE_HAS_WRONG_TYPE, queryData,\n          'Decorator query metadata must be an instance of a query type');\n    }\n    const type = reflector.getImportOfIdentifier(queryType);\n    if (type === null || (!isCore && type.from !== '@angular/core') ||\n        !QUERY_TYPES.has(type.name)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.VALUE_HAS_WRONG_TYPE, queryData,\n          'Decorator query metadata must be an instance of a query type');\n    }\n\n    const query = extractQueryMetadata(\n        queryExpr, type.name, queryExpr.arguments || [], propertyName, reflector, evaluator);\n    if (type.name.startsWith('Content')) {\n      content.push(query);\n    } else {\n      view.push(query);\n    }\n  });\n  return {content, view};\n}\n\nfunction isStringArrayOrDie(value: any, name: string, node: ts.Expression): value is string[] {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    if (typeof value[i] !== 'string') {\n      throw createValueHasWrongTypeError(\n          node, value[i], `Failed to resolve ${name} at position ${i} to a string`);\n    }\n  }\n  return true;\n}\n\nexport function parseFieldArrayValue(\n    directive: Map<string, ts.Expression>, field: string, evaluator: PartialEvaluator): null|\n    string[] {\n  if (!directive.has(field)) {\n    return null;\n  }\n\n  // Resolve the field of interest from the directive metadata to a string[].\n  const expression = directive.get(field)!;\n  const value = evaluator.evaluate(expression);\n  if (!isStringArrayOrDie(value, field, expression)) {\n    throw createValueHasWrongTypeError(\n        expression, value, `Failed to resolve @Directive.${field} to a string array`);\n  }\n\n  return value;\n}\n\n/**\n * Interpret property mapping fields on the decorator (e.g. inputs or outputs) and return the\n * correctly shaped metadata object.\n */\nfunction parseFieldToPropertyMapping(\n    directive: Map<string, ts.Expression>, field: string,\n    evaluator: PartialEvaluator): {[field: string]: string} {\n  const metaValues = parseFieldArrayValue(directive, field, evaluator);\n  if (!metaValues) {\n    return EMPTY_OBJECT;\n  }\n\n  return metaValues.reduce((results, value) => {\n    // Either the value is 'field' or 'field: property'. In the first case, `property` will\n    // be undefined, in which case the field name should also be used as the property name.\n    const [field, property] = value.split(':', 2).map(str => str.trim());\n    results[field] = property || field;\n    return results;\n  }, {} as {[field: string]: string});\n}\n\n/**\n * Parse property decorators (e.g. `Input` or `Output`) and return the correctly shaped metadata\n * object.\n */\nfunction parseDecoratedFields(\n    fields: {member: ClassMember, decorators: Decorator[]}[], evaluator: PartialEvaluator,\n    mapValueResolver: (publicName: string, internalName: string) =>\n        string | [string, string]): {[field: string]: string|[string, string]} {\n  return fields.reduce((results, field) => {\n    const fieldName = field.member.name;\n    field.decorators.forEach(decorator => {\n      // The decorator either doesn't have an argument (@Input()) in which case the property\n      // name is used, or it has one argument (@Output('named')).\n      if (decorator.args == null || decorator.args.length === 0) {\n        results[fieldName] = fieldName;\n      } else if (decorator.args.length === 1) {\n        const property = evaluator.evaluate(decorator.args[0]);\n        if (typeof property !== 'string') {\n          throw createValueHasWrongTypeError(\n              Decorator.nodeForError(decorator), property,\n              `@${decorator.name} decorator argument must resolve to a string`);\n        }\n        results[fieldName] = mapValueResolver(property, fieldName);\n      } else {\n        // Too many arguments.\n        throw new FatalDiagnosticError(\n            ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator),\n            `@${decorator.name} can have at most one argument, got ${\n                decorator.args.length} argument(s)`);\n      }\n    });\n    return results;\n  }, {} as {[field: string]: string | [string, string]});\n}\n\nfunction resolveInput(publicName: string, internalName: string): [string, string] {\n  return [publicName, internalName];\n}\n\nfunction resolveOutput(publicName: string, internalName: string) {\n  return publicName;\n}\n\nexport function queriesFromFields(\n    fields: {member: ClassMember, decorators: Decorator[]}[], reflector: ReflectionHost,\n    evaluator: PartialEvaluator): R3QueryMetadata[] {\n  return fields.map(({member, decorators}) => {\n    const decorator = decorators[0];\n    const node = member.node || Decorator.nodeForError(decorator);\n\n    // Throw in case of `@Input() @ContentChild('foo') foo: any`, which is not supported in Ivy\n    if (member.decorators!.some(v => v.name === 'Input')) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_COLLISION, node,\n          'Cannot combine @Input decorators with query decorators');\n    }\n    if (decorators.length !== 1) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_COLLISION, node,\n          'Cannot have multiple query decorators on the same class member');\n    } else if (!isPropertyTypeMember(member)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_UNEXPECTED, node,\n          'Query decorator must go on a property-type member');\n    }\n    return extractQueryMetadata(\n        node, decorator.name, decorator.args || [], member.name, reflector, evaluator);\n  });\n}\n\nfunction isPropertyTypeMember(member: ClassMember): boolean {\n  return member.kind === ClassMemberKind.Getter || member.kind === ClassMemberKind.Setter ||\n      member.kind === ClassMemberKind.Property;\n}\n\ntype StringMap<T> = {\n  [key: string]: T;\n};\n\nfunction evaluateHostExpressionBindings(\n    hostExpr: ts.Expression, evaluator: PartialEvaluator): ParsedHostBindings {\n  const hostMetaMap = evaluator.evaluate(hostExpr);\n  if (!(hostMetaMap instanceof Map)) {\n    throw createValueHasWrongTypeError(\n        hostExpr, hostMetaMap, `Decorator host metadata must be an object`);\n  }\n  const hostMetadata: StringMap<string|Expression> = {};\n  hostMetaMap.forEach((value, key) => {\n    // Resolve Enum references to their declared value.\n    if (value instanceof EnumValue) {\n      value = value.resolved;\n    }\n\n    if (typeof key !== 'string') {\n      throw createValueHasWrongTypeError(\n          hostExpr, key,\n          `Decorator host metadata must be a string -> string object, but found unparseable key`);\n    }\n\n    if (typeof value == 'string') {\n      hostMetadata[key] = value;\n    } else if (value instanceof DynamicValue) {\n      hostMetadata[key] = new WrappedNodeExpr(value.node as ts.Expression);\n    } else {\n      throw createValueHasWrongTypeError(\n          hostExpr, value,\n          `Decorator host metadata must be a string -> string object, but found unparseable value`);\n    }\n  });\n\n  const bindings = parseHostBindings(hostMetadata);\n\n  const errors = verifyHostBindings(bindings, createSourceSpan(hostExpr));\n  if (errors.length > 0) {\n    throw new FatalDiagnosticError(\n        // TODO: provide more granular diagnostic and output specific host expression that\n        // triggered an error instead of the whole host object.\n        ErrorCode.HOST_BINDING_PARSE_ERROR, hostExpr,\n        errors.map((error: ParseError) => error.msg).join('\\n'));\n  }\n\n  return bindings;\n}\n\nexport function extractHostBindings(\n    members: ClassMember[], evaluator: PartialEvaluator, coreModule: string|undefined,\n    metadata?: Map<string, ts.Expression>): ParsedHostBindings {\n  let bindings: ParsedHostBindings;\n  if (metadata && metadata.has('host')) {\n    bindings = evaluateHostExpressionBindings(metadata.get('host')!, evaluator);\n  } else {\n    bindings = parseHostBindings({});\n  }\n\n  filterToMembersWithDecorator(members, 'HostBinding', coreModule)\n      .forEach(({member, decorators}) => {\n        decorators.forEach(decorator => {\n          let hostPropertyName: string = member.name;\n          if (decorator.args !== null && decorator.args.length > 0) {\n            if (decorator.args.length !== 1) {\n              throw new FatalDiagnosticError(\n                  ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator),\n                  `@HostBinding can have at most one argument, got ${\n                      decorator.args.length} argument(s)`);\n            }\n\n            const resolved = evaluator.evaluate(decorator.args[0]);\n            if (typeof resolved !== 'string') {\n              throw createValueHasWrongTypeError(\n                  Decorator.nodeForError(decorator), resolved,\n                  `@HostBinding's argument must be a string`);\n            }\n\n            hostPropertyName = resolved;\n          }\n\n          // Since this is a decorator, we know that the value is a class member. Always access it\n          // through `this` so that further down the line it can't be confused for a literal value\n          // (e.g. if there's a property called `true`). There is no size penalty, because all\n          // values (except literals) are converted to `ctx.propName` eventually.\n          bindings.properties[hostPropertyName] = getSafePropertyAccessString('this', member.name);\n        });\n      });\n\n  filterToMembersWithDecorator(members, 'HostListener', coreModule)\n      .forEach(({member, decorators}) => {\n        decorators.forEach(decorator => {\n          let eventName: string = member.name;\n          let args: string[] = [];\n          if (decorator.args !== null && decorator.args.length > 0) {\n            if (decorator.args.length > 2) {\n              throw new FatalDiagnosticError(\n                  ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2],\n                  `@HostListener can have at most two arguments`);\n            }\n\n            const resolved = evaluator.evaluate(decorator.args[0]);\n            if (typeof resolved !== 'string') {\n              throw createValueHasWrongTypeError(\n                  decorator.args[0], resolved,\n                  `@HostListener's event name argument must be a string`);\n            }\n\n            eventName = resolved;\n\n            if (decorator.args.length === 2) {\n              const expression = decorator.args[1];\n              const resolvedArgs = evaluator.evaluate(decorator.args[1]);\n              if (!isStringArrayOrDie(resolvedArgs, '@HostListener.args', expression)) {\n                throw createValueHasWrongTypeError(\n                    decorator.args[1], resolvedArgs,\n                    `@HostListener's second argument must be a string array`);\n              }\n              args = resolvedArgs;\n            }\n          }\n\n          bindings.listeners[eventName] = `${member.name}(${args.join(',')})`;\n        });\n      });\n  return bindings;\n}\n\nconst QUERY_TYPES = new Set([\n  'ContentChild',\n  'ContentChildren',\n  'ViewChild',\n  'ViewChildren',\n]);\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}