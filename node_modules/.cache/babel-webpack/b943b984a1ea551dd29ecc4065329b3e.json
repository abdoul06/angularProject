{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/output/output_ast\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isNull = exports.localizedString = exports.literal = exports.taggedTemplate = exports.ifStmt = exports.fn = exports.assertNotNull = exports.not = exports.unary = exports.literalMap = exports.literalArr = exports.typeofExpr = exports.expressionType = exports.importType = exports.importExpr = exports.variable = exports.jsDocComment = exports.leadingComment = exports.applySourceSpanToExpressionIfNeeded = exports.applySourceSpanToStatementIfNeeded = exports.collectExternalReferences = exports.findReadVarNames = exports.RecursiveAstVisitor = exports.AstTransformer = exports.ThrowStmt = exports.TryCatchStmt = exports.IfStmt = exports.ClassStmt = exports.ClassGetter = exports.ClassMethod = exports.ClassField = exports.AbstractClassPart = exports.ReturnStatement = exports.ExpressionStatement = exports.DeclareFunctionStmt = exports.DeclareVarStmt = exports.Statement = exports.JSDocComment = exports.LeadingComment = exports.StmtModifier = exports.TYPED_NULL_EXPR = exports.NULL_EXPR = exports.CATCH_STACK_VAR = exports.CATCH_ERROR_VAR = exports.SUPER_EXPR = exports.THIS_EXPR = exports.CommaExpr = exports.LiteralMapExpr = exports.LiteralMapEntry = exports.LiteralArrayExpr = exports.ReadKeyExpr = exports.ReadPropExpr = exports.BinaryOperatorExpr = exports.UnaryOperatorExpr = exports.FunctionExpr = exports.FnParam = exports.CastExpr = exports.AssertNotNull = exports.NotExpr = exports.ConditionalExpr = exports.ExternalReference = exports.ExternalExpr = exports.LocalizedString = exports.PlaceholderPiece = exports.LiteralPiece = exports.MessagePiece = exports.TemplateLiteralElement = exports.TemplateLiteral = exports.LiteralExpr = exports.InstantiateExpr = exports.TaggedTemplateExpr = exports.InvokeFunctionExpr = exports.InvokeMethodExpr = exports.BuiltinMethod = exports.WritePropExpr = exports.WriteKeyExpr = exports.WriteVarExpr = exports.WrappedNodeExpr = exports.TypeofExpr = exports.ReadVarExpr = exports.BuiltinVar = exports.Expression = exports.areAllEquivalent = exports.nullSafeIsEquivalent = exports.BinaryOperator = exports.UnaryOperator = exports.NONE_TYPE = exports.FUNCTION_TYPE = exports.STRING_TYPE = exports.NUMBER_TYPE = exports.INT_TYPE = exports.BOOL_TYPE = exports.INFERRED_TYPE = exports.DYNAMIC_TYPE = exports.MapType = exports.ArrayType = exports.ExpressionType = exports.BuiltinType = exports.BuiltinTypeName = exports.Type = exports.TypeModifier = void 0;\n\n  var tslib_1 = require(\"tslib\"); //// Types\n\n\n  var TypeModifier;\n\n  (function (TypeModifier) {\n    TypeModifier[TypeModifier[\"Const\"] = 0] = \"Const\";\n  })(TypeModifier = exports.TypeModifier || (exports.TypeModifier = {}));\n\n  var Type =\n  /** @class */\n  function () {\n    function Type(modifiers) {\n      if (modifiers === void 0) {\n        modifiers = [];\n      }\n\n      this.modifiers = modifiers;\n    }\n\n    Type.prototype.hasModifier = function (modifier) {\n      return this.modifiers.indexOf(modifier) !== -1;\n    };\n\n    return Type;\n  }();\n\n  exports.Type = Type;\n  var BuiltinTypeName;\n\n  (function (BuiltinTypeName) {\n    BuiltinTypeName[BuiltinTypeName[\"Dynamic\"] = 0] = \"Dynamic\";\n    BuiltinTypeName[BuiltinTypeName[\"Bool\"] = 1] = \"Bool\";\n    BuiltinTypeName[BuiltinTypeName[\"String\"] = 2] = \"String\";\n    BuiltinTypeName[BuiltinTypeName[\"Int\"] = 3] = \"Int\";\n    BuiltinTypeName[BuiltinTypeName[\"Number\"] = 4] = \"Number\";\n    BuiltinTypeName[BuiltinTypeName[\"Function\"] = 5] = \"Function\";\n    BuiltinTypeName[BuiltinTypeName[\"Inferred\"] = 6] = \"Inferred\";\n    BuiltinTypeName[BuiltinTypeName[\"None\"] = 7] = \"None\";\n  })(BuiltinTypeName = exports.BuiltinTypeName || (exports.BuiltinTypeName = {}));\n\n  var BuiltinType =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(BuiltinType, _super);\n\n    function BuiltinType(name, modifiers) {\n      var _this = _super.call(this, modifiers) || this;\n\n      _this.name = name;\n      return _this;\n    }\n\n    BuiltinType.prototype.visitType = function (visitor, context) {\n      return visitor.visitBuiltinType(this, context);\n    };\n\n    return BuiltinType;\n  }(Type);\n\n  exports.BuiltinType = BuiltinType;\n\n  var ExpressionType =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ExpressionType, _super);\n\n    function ExpressionType(value, modifiers, typeParams) {\n      if (typeParams === void 0) {\n        typeParams = null;\n      }\n\n      var _this = _super.call(this, modifiers) || this;\n\n      _this.value = value;\n      _this.typeParams = typeParams;\n      return _this;\n    }\n\n    ExpressionType.prototype.visitType = function (visitor, context) {\n      return visitor.visitExpressionType(this, context);\n    };\n\n    return ExpressionType;\n  }(Type);\n\n  exports.ExpressionType = ExpressionType;\n\n  var ArrayType =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ArrayType, _super);\n\n    function ArrayType(of, modifiers) {\n      var _this = _super.call(this, modifiers) || this;\n\n      _this.of = of;\n      return _this;\n    }\n\n    ArrayType.prototype.visitType = function (visitor, context) {\n      return visitor.visitArrayType(this, context);\n    };\n\n    return ArrayType;\n  }(Type);\n\n  exports.ArrayType = ArrayType;\n\n  var MapType =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(MapType, _super);\n\n    function MapType(valueType, modifiers) {\n      var _this = _super.call(this, modifiers) || this;\n\n      _this.valueType = valueType || null;\n      return _this;\n    }\n\n    MapType.prototype.visitType = function (visitor, context) {\n      return visitor.visitMapType(this, context);\n    };\n\n    return MapType;\n  }(Type);\n\n  exports.MapType = MapType;\n  exports.DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\n  exports.INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\n  exports.BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\n  exports.INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\n  exports.NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\n  exports.STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\n  exports.FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\n  exports.NONE_TYPE = new BuiltinType(BuiltinTypeName.None); ///// Expressions\n\n  var UnaryOperator;\n\n  (function (UnaryOperator) {\n    UnaryOperator[UnaryOperator[\"Minus\"] = 0] = \"Minus\";\n    UnaryOperator[UnaryOperator[\"Plus\"] = 1] = \"Plus\";\n  })(UnaryOperator = exports.UnaryOperator || (exports.UnaryOperator = {}));\n\n  var BinaryOperator;\n\n  (function (BinaryOperator) {\n    BinaryOperator[BinaryOperator[\"Equals\"] = 0] = \"Equals\";\n    BinaryOperator[BinaryOperator[\"NotEquals\"] = 1] = \"NotEquals\";\n    BinaryOperator[BinaryOperator[\"Identical\"] = 2] = \"Identical\";\n    BinaryOperator[BinaryOperator[\"NotIdentical\"] = 3] = \"NotIdentical\";\n    BinaryOperator[BinaryOperator[\"Minus\"] = 4] = \"Minus\";\n    BinaryOperator[BinaryOperator[\"Plus\"] = 5] = \"Plus\";\n    BinaryOperator[BinaryOperator[\"Divide\"] = 6] = \"Divide\";\n    BinaryOperator[BinaryOperator[\"Multiply\"] = 7] = \"Multiply\";\n    BinaryOperator[BinaryOperator[\"Modulo\"] = 8] = \"Modulo\";\n    BinaryOperator[BinaryOperator[\"And\"] = 9] = \"And\";\n    BinaryOperator[BinaryOperator[\"Or\"] = 10] = \"Or\";\n    BinaryOperator[BinaryOperator[\"BitwiseAnd\"] = 11] = \"BitwiseAnd\";\n    BinaryOperator[BinaryOperator[\"Lower\"] = 12] = \"Lower\";\n    BinaryOperator[BinaryOperator[\"LowerEquals\"] = 13] = \"LowerEquals\";\n    BinaryOperator[BinaryOperator[\"Bigger\"] = 14] = \"Bigger\";\n    BinaryOperator[BinaryOperator[\"BiggerEquals\"] = 15] = \"BiggerEquals\";\n  })(BinaryOperator = exports.BinaryOperator || (exports.BinaryOperator = {}));\n\n  function nullSafeIsEquivalent(base, other) {\n    if (base == null || other == null) {\n      return base == other;\n    }\n\n    return base.isEquivalent(other);\n  }\n\n  exports.nullSafeIsEquivalent = nullSafeIsEquivalent;\n\n  function areAllEquivalentPredicate(base, other, equivalentPredicate) {\n    var len = base.length;\n\n    if (len !== other.length) {\n      return false;\n    }\n\n    for (var i = 0; i < len; i++) {\n      if (!equivalentPredicate(base[i], other[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function areAllEquivalent(base, other) {\n    return areAllEquivalentPredicate(base, other, function (baseElement, otherElement) {\n      return baseElement.isEquivalent(otherElement);\n    });\n  }\n\n  exports.areAllEquivalent = areAllEquivalent;\n\n  var Expression =\n  /** @class */\n  function () {\n    function Expression(type, sourceSpan) {\n      this.type = type || null;\n      this.sourceSpan = sourceSpan || null;\n    }\n\n    Expression.prototype.prop = function (name, sourceSpan) {\n      return new ReadPropExpr(this, name, null, sourceSpan);\n    };\n\n    Expression.prototype.key = function (index, type, sourceSpan) {\n      return new ReadKeyExpr(this, index, type, sourceSpan);\n    };\n\n    Expression.prototype.callMethod = function (name, params, sourceSpan) {\n      return new InvokeMethodExpr(this, name, params, null, sourceSpan);\n    };\n\n    Expression.prototype.callFn = function (params, sourceSpan, pure) {\n      return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n    };\n\n    Expression.prototype.instantiate = function (params, type, sourceSpan) {\n      return new InstantiateExpr(this, params, type, sourceSpan);\n    };\n\n    Expression.prototype.conditional = function (trueCase, falseCase, sourceSpan) {\n      if (falseCase === void 0) {\n        falseCase = null;\n      }\n\n      return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n    };\n\n    Expression.prototype.equals = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.notEquals = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.identical = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.notIdentical = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.minus = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.plus = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.divide = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.multiply = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.modulo = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.and = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.bitwiseAnd = function (rhs, sourceSpan, parens) {\n      if (parens === void 0) {\n        parens = true;\n      }\n\n      return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n    };\n\n    Expression.prototype.or = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.lower = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.lowerEquals = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.bigger = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.biggerEquals = function (rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n    };\n\n    Expression.prototype.isBlank = function (sourceSpan) {\n      // Note: We use equals by purpose here to compare to null and undefined in JS.\n      // We use the typed null to allow strictNullChecks to narrow types.\n      return this.equals(exports.TYPED_NULL_EXPR, sourceSpan);\n    };\n\n    Expression.prototype.cast = function (type, sourceSpan) {\n      return new CastExpr(this, type, sourceSpan);\n    };\n\n    Expression.prototype.toStmt = function () {\n      return new ExpressionStatement(this, null);\n    };\n\n    return Expression;\n  }();\n\n  exports.Expression = Expression;\n  var BuiltinVar;\n\n  (function (BuiltinVar) {\n    BuiltinVar[BuiltinVar[\"This\"] = 0] = \"This\";\n    BuiltinVar[BuiltinVar[\"Super\"] = 1] = \"Super\";\n    BuiltinVar[BuiltinVar[\"CatchError\"] = 2] = \"CatchError\";\n    BuiltinVar[BuiltinVar[\"CatchStack\"] = 3] = \"CatchStack\";\n  })(BuiltinVar = exports.BuiltinVar || (exports.BuiltinVar = {}));\n\n  var ReadVarExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ReadVarExpr, _super);\n\n    function ReadVarExpr(name, type, sourceSpan) {\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      if (typeof name === 'string') {\n        _this.name = name;\n        _this.builtin = null;\n      } else {\n        _this.name = null;\n        _this.builtin = name;\n      }\n\n      return _this;\n    }\n\n    ReadVarExpr.prototype.isEquivalent = function (e) {\n      return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;\n    };\n\n    ReadVarExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    ReadVarExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitReadVarExpr(this, context);\n    };\n\n    ReadVarExpr.prototype.set = function (value) {\n      if (!this.name) {\n        throw new Error(\"Built in variable \" + this.builtin + \" can not be assigned to.\");\n      }\n\n      return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n    };\n\n    return ReadVarExpr;\n  }(Expression);\n\n  exports.ReadVarExpr = ReadVarExpr;\n\n  var TypeofExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TypeofExpr, _super);\n\n    function TypeofExpr(expr, type, sourceSpan) {\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.expr = expr;\n      return _this;\n    }\n\n    TypeofExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitTypeofExpr(this, context);\n    };\n\n    TypeofExpr.prototype.isEquivalent = function (e) {\n      return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n    };\n\n    TypeofExpr.prototype.isConstant = function () {\n      return this.expr.isConstant();\n    };\n\n    return TypeofExpr;\n  }(Expression);\n\n  exports.TypeofExpr = TypeofExpr;\n\n  var WrappedNodeExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(WrappedNodeExpr, _super);\n\n    function WrappedNodeExpr(node, type, sourceSpan) {\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.node = node;\n      return _this;\n    }\n\n    WrappedNodeExpr.prototype.isEquivalent = function (e) {\n      return e instanceof WrappedNodeExpr && this.node === e.node;\n    };\n\n    WrappedNodeExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    WrappedNodeExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitWrappedNodeExpr(this, context);\n    };\n\n    return WrappedNodeExpr;\n  }(Expression);\n\n  exports.WrappedNodeExpr = WrappedNodeExpr;\n\n  var WriteVarExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(WriteVarExpr, _super);\n\n    function WriteVarExpr(name, value, type, sourceSpan) {\n      var _this = _super.call(this, type || value.type, sourceSpan) || this;\n\n      _this.name = name;\n      _this.value = value;\n      return _this;\n    }\n\n    WriteVarExpr.prototype.isEquivalent = function (e) {\n      return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n    };\n\n    WriteVarExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    WriteVarExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitWriteVarExpr(this, context);\n    };\n\n    WriteVarExpr.prototype.toDeclStmt = function (type, modifiers) {\n      return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n    };\n\n    WriteVarExpr.prototype.toConstDecl = function () {\n      return this.toDeclStmt(exports.INFERRED_TYPE, [StmtModifier.Final]);\n    };\n\n    return WriteVarExpr;\n  }(Expression);\n\n  exports.WriteVarExpr = WriteVarExpr;\n\n  var WriteKeyExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(WriteKeyExpr, _super);\n\n    function WriteKeyExpr(receiver, index, value, type, sourceSpan) {\n      var _this = _super.call(this, type || value.type, sourceSpan) || this;\n\n      _this.receiver = receiver;\n      _this.index = index;\n      _this.value = value;\n      return _this;\n    }\n\n    WriteKeyExpr.prototype.isEquivalent = function (e) {\n      return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n    };\n\n    WriteKeyExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    WriteKeyExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitWriteKeyExpr(this, context);\n    };\n\n    return WriteKeyExpr;\n  }(Expression);\n\n  exports.WriteKeyExpr = WriteKeyExpr;\n\n  var WritePropExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(WritePropExpr, _super);\n\n    function WritePropExpr(receiver, name, value, type, sourceSpan) {\n      var _this = _super.call(this, type || value.type, sourceSpan) || this;\n\n      _this.receiver = receiver;\n      _this.name = name;\n      _this.value = value;\n      return _this;\n    }\n\n    WritePropExpr.prototype.isEquivalent = function (e) {\n      return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.value.isEquivalent(e.value);\n    };\n\n    WritePropExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    WritePropExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitWritePropExpr(this, context);\n    };\n\n    return WritePropExpr;\n  }(Expression);\n\n  exports.WritePropExpr = WritePropExpr;\n  var BuiltinMethod;\n\n  (function (BuiltinMethod) {\n    BuiltinMethod[BuiltinMethod[\"ConcatArray\"] = 0] = \"ConcatArray\";\n    BuiltinMethod[BuiltinMethod[\"SubscribeObservable\"] = 1] = \"SubscribeObservable\";\n    BuiltinMethod[BuiltinMethod[\"Bind\"] = 2] = \"Bind\";\n  })(BuiltinMethod = exports.BuiltinMethod || (exports.BuiltinMethod = {}));\n\n  var InvokeMethodExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(InvokeMethodExpr, _super);\n\n    function InvokeMethodExpr(receiver, method, args, type, sourceSpan) {\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.receiver = receiver;\n      _this.args = args;\n\n      if (typeof method === 'string') {\n        _this.name = method;\n        _this.builtin = null;\n      } else {\n        _this.name = null;\n        _this.builtin = method;\n      }\n\n      return _this;\n    }\n\n    InvokeMethodExpr.prototype.isEquivalent = function (e) {\n      return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);\n    };\n\n    InvokeMethodExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    InvokeMethodExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitInvokeMethodExpr(this, context);\n    };\n\n    return InvokeMethodExpr;\n  }(Expression);\n\n  exports.InvokeMethodExpr = InvokeMethodExpr;\n\n  var InvokeFunctionExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(InvokeFunctionExpr, _super);\n\n    function InvokeFunctionExpr(fn, args, type, sourceSpan, pure) {\n      if (pure === void 0) {\n        pure = false;\n      }\n\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.fn = fn;\n      _this.args = args;\n      _this.pure = pure;\n      return _this;\n    }\n\n    InvokeFunctionExpr.prototype.isEquivalent = function (e) {\n      return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) && areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n    };\n\n    InvokeFunctionExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    InvokeFunctionExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitInvokeFunctionExpr(this, context);\n    };\n\n    return InvokeFunctionExpr;\n  }(Expression);\n\n  exports.InvokeFunctionExpr = InvokeFunctionExpr;\n\n  var TaggedTemplateExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TaggedTemplateExpr, _super);\n\n    function TaggedTemplateExpr(tag, template, type, sourceSpan) {\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.tag = tag;\n      _this.template = template;\n      return _this;\n    }\n\n    TaggedTemplateExpr.prototype.isEquivalent = function (e) {\n      return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) && areAllEquivalentPredicate(this.template.elements, e.template.elements, function (a, b) {\n        return a.text === b.text;\n      }) && areAllEquivalent(this.template.expressions, e.template.expressions);\n    };\n\n    TaggedTemplateExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    TaggedTemplateExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitTaggedTemplateExpr(this, context);\n    };\n\n    return TaggedTemplateExpr;\n  }(Expression);\n\n  exports.TaggedTemplateExpr = TaggedTemplateExpr;\n\n  var InstantiateExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(InstantiateExpr, _super);\n\n    function InstantiateExpr(classExpr, args, type, sourceSpan) {\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.classExpr = classExpr;\n      _this.args = args;\n      return _this;\n    }\n\n    InstantiateExpr.prototype.isEquivalent = function (e) {\n      return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) && areAllEquivalent(this.args, e.args);\n    };\n\n    InstantiateExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    InstantiateExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitInstantiateExpr(this, context);\n    };\n\n    return InstantiateExpr;\n  }(Expression);\n\n  exports.InstantiateExpr = InstantiateExpr;\n\n  var LiteralExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(LiteralExpr, _super);\n\n    function LiteralExpr(value, type, sourceSpan) {\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.value = value;\n      return _this;\n    }\n\n    LiteralExpr.prototype.isEquivalent = function (e) {\n      return e instanceof LiteralExpr && this.value === e.value;\n    };\n\n    LiteralExpr.prototype.isConstant = function () {\n      return true;\n    };\n\n    LiteralExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitLiteralExpr(this, context);\n    };\n\n    return LiteralExpr;\n  }(Expression);\n\n  exports.LiteralExpr = LiteralExpr;\n\n  var TemplateLiteral =\n  /** @class */\n  function () {\n    function TemplateLiteral(elements, expressions) {\n      this.elements = elements;\n      this.expressions = expressions;\n    }\n\n    return TemplateLiteral;\n  }();\n\n  exports.TemplateLiteral = TemplateLiteral;\n\n  var TemplateLiteralElement =\n  /** @class */\n  function () {\n    function TemplateLiteralElement(text, sourceSpan, rawText) {\n      var _a;\n\n      this.text = text;\n      this.sourceSpan = sourceSpan; // If `rawText` is not provided, try to extract the raw string from its\n      // associated `sourceSpan`. If that is also not available, \"fake\" the raw\n      // string instead by escaping the following control sequences:\n      // - \"\\\" would otherwise indicate that the next character is a control character.\n      // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\n      // indicate the end of the template literal element.\n\n      this.rawText = (_a = rawText !== null && rawText !== void 0 ? rawText : sourceSpan === null || sourceSpan === void 0 ? void 0 : sourceSpan.toString()) !== null && _a !== void 0 ? _a : escapeForTemplateLiteral(escapeSlashes(text));\n    }\n\n    return TemplateLiteralElement;\n  }();\n\n  exports.TemplateLiteralElement = TemplateLiteralElement;\n\n  var MessagePiece =\n  /** @class */\n  function () {\n    function MessagePiece(text, sourceSpan) {\n      this.text = text;\n      this.sourceSpan = sourceSpan;\n    }\n\n    return MessagePiece;\n  }();\n\n  exports.MessagePiece = MessagePiece;\n\n  var LiteralPiece =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(LiteralPiece, _super);\n\n    function LiteralPiece() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    return LiteralPiece;\n  }(MessagePiece);\n\n  exports.LiteralPiece = LiteralPiece;\n\n  var PlaceholderPiece =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(PlaceholderPiece, _super);\n\n    function PlaceholderPiece() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    return PlaceholderPiece;\n  }(MessagePiece);\n\n  exports.PlaceholderPiece = PlaceholderPiece;\n\n  var LocalizedString =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(LocalizedString, _super);\n\n    function LocalizedString(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {\n      var _this = _super.call(this, exports.STRING_TYPE, sourceSpan) || this;\n\n      _this.metaBlock = metaBlock;\n      _this.messageParts = messageParts;\n      _this.placeHolderNames = placeHolderNames;\n      _this.expressions = expressions;\n      return _this;\n    }\n\n    LocalizedString.prototype.isEquivalent = function (e) {\n      // return e instanceof LocalizedString && this.message === e.message;\n      return false;\n    };\n\n    LocalizedString.prototype.isConstant = function () {\n      return false;\n    };\n\n    LocalizedString.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitLocalizedString(this, context);\n    };\n    /**\n     * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n     * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n     * `parseI18nMeta()`.\n     *\n     * @param meta The metadata to serialize\n     * @param messagePart The first part of the tagged string\n     */\n\n\n    LocalizedString.prototype.serializeI18nHead = function () {\n      var MEANING_SEPARATOR = '|';\n      var ID_SEPARATOR = '@@';\n      var LEGACY_ID_INDICATOR = 'âŸ';\n      var metaBlock = this.metaBlock.description || '';\n\n      if (this.metaBlock.meaning) {\n        metaBlock = \"\" + this.metaBlock.meaning + MEANING_SEPARATOR + metaBlock;\n      }\n\n      if (this.metaBlock.customId) {\n        metaBlock = \"\" + metaBlock + ID_SEPARATOR + this.metaBlock.customId;\n      }\n\n      if (this.metaBlock.legacyIds) {\n        this.metaBlock.legacyIds.forEach(function (legacyId) {\n          metaBlock = \"\" + metaBlock + LEGACY_ID_INDICATOR + legacyId;\n        });\n      }\n\n      return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n    };\n\n    LocalizedString.prototype.getMessagePartSourceSpan = function (i) {\n      var _a, _b;\n\n      return (_b = (_a = this.messageParts[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : this.sourceSpan;\n    };\n\n    LocalizedString.prototype.getPlaceholderSourceSpan = function (i) {\n      var _a, _b, _c, _d;\n\n      return (_d = (_b = (_a = this.placeHolderNames[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : (_c = this.expressions[i]) === null || _c === void 0 ? void 0 : _c.sourceSpan) !== null && _d !== void 0 ? _d : this.sourceSpan;\n    };\n    /**\n     * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n     * can be used in a `$localize` tagged string.\n     *\n     * @param placeholderName The placeholder name to serialize\n     * @param messagePart The following message string after this placeholder\n     */\n\n\n    LocalizedString.prototype.serializeI18nTemplatePart = function (partIndex) {\n      var placeholderName = this.placeHolderNames[partIndex - 1].text;\n      var messagePart = this.messageParts[partIndex];\n      return createCookedRawString(placeholderName, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n    };\n\n    return LocalizedString;\n  }(Expression);\n\n  exports.LocalizedString = LocalizedString;\n\n  var escapeSlashes = function escapeSlashes(str) {\n    return str.replace(/\\\\/g, '\\\\\\\\');\n  };\n\n  var escapeStartingColon = function escapeStartingColon(str) {\n    return str.replace(/^:/, '\\\\:');\n  };\n\n  var escapeColons = function escapeColons(str) {\n    return str.replace(/:/g, '\\\\:');\n  };\n\n  var escapeForTemplateLiteral = function escapeForTemplateLiteral(str) {\n    return str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n  };\n  /**\n   * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n   *\n   * The `raw` text must have various character sequences escaped:\n   * * \"\\\" would otherwise indicate that the next character is a control character.\n   * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n   *   the end of a message part.\n   * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n   * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n   *   metablock.\n   *\n   * @param metaBlock Any metadata that should be prepended to the string\n   * @param messagePart The message part of the string\n   */\n\n\n  function createCookedRawString(metaBlock, messagePart, range) {\n    if (metaBlock === '') {\n      return {\n        cooked: messagePart,\n        raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n        range: range\n      };\n    } else {\n      return {\n        cooked: \":\" + metaBlock + \":\" + messagePart,\n        raw: escapeForTemplateLiteral(\":\" + escapeColons(escapeSlashes(metaBlock)) + \":\" + escapeSlashes(messagePart)),\n        range: range\n      };\n    }\n  }\n\n  var ExternalExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ExternalExpr, _super);\n\n    function ExternalExpr(value, type, typeParams, sourceSpan) {\n      if (typeParams === void 0) {\n        typeParams = null;\n      }\n\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.value = value;\n      _this.typeParams = typeParams;\n      return _this;\n    }\n\n    ExternalExpr.prototype.isEquivalent = function (e) {\n      return e instanceof ExternalExpr && this.value.name === e.value.name && this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n    };\n\n    ExternalExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    ExternalExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitExternalExpr(this, context);\n    };\n\n    return ExternalExpr;\n  }(Expression);\n\n  exports.ExternalExpr = ExternalExpr;\n\n  var ExternalReference =\n  /** @class */\n  function () {\n    function ExternalReference(moduleName, name, runtime) {\n      this.moduleName = moduleName;\n      this.name = name;\n      this.runtime = runtime;\n    }\n\n    return ExternalReference;\n  }();\n\n  exports.ExternalReference = ExternalReference;\n\n  var ConditionalExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ConditionalExpr, _super);\n\n    function ConditionalExpr(condition, trueCase, falseCase, type, sourceSpan) {\n      if (falseCase === void 0) {\n        falseCase = null;\n      }\n\n      var _this = _super.call(this, type || trueCase.type, sourceSpan) || this;\n\n      _this.condition = condition;\n      _this.falseCase = falseCase;\n      _this.trueCase = trueCase;\n      return _this;\n    }\n\n    ConditionalExpr.prototype.isEquivalent = function (e) {\n      return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) && this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n    };\n\n    ConditionalExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    ConditionalExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitConditionalExpr(this, context);\n    };\n\n    return ConditionalExpr;\n  }(Expression);\n\n  exports.ConditionalExpr = ConditionalExpr;\n\n  var NotExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(NotExpr, _super);\n\n    function NotExpr(condition, sourceSpan) {\n      var _this = _super.call(this, exports.BOOL_TYPE, sourceSpan) || this;\n\n      _this.condition = condition;\n      return _this;\n    }\n\n    NotExpr.prototype.isEquivalent = function (e) {\n      return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n    };\n\n    NotExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    NotExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitNotExpr(this, context);\n    };\n\n    return NotExpr;\n  }(Expression);\n\n  exports.NotExpr = NotExpr;\n\n  var AssertNotNull =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(AssertNotNull, _super);\n\n    function AssertNotNull(condition, sourceSpan) {\n      var _this = _super.call(this, condition.type, sourceSpan) || this;\n\n      _this.condition = condition;\n      return _this;\n    }\n\n    AssertNotNull.prototype.isEquivalent = function (e) {\n      return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);\n    };\n\n    AssertNotNull.prototype.isConstant = function () {\n      return false;\n    };\n\n    AssertNotNull.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitAssertNotNullExpr(this, context);\n    };\n\n    return AssertNotNull;\n  }(Expression);\n\n  exports.AssertNotNull = AssertNotNull;\n\n  var CastExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(CastExpr, _super);\n\n    function CastExpr(value, type, sourceSpan) {\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.value = value;\n      return _this;\n    }\n\n    CastExpr.prototype.isEquivalent = function (e) {\n      return e instanceof CastExpr && this.value.isEquivalent(e.value);\n    };\n\n    CastExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    CastExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitCastExpr(this, context);\n    };\n\n    return CastExpr;\n  }(Expression);\n\n  exports.CastExpr = CastExpr;\n\n  var FnParam =\n  /** @class */\n  function () {\n    function FnParam(name, type) {\n      if (type === void 0) {\n        type = null;\n      }\n\n      this.name = name;\n      this.type = type;\n    }\n\n    FnParam.prototype.isEquivalent = function (param) {\n      return this.name === param.name;\n    };\n\n    return FnParam;\n  }();\n\n  exports.FnParam = FnParam;\n\n  var FunctionExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(FunctionExpr, _super);\n\n    function FunctionExpr(params, statements, type, sourceSpan, name) {\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.params = params;\n      _this.statements = statements;\n      _this.name = name;\n      return _this;\n    }\n\n    FunctionExpr.prototype.isEquivalent = function (e) {\n      return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) && areAllEquivalent(this.statements, e.statements);\n    };\n\n    FunctionExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    FunctionExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitFunctionExpr(this, context);\n    };\n\n    FunctionExpr.prototype.toDeclStmt = function (name, modifiers) {\n      return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n    };\n\n    return FunctionExpr;\n  }(Expression);\n\n  exports.FunctionExpr = FunctionExpr;\n\n  var UnaryOperatorExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(UnaryOperatorExpr, _super);\n\n    function UnaryOperatorExpr(operator, expr, type, sourceSpan, parens) {\n      if (parens === void 0) {\n        parens = true;\n      }\n\n      var _this = _super.call(this, type || exports.NUMBER_TYPE, sourceSpan) || this;\n\n      _this.operator = operator;\n      _this.expr = expr;\n      _this.parens = parens;\n      return _this;\n    }\n\n    UnaryOperatorExpr.prototype.isEquivalent = function (e) {\n      return e instanceof UnaryOperatorExpr && this.operator === e.operator && this.expr.isEquivalent(e.expr);\n    };\n\n    UnaryOperatorExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    UnaryOperatorExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitUnaryOperatorExpr(this, context);\n    };\n\n    return UnaryOperatorExpr;\n  }(Expression);\n\n  exports.UnaryOperatorExpr = UnaryOperatorExpr;\n\n  var BinaryOperatorExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(BinaryOperatorExpr, _super);\n\n    function BinaryOperatorExpr(operator, lhs, rhs, type, sourceSpan, parens) {\n      if (parens === void 0) {\n        parens = true;\n      }\n\n      var _this = _super.call(this, type || lhs.type, sourceSpan) || this;\n\n      _this.operator = operator;\n      _this.rhs = rhs;\n      _this.parens = parens;\n      _this.lhs = lhs;\n      return _this;\n    }\n\n    BinaryOperatorExpr.prototype.isEquivalent = function (e) {\n      return e instanceof BinaryOperatorExpr && this.operator === e.operator && this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n    };\n\n    BinaryOperatorExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    BinaryOperatorExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitBinaryOperatorExpr(this, context);\n    };\n\n    return BinaryOperatorExpr;\n  }(Expression);\n\n  exports.BinaryOperatorExpr = BinaryOperatorExpr;\n\n  var ReadPropExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ReadPropExpr, _super);\n\n    function ReadPropExpr(receiver, name, type, sourceSpan) {\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.receiver = receiver;\n      _this.name = name;\n      return _this;\n    }\n\n    ReadPropExpr.prototype.isEquivalent = function (e) {\n      return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name;\n    };\n\n    ReadPropExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    ReadPropExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitReadPropExpr(this, context);\n    };\n\n    ReadPropExpr.prototype.set = function (value) {\n      return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n    };\n\n    return ReadPropExpr;\n  }(Expression);\n\n  exports.ReadPropExpr = ReadPropExpr;\n\n  var ReadKeyExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ReadKeyExpr, _super);\n\n    function ReadKeyExpr(receiver, index, type, sourceSpan) {\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.receiver = receiver;\n      _this.index = index;\n      return _this;\n    }\n\n    ReadKeyExpr.prototype.isEquivalent = function (e) {\n      return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index);\n    };\n\n    ReadKeyExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    ReadKeyExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitReadKeyExpr(this, context);\n    };\n\n    ReadKeyExpr.prototype.set = function (value) {\n      return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n    };\n\n    return ReadKeyExpr;\n  }(Expression);\n\n  exports.ReadKeyExpr = ReadKeyExpr;\n\n  var LiteralArrayExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(LiteralArrayExpr, _super);\n\n    function LiteralArrayExpr(entries, type, sourceSpan) {\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.entries = entries;\n      return _this;\n    }\n\n    LiteralArrayExpr.prototype.isConstant = function () {\n      return this.entries.every(function (e) {\n        return e.isConstant();\n      });\n    };\n\n    LiteralArrayExpr.prototype.isEquivalent = function (e) {\n      return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n    };\n\n    LiteralArrayExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitLiteralArrayExpr(this, context);\n    };\n\n    return LiteralArrayExpr;\n  }(Expression);\n\n  exports.LiteralArrayExpr = LiteralArrayExpr;\n\n  var LiteralMapEntry =\n  /** @class */\n  function () {\n    function LiteralMapEntry(key, value, quoted) {\n      this.key = key;\n      this.value = value;\n      this.quoted = quoted;\n    }\n\n    LiteralMapEntry.prototype.isEquivalent = function (e) {\n      return this.key === e.key && this.value.isEquivalent(e.value);\n    };\n\n    return LiteralMapEntry;\n  }();\n\n  exports.LiteralMapEntry = LiteralMapEntry;\n\n  var LiteralMapExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(LiteralMapExpr, _super);\n\n    function LiteralMapExpr(entries, type, sourceSpan) {\n      var _this = _super.call(this, type, sourceSpan) || this;\n\n      _this.entries = entries;\n      _this.valueType = null;\n\n      if (type) {\n        _this.valueType = type.valueType;\n      }\n\n      return _this;\n    }\n\n    LiteralMapExpr.prototype.isEquivalent = function (e) {\n      return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n    };\n\n    LiteralMapExpr.prototype.isConstant = function () {\n      return this.entries.every(function (e) {\n        return e.value.isConstant();\n      });\n    };\n\n    LiteralMapExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitLiteralMapExpr(this, context);\n    };\n\n    return LiteralMapExpr;\n  }(Expression);\n\n  exports.LiteralMapExpr = LiteralMapExpr;\n\n  var CommaExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(CommaExpr, _super);\n\n    function CommaExpr(parts, sourceSpan) {\n      var _this = _super.call(this, parts[parts.length - 1].type, sourceSpan) || this;\n\n      _this.parts = parts;\n      return _this;\n    }\n\n    CommaExpr.prototype.isEquivalent = function (e) {\n      return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n    };\n\n    CommaExpr.prototype.isConstant = function () {\n      return false;\n    };\n\n    CommaExpr.prototype.visitExpression = function (visitor, context) {\n      return visitor.visitCommaExpr(this, context);\n    };\n\n    return CommaExpr;\n  }(Expression);\n\n  exports.CommaExpr = CommaExpr;\n  exports.THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);\n  exports.SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);\n  exports.CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);\n  exports.CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);\n  exports.NULL_EXPR = new LiteralExpr(null, null, null);\n  exports.TYPED_NULL_EXPR = new LiteralExpr(null, exports.INFERRED_TYPE, null); //// Statements\n\n  var StmtModifier;\n\n  (function (StmtModifier) {\n    StmtModifier[StmtModifier[\"Final\"] = 0] = \"Final\";\n    StmtModifier[StmtModifier[\"Private\"] = 1] = \"Private\";\n    StmtModifier[StmtModifier[\"Exported\"] = 2] = \"Exported\";\n    StmtModifier[StmtModifier[\"Static\"] = 3] = \"Static\";\n  })(StmtModifier = exports.StmtModifier || (exports.StmtModifier = {}));\n\n  var LeadingComment =\n  /** @class */\n  function () {\n    function LeadingComment(text, multiline, trailingNewline) {\n      this.text = text;\n      this.multiline = multiline;\n      this.trailingNewline = trailingNewline;\n    }\n\n    LeadingComment.prototype.toString = function () {\n      return this.multiline ? \" \" + this.text + \" \" : this.text;\n    };\n\n    return LeadingComment;\n  }();\n\n  exports.LeadingComment = LeadingComment;\n\n  var JSDocComment =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(JSDocComment, _super);\n\n    function JSDocComment(tags) {\n      var _this = _super.call(this, '',\n      /* multiline */\n      true,\n      /* trailingNewline */\n      true) || this;\n\n      _this.tags = tags;\n      return _this;\n    }\n\n    JSDocComment.prototype.toString = function () {\n      return serializeTags(this.tags);\n    };\n\n    return JSDocComment;\n  }(LeadingComment);\n\n  exports.JSDocComment = JSDocComment;\n\n  var Statement =\n  /** @class */\n  function () {\n    function Statement(modifiers, sourceSpan, leadingComments) {\n      if (modifiers === void 0) {\n        modifiers = [];\n      }\n\n      if (sourceSpan === void 0) {\n        sourceSpan = null;\n      }\n\n      this.modifiers = modifiers;\n      this.sourceSpan = sourceSpan;\n      this.leadingComments = leadingComments;\n    }\n\n    Statement.prototype.hasModifier = function (modifier) {\n      return this.modifiers.indexOf(modifier) !== -1;\n    };\n\n    Statement.prototype.addLeadingComment = function (leadingComment) {\n      var _a;\n\n      this.leadingComments = (_a = this.leadingComments) !== null && _a !== void 0 ? _a : [];\n      this.leadingComments.push(leadingComment);\n    };\n\n    return Statement;\n  }();\n\n  exports.Statement = Statement;\n\n  var DeclareVarStmt =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(DeclareVarStmt, _super);\n\n    function DeclareVarStmt(name, value, type, modifiers, sourceSpan, leadingComments) {\n      var _this = _super.call(this, modifiers, sourceSpan, leadingComments) || this;\n\n      _this.name = name;\n      _this.value = value;\n      _this.type = type || value && value.type || null;\n      return _this;\n    }\n\n    DeclareVarStmt.prototype.isEquivalent = function (stmt) {\n      return stmt instanceof DeclareVarStmt && this.name === stmt.name && (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n    };\n\n    DeclareVarStmt.prototype.visitStatement = function (visitor, context) {\n      return visitor.visitDeclareVarStmt(this, context);\n    };\n\n    return DeclareVarStmt;\n  }(Statement);\n\n  exports.DeclareVarStmt = DeclareVarStmt;\n\n  var DeclareFunctionStmt =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(DeclareFunctionStmt, _super);\n\n    function DeclareFunctionStmt(name, params, statements, type, modifiers, sourceSpan, leadingComments) {\n      var _this = _super.call(this, modifiers, sourceSpan, leadingComments) || this;\n\n      _this.name = name;\n      _this.params = params;\n      _this.statements = statements;\n      _this.type = type || null;\n      return _this;\n    }\n\n    DeclareFunctionStmt.prototype.isEquivalent = function (stmt) {\n      return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) && areAllEquivalent(this.statements, stmt.statements);\n    };\n\n    DeclareFunctionStmt.prototype.visitStatement = function (visitor, context) {\n      return visitor.visitDeclareFunctionStmt(this, context);\n    };\n\n    return DeclareFunctionStmt;\n  }(Statement);\n\n  exports.DeclareFunctionStmt = DeclareFunctionStmt;\n\n  var ExpressionStatement =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ExpressionStatement, _super);\n\n    function ExpressionStatement(expr, sourceSpan, leadingComments) {\n      var _this = _super.call(this, [], sourceSpan, leadingComments) || this;\n\n      _this.expr = expr;\n      return _this;\n    }\n\n    ExpressionStatement.prototype.isEquivalent = function (stmt) {\n      return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n    };\n\n    ExpressionStatement.prototype.visitStatement = function (visitor, context) {\n      return visitor.visitExpressionStmt(this, context);\n    };\n\n    return ExpressionStatement;\n  }(Statement);\n\n  exports.ExpressionStatement = ExpressionStatement;\n\n  var ReturnStatement =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ReturnStatement, _super);\n\n    function ReturnStatement(value, sourceSpan, leadingComments) {\n      if (sourceSpan === void 0) {\n        sourceSpan = null;\n      }\n\n      var _this = _super.call(this, [], sourceSpan, leadingComments) || this;\n\n      _this.value = value;\n      return _this;\n    }\n\n    ReturnStatement.prototype.isEquivalent = function (stmt) {\n      return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n    };\n\n    ReturnStatement.prototype.visitStatement = function (visitor, context) {\n      return visitor.visitReturnStmt(this, context);\n    };\n\n    return ReturnStatement;\n  }(Statement);\n\n  exports.ReturnStatement = ReturnStatement;\n\n  var AbstractClassPart =\n  /** @class */\n  function () {\n    function AbstractClassPart(type, modifiers) {\n      if (type === void 0) {\n        type = null;\n      }\n\n      if (modifiers === void 0) {\n        modifiers = [];\n      }\n\n      this.type = type;\n      this.modifiers = modifiers;\n    }\n\n    AbstractClassPart.prototype.hasModifier = function (modifier) {\n      return this.modifiers.indexOf(modifier) !== -1;\n    };\n\n    return AbstractClassPart;\n  }();\n\n  exports.AbstractClassPart = AbstractClassPart;\n\n  var ClassField =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ClassField, _super);\n\n    function ClassField(name, type, modifiers, initializer) {\n      var _this = _super.call(this, type, modifiers) || this;\n\n      _this.name = name;\n      _this.initializer = initializer;\n      return _this;\n    }\n\n    ClassField.prototype.isEquivalent = function (f) {\n      return this.name === f.name;\n    };\n\n    return ClassField;\n  }(AbstractClassPart);\n\n  exports.ClassField = ClassField;\n\n  var ClassMethod =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ClassMethod, _super);\n\n    function ClassMethod(name, params, body, type, modifiers) {\n      var _this = _super.call(this, type, modifiers) || this;\n\n      _this.name = name;\n      _this.params = params;\n      _this.body = body;\n      return _this;\n    }\n\n    ClassMethod.prototype.isEquivalent = function (m) {\n      return this.name === m.name && areAllEquivalent(this.body, m.body);\n    };\n\n    return ClassMethod;\n  }(AbstractClassPart);\n\n  exports.ClassMethod = ClassMethod;\n\n  var ClassGetter =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ClassGetter, _super);\n\n    function ClassGetter(name, body, type, modifiers) {\n      var _this = _super.call(this, type, modifiers) || this;\n\n      _this.name = name;\n      _this.body = body;\n      return _this;\n    }\n\n    ClassGetter.prototype.isEquivalent = function (m) {\n      return this.name === m.name && areAllEquivalent(this.body, m.body);\n    };\n\n    return ClassGetter;\n  }(AbstractClassPart);\n\n  exports.ClassGetter = ClassGetter;\n\n  var ClassStmt =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ClassStmt, _super);\n\n    function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers, sourceSpan, leadingComments) {\n      var _this = _super.call(this, modifiers, sourceSpan, leadingComments) || this;\n\n      _this.name = name;\n      _this.parent = parent;\n      _this.fields = fields;\n      _this.getters = getters;\n      _this.constructorMethod = constructorMethod;\n      _this.methods = methods;\n      return _this;\n    }\n\n    ClassStmt.prototype.isEquivalent = function (stmt) {\n      return stmt instanceof ClassStmt && this.name === stmt.name && nullSafeIsEquivalent(this.parent, stmt.parent) && areAllEquivalent(this.fields, stmt.fields) && areAllEquivalent(this.getters, stmt.getters) && this.constructorMethod.isEquivalent(stmt.constructorMethod) && areAllEquivalent(this.methods, stmt.methods);\n    };\n\n    ClassStmt.prototype.visitStatement = function (visitor, context) {\n      return visitor.visitDeclareClassStmt(this, context);\n    };\n\n    return ClassStmt;\n  }(Statement);\n\n  exports.ClassStmt = ClassStmt;\n\n  var IfStmt =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(IfStmt, _super);\n\n    function IfStmt(condition, trueCase, falseCase, sourceSpan, leadingComments) {\n      if (falseCase === void 0) {\n        falseCase = [];\n      }\n\n      var _this = _super.call(this, [], sourceSpan, leadingComments) || this;\n\n      _this.condition = condition;\n      _this.trueCase = trueCase;\n      _this.falseCase = falseCase;\n      return _this;\n    }\n\n    IfStmt.prototype.isEquivalent = function (stmt) {\n      return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) && areAllEquivalent(this.trueCase, stmt.trueCase) && areAllEquivalent(this.falseCase, stmt.falseCase);\n    };\n\n    IfStmt.prototype.visitStatement = function (visitor, context) {\n      return visitor.visitIfStmt(this, context);\n    };\n\n    return IfStmt;\n  }(Statement);\n\n  exports.IfStmt = IfStmt;\n\n  var TryCatchStmt =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TryCatchStmt, _super);\n\n    function TryCatchStmt(bodyStmts, catchStmts, sourceSpan, leadingComments) {\n      if (sourceSpan === void 0) {\n        sourceSpan = null;\n      }\n\n      var _this = _super.call(this, [], sourceSpan, leadingComments) || this;\n\n      _this.bodyStmts = bodyStmts;\n      _this.catchStmts = catchStmts;\n      return _this;\n    }\n\n    TryCatchStmt.prototype.isEquivalent = function (stmt) {\n      return stmt instanceof TryCatchStmt && areAllEquivalent(this.bodyStmts, stmt.bodyStmts) && areAllEquivalent(this.catchStmts, stmt.catchStmts);\n    };\n\n    TryCatchStmt.prototype.visitStatement = function (visitor, context) {\n      return visitor.visitTryCatchStmt(this, context);\n    };\n\n    return TryCatchStmt;\n  }(Statement);\n\n  exports.TryCatchStmt = TryCatchStmt;\n\n  var ThrowStmt =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ThrowStmt, _super);\n\n    function ThrowStmt(error, sourceSpan, leadingComments) {\n      if (sourceSpan === void 0) {\n        sourceSpan = null;\n      }\n\n      var _this = _super.call(this, [], sourceSpan, leadingComments) || this;\n\n      _this.error = error;\n      return _this;\n    }\n\n    ThrowStmt.prototype.isEquivalent = function (stmt) {\n      return stmt instanceof TryCatchStmt && this.error.isEquivalent(stmt.error);\n    };\n\n    ThrowStmt.prototype.visitStatement = function (visitor, context) {\n      return visitor.visitThrowStmt(this, context);\n    };\n\n    return ThrowStmt;\n  }(Statement);\n\n  exports.ThrowStmt = ThrowStmt;\n\n  var AstTransformer =\n  /** @class */\n  function () {\n    function AstTransformer() {}\n\n    AstTransformer.prototype.transformExpr = function (expr, context) {\n      return expr;\n    };\n\n    AstTransformer.prototype.transformStmt = function (stmt, context) {\n      return stmt;\n    };\n\n    AstTransformer.prototype.visitReadVarExpr = function (ast, context) {\n      return this.transformExpr(ast, context);\n    };\n\n    AstTransformer.prototype.visitWrappedNodeExpr = function (ast, context) {\n      return this.transformExpr(ast, context);\n    };\n\n    AstTransformer.prototype.visitTypeofExpr = function (expr, context) {\n      return this.transformExpr(new TypeofExpr(expr.expr.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitWriteVarExpr = function (expr, context) {\n      return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitWriteKeyExpr = function (expr, context) {\n      return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitWritePropExpr = function (expr, context) {\n      return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitInvokeMethodExpr = function (ast, context) {\n      var method = ast.builtin || ast.name;\n      return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitInvokeFunctionExpr = function (ast, context) {\n      return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitTaggedTemplateExpr = function (ast, context) {\n      var _this = this;\n\n      return this.transformExpr(new TaggedTemplateExpr(ast.tag.visitExpression(this, context), new TemplateLiteral(ast.template.elements, ast.template.expressions.map(function (e) {\n        return e.visitExpression(_this, context);\n      })), ast.type, ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitInstantiateExpr = function (ast, context) {\n      return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitLiteralExpr = function (ast, context) {\n      return this.transformExpr(ast, context);\n    };\n\n    AstTransformer.prototype.visitLocalizedString = function (ast, context) {\n      return this.transformExpr(new LocalizedString(ast.metaBlock, ast.messageParts, ast.placeHolderNames, this.visitAllExpressions(ast.expressions, context), ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitExternalExpr = function (ast, context) {\n      return this.transformExpr(ast, context);\n    };\n\n    AstTransformer.prototype.visitConditionalExpr = function (ast, context) {\n      return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitNotExpr = function (ast, context) {\n      return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitAssertNotNullExpr = function (ast, context) {\n      return this.transformExpr(new AssertNotNull(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitCastExpr = function (ast, context) {\n      return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitFunctionExpr = function (ast, context) {\n      return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitUnaryOperatorExpr = function (ast, context) {\n      return this.transformExpr(new UnaryOperatorExpr(ast.operator, ast.expr.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitBinaryOperatorExpr = function (ast, context) {\n      return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitReadPropExpr = function (ast, context) {\n      return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitReadKeyExpr = function (ast, context) {\n      return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitLiteralArrayExpr = function (ast, context) {\n      return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitLiteralMapExpr = function (ast, context) {\n      var _this = this;\n\n      var entries = ast.entries.map(function (entry) {\n        return new LiteralMapEntry(entry.key, entry.value.visitExpression(_this, context), entry.quoted);\n      });\n      var mapType = new MapType(ast.valueType);\n      return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitCommaExpr = function (ast, context) {\n      return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitAllExpressions = function (exprs, context) {\n      var _this = this;\n\n      return exprs.map(function (expr) {\n        return expr.visitExpression(_this, context);\n      });\n    };\n\n    AstTransformer.prototype.visitDeclareVarStmt = function (stmt, context) {\n      var value = stmt.value && stmt.value.visitExpression(this, context);\n      return this.transformStmt(new DeclareVarStmt(stmt.name, value, stmt.type, stmt.modifiers, stmt.sourceSpan, stmt.leadingComments), context);\n    };\n\n    AstTransformer.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n      return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan, stmt.leadingComments), context);\n    };\n\n    AstTransformer.prototype.visitExpressionStmt = function (stmt, context) {\n      return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments), context);\n    };\n\n    AstTransformer.prototype.visitReturnStmt = function (stmt, context) {\n      return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments), context);\n    };\n\n    AstTransformer.prototype.visitDeclareClassStmt = function (stmt, context) {\n      var _this = this;\n\n      var parent = stmt.parent.visitExpression(this, context);\n      var getters = stmt.getters.map(function (getter) {\n        return new ClassGetter(getter.name, _this.visitAllStatements(getter.body, context), getter.type, getter.modifiers);\n      });\n      var ctorMethod = stmt.constructorMethod && new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);\n      var methods = stmt.methods.map(function (method) {\n        return new ClassMethod(method.name, method.params, _this.visitAllStatements(method.body, context), method.type, method.modifiers);\n      });\n      return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);\n    };\n\n    AstTransformer.prototype.visitIfStmt = function (stmt, context) {\n      return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan, stmt.leadingComments), context);\n    };\n\n    AstTransformer.prototype.visitTryCatchStmt = function (stmt, context) {\n      return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan, stmt.leadingComments), context);\n    };\n\n    AstTransformer.prototype.visitThrowStmt = function (stmt, context) {\n      return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments), context);\n    };\n\n    AstTransformer.prototype.visitAllStatements = function (stmts, context) {\n      var _this = this;\n\n      return stmts.map(function (stmt) {\n        return stmt.visitStatement(_this, context);\n      });\n    };\n\n    return AstTransformer;\n  }();\n\n  exports.AstTransformer = AstTransformer;\n\n  var RecursiveAstVisitor =\n  /** @class */\n  function () {\n    function RecursiveAstVisitor() {}\n\n    RecursiveAstVisitor.prototype.visitType = function (ast, context) {\n      return ast;\n    };\n\n    RecursiveAstVisitor.prototype.visitExpression = function (ast, context) {\n      if (ast.type) {\n        ast.type.visitType(this, context);\n      }\n\n      return ast;\n    };\n\n    RecursiveAstVisitor.prototype.visitBuiltinType = function (type, context) {\n      return this.visitType(type, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitExpressionType = function (type, context) {\n      var _this = this;\n\n      type.value.visitExpression(this, context);\n\n      if (type.typeParams !== null) {\n        type.typeParams.forEach(function (param) {\n          return _this.visitType(param, context);\n        });\n      }\n\n      return this.visitType(type, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitArrayType = function (type, context) {\n      return this.visitType(type, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitMapType = function (type, context) {\n      return this.visitType(type, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitWrappedNodeExpr = function (ast, context) {\n      return ast;\n    };\n\n    RecursiveAstVisitor.prototype.visitTypeofExpr = function (ast, context) {\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitReadVarExpr = function (ast, context) {\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitWriteVarExpr = function (ast, context) {\n      ast.value.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitWriteKeyExpr = function (ast, context) {\n      ast.receiver.visitExpression(this, context);\n      ast.index.visitExpression(this, context);\n      ast.value.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitWritePropExpr = function (ast, context) {\n      ast.receiver.visitExpression(this, context);\n      ast.value.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitInvokeMethodExpr = function (ast, context) {\n      ast.receiver.visitExpression(this, context);\n      this.visitAllExpressions(ast.args, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitInvokeFunctionExpr = function (ast, context) {\n      ast.fn.visitExpression(this, context);\n      this.visitAllExpressions(ast.args, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitTaggedTemplateExpr = function (ast, context) {\n      ast.tag.visitExpression(this, context);\n      this.visitAllExpressions(ast.template.expressions, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitInstantiateExpr = function (ast, context) {\n      ast.classExpr.visitExpression(this, context);\n      this.visitAllExpressions(ast.args, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitLiteralExpr = function (ast, context) {\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitLocalizedString = function (ast, context) {\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitExternalExpr = function (ast, context) {\n      var _this = this;\n\n      if (ast.typeParams) {\n        ast.typeParams.forEach(function (type) {\n          return type.visitType(_this, context);\n        });\n      }\n\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitConditionalExpr = function (ast, context) {\n      ast.condition.visitExpression(this, context);\n      ast.trueCase.visitExpression(this, context);\n      ast.falseCase.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitNotExpr = function (ast, context) {\n      ast.condition.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitAssertNotNullExpr = function (ast, context) {\n      ast.condition.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitCastExpr = function (ast, context) {\n      ast.value.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitFunctionExpr = function (ast, context) {\n      this.visitAllStatements(ast.statements, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitUnaryOperatorExpr = function (ast, context) {\n      ast.expr.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitBinaryOperatorExpr = function (ast, context) {\n      ast.lhs.visitExpression(this, context);\n      ast.rhs.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitReadPropExpr = function (ast, context) {\n      ast.receiver.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitReadKeyExpr = function (ast, context) {\n      ast.receiver.visitExpression(this, context);\n      ast.index.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {\n      this.visitAllExpressions(ast.entries, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitLiteralMapExpr = function (ast, context) {\n      var _this = this;\n\n      ast.entries.forEach(function (entry) {\n        return entry.value.visitExpression(_this, context);\n      });\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitCommaExpr = function (ast, context) {\n      this.visitAllExpressions(ast.parts, context);\n      return this.visitExpression(ast, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitAllExpressions = function (exprs, context) {\n      var _this = this;\n\n      exprs.forEach(function (expr) {\n        return expr.visitExpression(_this, context);\n      });\n    };\n\n    RecursiveAstVisitor.prototype.visitDeclareVarStmt = function (stmt, context) {\n      if (stmt.value) {\n        stmt.value.visitExpression(this, context);\n      }\n\n      if (stmt.type) {\n        stmt.type.visitType(this, context);\n      }\n\n      return stmt;\n    };\n\n    RecursiveAstVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n      this.visitAllStatements(stmt.statements, context);\n\n      if (stmt.type) {\n        stmt.type.visitType(this, context);\n      }\n\n      return stmt;\n    };\n\n    RecursiveAstVisitor.prototype.visitExpressionStmt = function (stmt, context) {\n      stmt.expr.visitExpression(this, context);\n      return stmt;\n    };\n\n    RecursiveAstVisitor.prototype.visitReturnStmt = function (stmt, context) {\n      stmt.value.visitExpression(this, context);\n      return stmt;\n    };\n\n    RecursiveAstVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {\n      var _this = this;\n\n      stmt.parent.visitExpression(this, context);\n      stmt.getters.forEach(function (getter) {\n        return _this.visitAllStatements(getter.body, context);\n      });\n\n      if (stmt.constructorMethod) {\n        this.visitAllStatements(stmt.constructorMethod.body, context);\n      }\n\n      stmt.methods.forEach(function (method) {\n        return _this.visitAllStatements(method.body, context);\n      });\n      return stmt;\n    };\n\n    RecursiveAstVisitor.prototype.visitIfStmt = function (stmt, context) {\n      stmt.condition.visitExpression(this, context);\n      this.visitAllStatements(stmt.trueCase, context);\n      this.visitAllStatements(stmt.falseCase, context);\n      return stmt;\n    };\n\n    RecursiveAstVisitor.prototype.visitTryCatchStmt = function (stmt, context) {\n      this.visitAllStatements(stmt.bodyStmts, context);\n      this.visitAllStatements(stmt.catchStmts, context);\n      return stmt;\n    };\n\n    RecursiveAstVisitor.prototype.visitThrowStmt = function (stmt, context) {\n      stmt.error.visitExpression(this, context);\n      return stmt;\n    };\n\n    RecursiveAstVisitor.prototype.visitAllStatements = function (stmts, context) {\n      var _this = this;\n\n      stmts.forEach(function (stmt) {\n        return stmt.visitStatement(_this, context);\n      });\n    };\n\n    return RecursiveAstVisitor;\n  }();\n\n  exports.RecursiveAstVisitor = RecursiveAstVisitor;\n\n  function findReadVarNames(stmts) {\n    var visitor = new _ReadVarVisitor();\n    visitor.visitAllStatements(stmts, null);\n    return visitor.varNames;\n  }\n\n  exports.findReadVarNames = findReadVarNames;\n\n  var _ReadVarVisitor =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(_ReadVarVisitor, _super);\n\n    function _ReadVarVisitor() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.varNames = new Set();\n      return _this;\n    }\n\n    _ReadVarVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n      // Don't descend into nested functions\n      return stmt;\n    };\n\n    _ReadVarVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {\n      // Don't descend into nested classes\n      return stmt;\n    };\n\n    _ReadVarVisitor.prototype.visitReadVarExpr = function (ast, context) {\n      if (ast.name) {\n        this.varNames.add(ast.name);\n      }\n\n      return null;\n    };\n\n    return _ReadVarVisitor;\n  }(RecursiveAstVisitor);\n\n  function collectExternalReferences(stmts) {\n    var visitor = new _FindExternalReferencesVisitor();\n    visitor.visitAllStatements(stmts, null);\n    return visitor.externalReferences;\n  }\n\n  exports.collectExternalReferences = collectExternalReferences;\n\n  var _FindExternalReferencesVisitor =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(_FindExternalReferencesVisitor, _super);\n\n    function _FindExternalReferencesVisitor() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.externalReferences = [];\n      return _this;\n    }\n\n    _FindExternalReferencesVisitor.prototype.visitExternalExpr = function (e, context) {\n      this.externalReferences.push(e.value);\n      return _super.prototype.visitExternalExpr.call(this, e, context);\n    };\n\n    return _FindExternalReferencesVisitor;\n  }(RecursiveAstVisitor);\n\n  function applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {\n    if (!sourceSpan) {\n      return stmt;\n    }\n\n    var transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return stmt.visitStatement(transformer, null);\n  }\n\n  exports.applySourceSpanToStatementIfNeeded = applySourceSpanToStatementIfNeeded;\n\n  function applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {\n    if (!sourceSpan) {\n      return expr;\n    }\n\n    var transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return expr.visitExpression(transformer, null);\n  }\n\n  exports.applySourceSpanToExpressionIfNeeded = applySourceSpanToExpressionIfNeeded;\n\n  var _ApplySourceSpanTransformer =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(_ApplySourceSpanTransformer, _super);\n\n    function _ApplySourceSpanTransformer(sourceSpan) {\n      var _this = _super.call(this) || this;\n\n      _this.sourceSpan = sourceSpan;\n      return _this;\n    }\n\n    _ApplySourceSpanTransformer.prototype._clone = function (obj) {\n      var e_1, _a;\n\n      var clone = Object.create(obj.constructor.prototype);\n\n      try {\n        for (var _b = tslib_1.__values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var prop = _c.value;\n          clone[prop] = obj[prop];\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return clone;\n    };\n\n    _ApplySourceSpanTransformer.prototype.transformExpr = function (expr, context) {\n      if (!expr.sourceSpan) {\n        expr = this._clone(expr);\n        expr.sourceSpan = this.sourceSpan;\n      }\n\n      return expr;\n    };\n\n    _ApplySourceSpanTransformer.prototype.transformStmt = function (stmt, context) {\n      if (!stmt.sourceSpan) {\n        stmt = this._clone(stmt);\n        stmt.sourceSpan = this.sourceSpan;\n      }\n\n      return stmt;\n    };\n\n    return _ApplySourceSpanTransformer;\n  }(AstTransformer);\n\n  function leadingComment(text, multiline, trailingNewline) {\n    if (multiline === void 0) {\n      multiline = false;\n    }\n\n    if (trailingNewline === void 0) {\n      trailingNewline = true;\n    }\n\n    return new LeadingComment(text, multiline, trailingNewline);\n  }\n\n  exports.leadingComment = leadingComment;\n\n  function jsDocComment(tags) {\n    if (tags === void 0) {\n      tags = [];\n    }\n\n    return new JSDocComment(tags);\n  }\n\n  exports.jsDocComment = jsDocComment;\n\n  function variable(name, type, sourceSpan) {\n    return new ReadVarExpr(name, type, sourceSpan);\n  }\n\n  exports.variable = variable;\n\n  function importExpr(id, typeParams, sourceSpan) {\n    if (typeParams === void 0) {\n      typeParams = null;\n    }\n\n    return new ExternalExpr(id, null, typeParams, sourceSpan);\n  }\n\n  exports.importExpr = importExpr;\n\n  function importType(id, typeParams, typeModifiers) {\n    return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n  }\n\n  exports.importType = importType;\n\n  function expressionType(expr, typeModifiers, typeParams) {\n    return new ExpressionType(expr, typeModifiers, typeParams);\n  }\n\n  exports.expressionType = expressionType;\n\n  function typeofExpr(expr) {\n    return new TypeofExpr(expr);\n  }\n\n  exports.typeofExpr = typeofExpr;\n\n  function literalArr(values, type, sourceSpan) {\n    return new LiteralArrayExpr(values, type, sourceSpan);\n  }\n\n  exports.literalArr = literalArr;\n\n  function literalMap(values, type) {\n    if (type === void 0) {\n      type = null;\n    }\n\n    return new LiteralMapExpr(values.map(function (e) {\n      return new LiteralMapEntry(e.key, e.value, e.quoted);\n    }), type, null);\n  }\n\n  exports.literalMap = literalMap;\n\n  function unary(operator, expr, type, sourceSpan) {\n    return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n  }\n\n  exports.unary = unary;\n\n  function not(expr, sourceSpan) {\n    return new NotExpr(expr, sourceSpan);\n  }\n\n  exports.not = not;\n\n  function assertNotNull(expr, sourceSpan) {\n    return new AssertNotNull(expr, sourceSpan);\n  }\n\n  exports.assertNotNull = assertNotNull;\n\n  function fn(params, body, type, sourceSpan, name) {\n    return new FunctionExpr(params, body, type, sourceSpan, name);\n  }\n\n  exports.fn = fn;\n\n  function ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {\n    return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n  }\n\n  exports.ifStmt = ifStmt;\n\n  function taggedTemplate(tag, template, type, sourceSpan) {\n    return new TaggedTemplateExpr(tag, template, type, sourceSpan);\n  }\n\n  exports.taggedTemplate = taggedTemplate;\n\n  function literal(value, type, sourceSpan) {\n    return new LiteralExpr(value, type, sourceSpan);\n  }\n\n  exports.literal = literal;\n\n  function localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {\n    return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n  }\n\n  exports.localizedString = localizedString;\n\n  function isNull(exp) {\n    return exp instanceof LiteralExpr && exp.value === null;\n  }\n\n  exports.isNull = isNull;\n  /*\n   * Serializes a `Tag` into a string.\n   * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n   */\n\n  function tagToString(tag) {\n    var out = '';\n\n    if (tag.tagName) {\n      out += \" @\" + tag.tagName;\n    }\n\n    if (tag.text) {\n      if (tag.text.match(/\\/\\*|\\*\\//)) {\n        throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n      }\n\n      out += ' ' + tag.text.replace(/@/g, '\\\\@');\n    }\n\n    return out;\n  }\n\n  function serializeTags(tags) {\n    var e_2, _a;\n\n    if (tags.length === 0) return '';\n\n    if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n      // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\n      return \"*\" + tagToString(tags[0]) + \" \";\n    }\n\n    var out = '*\\n';\n\n    try {\n      for (var tags_1 = tslib_1.__values(tags), tags_1_1 = tags_1.next(); !tags_1_1.done; tags_1_1 = tags_1.next()) {\n        var tag = tags_1_1.value;\n        out += ' *'; // If the tagToString is multi-line, insert \" * \" prefixes on lines.\n\n        out += tagToString(tag).replace(/\\n/g, '\\n * ');\n        out += '\\n';\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (tags_1_1 && !tags_1_1.done && (_a = tags_1.return)) _a.call(tags_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    out += ' ';\n    return out;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/output/output_ast.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {ParseSourceSpan} from '../parse_util';\nimport {I18nMeta} from '../render3/view/i18n/meta';\n\n//// Types\nexport enum TypeModifier {\n  Const\n}\n\nexport abstract class Type {\n  constructor(public modifiers: TypeModifier[] = []) {}\n  abstract visitType(visitor: TypeVisitor, context: any): any;\n\n  hasModifier(modifier: TypeModifier): boolean {\n    return this.modifiers.indexOf(modifier) !== -1;\n  }\n}\n\nexport enum BuiltinTypeName {\n  Dynamic,\n  Bool,\n  String,\n  Int,\n  Number,\n  Function,\n  Inferred,\n  None,\n}\n\nexport class BuiltinType extends Type {\n  constructor(public name: BuiltinTypeName, modifiers?: TypeModifier[]) {\n    super(modifiers);\n  }\n  visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitBuiltinType(this, context);\n  }\n}\n\nexport class ExpressionType extends Type {\n  constructor(\n      public value: Expression, modifiers?: TypeModifier[], public typeParams: Type[]|null = null) {\n    super(modifiers);\n  }\n  visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitExpressionType(this, context);\n  }\n}\n\n\nexport class ArrayType extends Type {\n  constructor(public of: Type, modifiers?: TypeModifier[]) {\n    super(modifiers);\n  }\n  visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitArrayType(this, context);\n  }\n}\n\n\nexport class MapType extends Type {\n  public valueType: Type|null;\n  constructor(valueType: Type|null|undefined, modifiers?: TypeModifier[]) {\n    super(modifiers);\n    this.valueType = valueType || null;\n  }\n  visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitMapType(this, context);\n  }\n}\n\nexport const DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nexport const INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nexport const BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nexport const INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nexport const NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nexport const STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nexport const FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nexport const NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\n\nexport interface TypeVisitor {\n  visitBuiltinType(type: BuiltinType, context: any): any;\n  visitExpressionType(type: ExpressionType, context: any): any;\n  visitArrayType(type: ArrayType, context: any): any;\n  visitMapType(type: MapType, context: any): any;\n}\n\n///// Expressions\n\nexport enum UnaryOperator {\n  Minus,\n  Plus,\n}\n\nexport enum BinaryOperator {\n  Equals,\n  NotEquals,\n  Identical,\n  NotIdentical,\n  Minus,\n  Plus,\n  Divide,\n  Multiply,\n  Modulo,\n  And,\n  Or,\n  BitwiseAnd,\n  Lower,\n  LowerEquals,\n  Bigger,\n  BiggerEquals\n}\n\nexport function nullSafeIsEquivalent<T extends {isEquivalent(other: T): boolean}>(\n    base: T|null, other: T|null) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n  return base.isEquivalent(other);\n}\n\nfunction areAllEquivalentPredicate<T>(\n    base: T[], other: T[], equivalentPredicate: (baseElement: T, otherElement: T) => boolean) {\n  const len = base.length;\n  if (len !== other.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (!equivalentPredicate(base[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function areAllEquivalent<T extends {isEquivalent(other: T): boolean}>(\n    base: T[], other: T[]) {\n  return areAllEquivalentPredicate(\n      base, other, (baseElement: T, otherElement: T) => baseElement.isEquivalent(otherElement));\n}\n\nexport abstract class Expression {\n  public type: Type|null;\n  public sourceSpan: ParseSourceSpan|null;\n\n  constructor(type: Type|null|undefined, sourceSpan?: ParseSourceSpan|null) {\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n\n  abstract visitExpression(visitor: ExpressionVisitor, context: any): any;\n\n  /**\n   * Calculates whether this expression produces the same value as the given expression.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(e: Expression): boolean;\n\n  /**\n   * Return true if the expression is constant.\n   */\n  abstract isConstant(): boolean;\n\n  prop(name: string, sourceSpan?: ParseSourceSpan|null): ReadPropExpr {\n    return new ReadPropExpr(this, name, null, sourceSpan);\n  }\n\n  key(index: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null): ReadKeyExpr {\n    return new ReadKeyExpr(this, index, type, sourceSpan);\n  }\n\n  callMethod(name: string|BuiltinMethod, params: Expression[], sourceSpan?: ParseSourceSpan|null):\n      InvokeMethodExpr {\n    return new InvokeMethodExpr(this, name, params, null, sourceSpan);\n  }\n\n  callFn(params: Expression[], sourceSpan?: ParseSourceSpan|null, pure?: boolean):\n      InvokeFunctionExpr {\n    return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n  }\n\n  instantiate(params: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null):\n      InstantiateExpr {\n    return new InstantiateExpr(this, params, type, sourceSpan);\n  }\n\n  conditional(\n      trueCase: Expression, falseCase: Expression|null = null,\n      sourceSpan?: ParseSourceSpan|null): ConditionalExpr {\n    return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n  }\n\n  equals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n  }\n  notEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n  }\n  identical(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n  }\n  notIdentical(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n  }\n  minus(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n  }\n  plus(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n  }\n  divide(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n  }\n  multiply(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n  }\n  modulo(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n  }\n  and(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n  }\n  bitwiseAnd(rhs: Expression, sourceSpan?: ParseSourceSpan|null, parens: boolean = true):\n      BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n  }\n  or(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n  }\n  lower(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n  }\n  lowerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n  }\n  bigger(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n  }\n  biggerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n  }\n  isBlank(sourceSpan?: ParseSourceSpan|null): Expression {\n    // Note: We use equals by purpose here to compare to null and undefined in JS.\n    // We use the typed null to allow strictNullChecks to narrow types.\n    return this.equals(TYPED_NULL_EXPR, sourceSpan);\n  }\n  cast(type: Type, sourceSpan?: ParseSourceSpan|null): Expression {\n    return new CastExpr(this, type, sourceSpan);\n  }\n\n  toStmt(): Statement {\n    return new ExpressionStatement(this, null);\n  }\n}\n\nexport enum BuiltinVar {\n  This,\n  Super,\n  CatchError,\n  CatchStack\n}\n\nexport class ReadVarExpr extends Expression {\n  public name: string|null;\n  public builtin: BuiltinVar|null;\n\n  constructor(name: string|BuiltinVar, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    if (typeof name === 'string') {\n      this.name = name;\n      this.builtin = null;\n    } else {\n      this.name = null;\n      this.builtin = name;\n    }\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadVarExpr(this, context);\n  }\n\n  set(value: Expression): WriteVarExpr {\n    if (!this.name) {\n      throw new Error(`Built in variable ${this.builtin} can not be assigned to.`);\n    }\n    return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n  }\n}\n\nexport class TypeofExpr extends Expression {\n  constructor(public expr: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitTypeofExpr(this, context);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n  }\n\n  isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n}\n\nexport class WrappedNodeExpr<T> extends Expression {\n  constructor(public node: T, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof WrappedNodeExpr && this.node === e.node;\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWrappedNodeExpr(this, context);\n  }\n}\n\nexport class WriteVarExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public name: string, value: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteVarExpr(this, context);\n  }\n\n  toDeclStmt(type?: Type|null, modifiers?: StmtModifier[]): DeclareVarStmt {\n    return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n  }\n\n  toConstDecl(): DeclareVarStmt {\n    return this.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]);\n  }\n}\n\n\nexport class WriteKeyExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public receiver: Expression, public index: Expression, value: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteKeyExpr(this, context);\n  }\n}\n\n\nexport class WritePropExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public receiver: Expression, public name: string, value: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name && this.value.isEquivalent(e.value);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWritePropExpr(this, context);\n  }\n}\n\nexport enum BuiltinMethod {\n  ConcatArray,\n  SubscribeObservable,\n  Bind\n}\n\nexport class InvokeMethodExpr extends Expression {\n  public name: string|null;\n  public builtin: BuiltinMethod|null;\n  constructor(\n      public receiver: Expression, method: string|BuiltinMethod, public args: Expression[],\n      type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    if (typeof method === 'string') {\n      this.name = method;\n      this.builtin = null;\n    } else {\n      this.name = null;\n      this.builtin = <BuiltinMethod>method;\n    }\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInvokeMethodExpr(this, context);\n  }\n}\n\n\nexport class InvokeFunctionExpr extends Expression {\n  constructor(\n      public fn: Expression, public args: Expression[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public pure = false) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&\n        areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInvokeFunctionExpr(this, context);\n  }\n}\n\n\nexport class TaggedTemplateExpr extends Expression {\n  constructor(\n      public tag: Expression, public template: TemplateLiteral, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) &&\n        areAllEquivalentPredicate(\n               this.template.elements, e.template.elements, (a, b) => a.text === b.text) &&\n        areAllEquivalent(this.template.expressions, e.template.expressions);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitTaggedTemplateExpr(this, context);\n  }\n}\n\n\nexport class InstantiateExpr extends Expression {\n  constructor(\n      public classExpr: Expression, public args: Expression[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&\n        areAllEquivalent(this.args, e.args);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInstantiateExpr(this, context);\n  }\n}\n\n\nexport class LiteralExpr extends Expression {\n  constructor(\n      public value: number|string|boolean|null|undefined, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralExpr && this.value === e.value;\n  }\n\n  isConstant() {\n    return true;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralExpr(this, context);\n  }\n}\n\nexport class TemplateLiteral {\n  constructor(public elements: TemplateLiteralElement[], public expressions: Expression[]) {}\n}\nexport class TemplateLiteralElement {\n  rawText: string;\n  constructor(public text: string, public sourceSpan?: ParseSourceSpan, rawText?: string) {\n    // If `rawText` is not provided, try to extract the raw string from its\n    // associated `sourceSpan`. If that is also not available, \"fake\" the raw\n    // string instead by escaping the following control sequences:\n    // - \"\\\" would otherwise indicate that the next character is a control character.\n    // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\n    // indicate the end of the template literal element.\n    this.rawText =\n        rawText ?? sourceSpan?.toString() ?? escapeForTemplateLiteral(escapeSlashes(text));\n  }\n}\n\nexport abstract class MessagePiece {\n  constructor(public text: string, public sourceSpan: ParseSourceSpan) {}\n}\nexport class LiteralPiece extends MessagePiece {}\nexport class PlaceholderPiece extends MessagePiece {}\n\nexport class LocalizedString extends Expression {\n  constructor(\n      readonly metaBlock: I18nMeta, readonly messageParts: LiteralPiece[],\n      readonly placeHolderNames: PlaceholderPiece[], readonly expressions: Expression[],\n      sourceSpan?: ParseSourceSpan|null) {\n    super(STRING_TYPE, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    // return e instanceof LocalizedString && this.message === e.message;\n    return false;\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLocalizedString(this, context);\n  }\n\n  /**\n   * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n   * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n   * `parseI18nMeta()`.\n   *\n   * @param meta The metadata to serialize\n   * @param messagePart The first part of the tagged string\n   */\n  serializeI18nHead(): CookedRawString {\n    const MEANING_SEPARATOR = '|';\n    const ID_SEPARATOR = '@@';\n    const LEGACY_ID_INDICATOR = 'âŸ';\n\n    let metaBlock = this.metaBlock.description || '';\n    if (this.metaBlock.meaning) {\n      metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;\n    }\n    if (this.metaBlock.customId) {\n      metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;\n    }\n    if (this.metaBlock.legacyIds) {\n      this.metaBlock.legacyIds.forEach(legacyId => {\n        metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n      });\n    }\n    return createCookedRawString(\n        metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n  }\n\n  getMessagePartSourceSpan(i: number): ParseSourceSpan|null {\n    return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;\n  }\n\n  getPlaceholderSourceSpan(i: number): ParseSourceSpan {\n    return this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ??\n        this.sourceSpan;\n  }\n\n  /**\n   * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n   * can be used in a `$localize` tagged string.\n   *\n   * @param placeholderName The placeholder name to serialize\n   * @param messagePart The following message string after this placeholder\n   */\n  serializeI18nTemplatePart(partIndex: number): CookedRawString {\n    const placeholderName = this.placeHolderNames[partIndex - 1].text;\n    const messagePart = this.messageParts[partIndex];\n    return createCookedRawString(\n        placeholderName, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n  }\n}\n\n/**\n * A structure to hold the cooked and raw strings of a template literal element, along with its\n * source-span range.\n */\nexport interface CookedRawString {\n  cooked: string;\n  raw: string;\n  range: ParseSourceSpan|null;\n}\n\nconst escapeSlashes = (str: string): string => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = (str: string): string => str.replace(/^:/, '\\\\:');\nconst escapeColons = (str: string): string => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = (str: string): string =>\n    str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\nfunction createCookedRawString(\n    metaBlock: string, messagePart: string, range: ParseSourceSpan|null): CookedRawString {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n      range,\n    };\n  } else {\n    return {\n      cooked: `:${metaBlock}:${messagePart}`,\n      raw: escapeForTemplateLiteral(\n          `:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),\n      range,\n    };\n  }\n}\n\nexport class ExternalExpr extends Expression {\n  constructor(\n      public value: ExternalReference, type?: Type|null, public typeParams: Type[]|null = null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof ExternalExpr && this.value.name === e.value.name &&\n        this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitExternalExpr(this, context);\n  }\n}\n\nexport class ExternalReference {\n  constructor(public moduleName: string|null, public name: string|null, public runtime?: any|null) {\n  }\n  // Note: no isEquivalent method here as we use this as an interface too.\n}\n\nexport class ConditionalExpr extends Expression {\n  public trueCase: Expression;\n\n  constructor(\n      public condition: Expression, trueCase: Expression, public falseCase: Expression|null = null,\n      type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type || trueCase.type, sourceSpan);\n    this.trueCase = trueCase;\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&\n        this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitConditionalExpr(this, context);\n  }\n}\n\n\nexport class NotExpr extends Expression {\n  constructor(public condition: Expression, sourceSpan?: ParseSourceSpan|null) {\n    super(BOOL_TYPE, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitNotExpr(this, context);\n  }\n}\n\nexport class AssertNotNull extends Expression {\n  constructor(public condition: Expression, sourceSpan?: ParseSourceSpan|null) {\n    super(condition.type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitAssertNotNullExpr(this, context);\n  }\n}\n\nexport class CastExpr extends Expression {\n  constructor(public value: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof CastExpr && this.value.isEquivalent(e.value);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitCastExpr(this, context);\n  }\n}\n\n\nexport class FnParam {\n  constructor(public name: string, public type: Type|null = null) {}\n\n  isEquivalent(param: FnParam): boolean {\n    return this.name === param.name;\n  }\n}\n\n\nexport class FunctionExpr extends Expression {\n  constructor(\n      public params: FnParam[], public statements: Statement[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public name?: string|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&\n        areAllEquivalent(this.statements, e.statements);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitFunctionExpr(this, context);\n  }\n\n  toDeclStmt(name: string, modifiers?: StmtModifier[]): DeclareFunctionStmt {\n    return new DeclareFunctionStmt(\n        name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n  }\n}\n\n\nexport class UnaryOperatorExpr extends Expression {\n  constructor(\n      public operator: UnaryOperator, public expr: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public parens: boolean = true) {\n    super(type || NUMBER_TYPE, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof UnaryOperatorExpr && this.operator === e.operator &&\n        this.expr.isEquivalent(e.expr);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitUnaryOperatorExpr(this, context);\n  }\n}\n\n\nexport class BinaryOperatorExpr extends Expression {\n  public lhs: Expression;\n  constructor(\n      public operator: BinaryOperator, lhs: Expression, public rhs: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public parens: boolean = true) {\n    super(type || lhs.type, sourceSpan);\n    this.lhs = lhs;\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof BinaryOperatorExpr && this.operator === e.operator &&\n        this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitBinaryOperatorExpr(this, context);\n  }\n}\n\n\nexport class ReadPropExpr extends Expression {\n  constructor(\n      public receiver: Expression, public name: string, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name;\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadPropExpr(this, context);\n  }\n\n  set(value: Expression): WritePropExpr {\n    return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n  }\n}\n\n\nexport class ReadKeyExpr extends Expression {\n  constructor(\n      public receiver: Expression, public index: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.index.isEquivalent(e.index);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadKeyExpr(this, context);\n  }\n\n  set(value: Expression): WriteKeyExpr {\n    return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n  }\n}\n\n\nexport class LiteralArrayExpr extends Expression {\n  public entries: Expression[];\n  constructor(entries: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    this.entries = entries;\n  }\n\n  isConstant() {\n    return this.entries.every(e => e.isConstant());\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralArrayExpr(this, context);\n  }\n}\n\nexport class LiteralMapEntry {\n  constructor(public key: string, public value: Expression, public quoted: boolean) {}\n  isEquivalent(e: LiteralMapEntry): boolean {\n    return this.key === e.key && this.value.isEquivalent(e.value);\n  }\n}\n\nexport class LiteralMapExpr extends Expression {\n  public valueType: Type|null = null;\n  constructor(\n      public entries: LiteralMapEntry[], type?: MapType|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    if (type) {\n      this.valueType = type.valueType;\n    }\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n  }\n\n  isConstant() {\n    return this.entries.every(e => e.value.isConstant());\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralMapExpr(this, context);\n  }\n}\n\nexport class CommaExpr extends Expression {\n  constructor(public parts: Expression[], sourceSpan?: ParseSourceSpan|null) {\n    super(parts[parts.length - 1].type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n  }\n\n  isConstant() {\n    return false;\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitCommaExpr(this, context);\n  }\n}\n\nexport interface ExpressionVisitor {\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any;\n  visitWriteVarExpr(expr: WriteVarExpr, context: any): any;\n  visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;\n  visitWritePropExpr(expr: WritePropExpr, context: any): any;\n  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;\n  visitTaggedTemplateExpr(ast: TaggedTemplateExpr, context: any): any;\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any;\n  visitLiteralExpr(ast: LiteralExpr, context: any): any;\n  visitLocalizedString(ast: LocalizedString, context: any): any;\n  visitExternalExpr(ast: ExternalExpr, context: any): any;\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any;\n  visitNotExpr(ast: NotExpr, context: any): any;\n  visitAssertNotNullExpr(ast: AssertNotNull, context: any): any;\n  visitCastExpr(ast: CastExpr, context: any): any;\n  visitFunctionExpr(ast: FunctionExpr, context: any): any;\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any;\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any;\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;\n  visitCommaExpr(ast: CommaExpr, context: any): any;\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any;\n  visitTypeofExpr(ast: TypeofExpr, context: any): any;\n}\n\nexport const THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);\nexport const SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);\nexport const CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);\nexport const CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);\nexport const NULL_EXPR = new LiteralExpr(null, null, null);\nexport const TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n\n//// Statements\nexport enum StmtModifier {\n  Final,\n  Private,\n  Exported,\n  Static,\n}\n\nexport class LeadingComment {\n  constructor(public text: string, public multiline: boolean, public trailingNewline: boolean) {}\n  toString() {\n    return this.multiline ? ` ${this.text} ` : this.text;\n  }\n}\nexport class JSDocComment extends LeadingComment {\n  constructor(public tags: JSDocTag[]) {\n    super('', /* multiline */ true, /* trailingNewline */ true);\n  }\n  toString(): string {\n    return serializeTags(this.tags);\n  }\n}\n\nexport abstract class Statement {\n  constructor(\n      public modifiers: StmtModifier[] = [], public sourceSpan: ParseSourceSpan|null = null,\n      public leadingComments?: LeadingComment[]) {}\n  /**\n   * Calculates whether this statement produces the same value as the given statement.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(stmt: Statement): boolean;\n\n  abstract visitStatement(visitor: StatementVisitor, context: any): any;\n\n  hasModifier(modifier: StmtModifier): boolean {\n    return this.modifiers.indexOf(modifier) !== -1;\n  }\n\n  addLeadingComment(leadingComment: LeadingComment): void {\n    this.leadingComments = this.leadingComments ?? [];\n    this.leadingComments.push(leadingComment);\n  }\n}\n\n\nexport class DeclareVarStmt extends Statement {\n  public type: Type|null;\n  constructor(\n      public name: string, public value?: Expression, type?: Type|null, modifiers?: StmtModifier[],\n      sourceSpan?: ParseSourceSpan|null, leadingComments?: LeadingComment[]) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || (value && value.type) || null;\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof DeclareVarStmt && this.name === stmt.name &&\n        (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareVarStmt(this, context);\n  }\n}\n\nexport class DeclareFunctionStmt extends Statement {\n  public type: Type|null;\n  constructor(\n      public name: string, public params: FnParam[], public statements: Statement[],\n      type?: Type|null, modifiers?: StmtModifier[], sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || null;\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\n        areAllEquivalent(this.statements, stmt.statements);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareFunctionStmt(this, context);\n  }\n}\n\nexport class ExpressionStatement extends Statement {\n  constructor(\n      public expr: Expression, sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super([], sourceSpan, leadingComments);\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitExpressionStmt(this, context);\n  }\n}\n\n\nexport class ReturnStatement extends Statement {\n  constructor(\n      public value: Expression, sourceSpan: ParseSourceSpan|null = null,\n      leadingComments?: LeadingComment[]) {\n    super([], sourceSpan, leadingComments);\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitReturnStmt(this, context);\n  }\n}\n\nexport class AbstractClassPart {\n  constructor(public type: Type|null = null, public modifiers: StmtModifier[] = []) {}\n  hasModifier(modifier: StmtModifier): boolean {\n    return this.modifiers.indexOf(modifier) !== -1;\n  }\n}\n\nexport class ClassField extends AbstractClassPart {\n  constructor(\n      public name: string, type?: Type|null, modifiers?: StmtModifier[],\n      public initializer?: Expression) {\n    super(type, modifiers);\n  }\n  isEquivalent(f: ClassField) {\n    return this.name === f.name;\n  }\n}\n\n\nexport class ClassMethod extends AbstractClassPart {\n  constructor(\n      public name: string|null, public params: FnParam[], public body: Statement[],\n      type?: Type|null, modifiers?: StmtModifier[]) {\n    super(type, modifiers);\n  }\n  isEquivalent(m: ClassMethod) {\n    return this.name === m.name && areAllEquivalent(this.body, m.body);\n  }\n}\n\n\nexport class ClassGetter extends AbstractClassPart {\n  constructor(\n      public name: string, public body: Statement[], type?: Type|null, modifiers?: StmtModifier[]) {\n    super(type, modifiers);\n  }\n  isEquivalent(m: ClassGetter) {\n    return this.name === m.name && areAllEquivalent(this.body, m.body);\n  }\n}\n\n\nexport class ClassStmt extends Statement {\n  constructor(\n      public name: string, public parent: Expression|null, public fields: ClassField[],\n      public getters: ClassGetter[], public constructorMethod: ClassMethod,\n      public methods: ClassMethod[], modifiers?: StmtModifier[], sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(modifiers, sourceSpan, leadingComments);\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ClassStmt && this.name === stmt.name &&\n        nullSafeIsEquivalent(this.parent, stmt.parent) &&\n        areAllEquivalent(this.fields, stmt.fields) &&\n        areAllEquivalent(this.getters, stmt.getters) &&\n        this.constructorMethod.isEquivalent(stmt.constructorMethod) &&\n        areAllEquivalent(this.methods, stmt.methods);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareClassStmt(this, context);\n  }\n}\n\n\nexport class IfStmt extends Statement {\n  constructor(\n      public condition: Expression, public trueCase: Statement[],\n      public falseCase: Statement[] = [], sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super([], sourceSpan, leadingComments);\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\n        areAllEquivalent(this.trueCase, stmt.trueCase) &&\n        areAllEquivalent(this.falseCase, stmt.falseCase);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitIfStmt(this, context);\n  }\n}\n\nexport class TryCatchStmt extends Statement {\n  constructor(\n      public bodyStmts: Statement[], public catchStmts: Statement[],\n      sourceSpan: ParseSourceSpan|null = null, leadingComments?: LeadingComment[]) {\n    super([], sourceSpan, leadingComments);\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof TryCatchStmt && areAllEquivalent(this.bodyStmts, stmt.bodyStmts) &&\n        areAllEquivalent(this.catchStmts, stmt.catchStmts);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitTryCatchStmt(this, context);\n  }\n}\n\n\nexport class ThrowStmt extends Statement {\n  constructor(\n      public error: Expression, sourceSpan: ParseSourceSpan|null = null,\n      leadingComments?: LeadingComment[]) {\n    super([], sourceSpan, leadingComments);\n  }\n  isEquivalent(stmt: ThrowStmt): boolean {\n    return stmt instanceof TryCatchStmt && this.error.isEquivalent(stmt.error);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitThrowStmt(this, context);\n  }\n}\n\nexport interface StatementVisitor {\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any;\n  visitReturnStmt(stmt: ReturnStatement, context: any): any;\n  visitDeclareClassStmt(stmt: ClassStmt, context: any): any;\n  visitIfStmt(stmt: IfStmt, context: any): any;\n  visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;\n  visitThrowStmt(stmt: ThrowStmt, context: any): any;\n}\n\nexport class AstTransformer implements StatementVisitor, ExpressionVisitor {\n  transformExpr(expr: Expression, context: any): Expression {\n    return expr;\n  }\n\n  transformStmt(stmt: Statement, context: any): Statement {\n    return stmt;\n  }\n\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any {\n    return this.transformExpr(ast, context);\n  }\n\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any {\n    return this.transformExpr(ast, context);\n  }\n\n  visitTypeofExpr(expr: TypeofExpr, context: any): any {\n    return this.transformExpr(\n        new TypeofExpr(expr.expr.visitExpression(this, context), expr.type, expr.sourceSpan),\n        context);\n  }\n\n  visitWriteVarExpr(expr: WriteVarExpr, context: any): any {\n    return this.transformExpr(\n        new WriteVarExpr(\n            expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan),\n        context);\n  }\n\n  visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any {\n    return this.transformExpr(\n        new WriteKeyExpr(\n            expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context),\n            expr.value.visitExpression(this, context), expr.type, expr.sourceSpan),\n        context);\n  }\n\n  visitWritePropExpr(expr: WritePropExpr, context: any): any {\n    return this.transformExpr(\n        new WritePropExpr(\n            expr.receiver.visitExpression(this, context), expr.name,\n            expr.value.visitExpression(this, context), expr.type, expr.sourceSpan),\n        context);\n  }\n\n  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any {\n    const method = ast.builtin || ast.name;\n    return this.transformExpr(\n        new InvokeMethodExpr(\n            ast.receiver.visitExpression(this, context), method!,\n            this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any {\n    return this.transformExpr(\n        new InvokeFunctionExpr(\n            ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context),\n            ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitTaggedTemplateExpr(ast: TaggedTemplateExpr, context: any): any {\n    return this.transformExpr(\n        new TaggedTemplateExpr(\n            ast.tag.visitExpression(this, context),\n            new TemplateLiteral(\n                ast.template.elements,\n                ast.template.expressions.map((e) => e.visitExpression(this, context))),\n            ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any {\n    return this.transformExpr(\n        new InstantiateExpr(\n            ast.classExpr.visitExpression(this, context),\n            this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitLiteralExpr(ast: LiteralExpr, context: any): any {\n    return this.transformExpr(ast, context);\n  }\n\n  visitLocalizedString(ast: LocalizedString, context: any): any {\n    return this.transformExpr(\n        new LocalizedString(\n            ast.metaBlock, ast.messageParts, ast.placeHolderNames,\n            this.visitAllExpressions(ast.expressions, context), ast.sourceSpan),\n        context);\n  }\n\n  visitExternalExpr(ast: ExternalExpr, context: any): any {\n    return this.transformExpr(ast, context);\n  }\n\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any {\n    return this.transformExpr(\n        new ConditionalExpr(\n            ast.condition.visitExpression(this, context),\n            ast.trueCase.visitExpression(this, context),\n            ast.falseCase!.visitExpression(this, context), ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitNotExpr(ast: NotExpr, context: any): any {\n    return this.transformExpr(\n        new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n  }\n\n  visitAssertNotNullExpr(ast: AssertNotNull, context: any): any {\n    return this.transformExpr(\n        new AssertNotNull(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n  }\n\n  visitCastExpr(ast: CastExpr, context: any): any {\n    return this.transformExpr(\n        new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n  }\n\n  visitFunctionExpr(ast: FunctionExpr, context: any): any {\n    return this.transformExpr(\n        new FunctionExpr(\n            ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any {\n    return this.transformExpr(\n        new UnaryOperatorExpr(\n            ast.operator, ast.expr.visitExpression(this, context), ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any {\n    return this.transformExpr(\n        new BinaryOperatorExpr(\n            ast.operator, ast.lhs.visitExpression(this, context),\n            ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any {\n    return this.transformExpr(\n        new ReadPropExpr(\n            ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any {\n    return this.transformExpr(\n        new ReadKeyExpr(\n            ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context),\n            ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any {\n    return this.transformExpr(\n        new LiteralArrayExpr(\n            this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any {\n    const entries = ast.entries.map(\n        (entry): LiteralMapEntry => new LiteralMapEntry(\n            entry.key, entry.value.visitExpression(this, context), entry.quoted));\n    const mapType = new MapType(ast.valueType);\n    return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n  }\n  visitCommaExpr(ast: CommaExpr, context: any): any {\n    return this.transformExpr(\n        new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\n  }\n  visitAllExpressions<T extends Expression>(exprs: T[], context: any): T[] {\n    return exprs.map(expr => expr.visitExpression(this, context));\n  }\n\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any {\n    const value = stmt.value && stmt.value.visitExpression(this, context);\n    return this.transformStmt(\n        new DeclareVarStmt(\n            stmt.name, value, stmt.type, stmt.modifiers, stmt.sourceSpan, stmt.leadingComments),\n        context);\n  }\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n    return this.transformStmt(\n        new DeclareFunctionStmt(\n            stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type,\n            stmt.modifiers, stmt.sourceSpan, stmt.leadingComments),\n        context);\n  }\n\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any {\n    return this.transformStmt(\n        new ExpressionStatement(\n            stmt.expr.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments),\n        context);\n  }\n\n  visitReturnStmt(stmt: ReturnStatement, context: any): any {\n    return this.transformStmt(\n        new ReturnStatement(\n            stmt.value.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments),\n        context);\n  }\n\n  visitDeclareClassStmt(stmt: ClassStmt, context: any): any {\n    const parent = stmt.parent!.visitExpression(this, context);\n    const getters = stmt.getters.map(\n        getter => new ClassGetter(\n            getter.name, this.visitAllStatements(getter.body, context), getter.type,\n            getter.modifiers));\n    const ctorMethod = stmt.constructorMethod &&\n        new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params,\n                        this.visitAllStatements(stmt.constructorMethod.body, context),\n                        stmt.constructorMethod.type, stmt.constructorMethod.modifiers);\n    const methods = stmt.methods.map(\n        method => new ClassMethod(\n            method.name, method.params, this.visitAllStatements(method.body, context), method.type,\n            method.modifiers));\n    return this.transformStmt(\n        new ClassStmt(\n            stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers,\n            stmt.sourceSpan),\n        context);\n  }\n\n  visitIfStmt(stmt: IfStmt, context: any): any {\n    return this.transformStmt(\n        new IfStmt(\n            stmt.condition.visitExpression(this, context),\n            this.visitAllStatements(stmt.trueCase, context),\n            this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan,\n            stmt.leadingComments),\n        context);\n  }\n\n  visitTryCatchStmt(stmt: TryCatchStmt, context: any): any {\n    return this.transformStmt(\n        new TryCatchStmt(\n            this.visitAllStatements(stmt.bodyStmts, context),\n            this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan,\n            stmt.leadingComments),\n        context);\n  }\n\n  visitThrowStmt(stmt: ThrowStmt, context: any): any {\n    return this.transformStmt(\n        new ThrowStmt(\n            stmt.error.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments),\n        context);\n  }\n\n  visitAllStatements(stmts: Statement[], context: any): Statement[] {\n    return stmts.map(stmt => stmt.visitStatement(this, context));\n  }\n}\n\n\nexport class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor {\n  visitType(ast: Type, context: any): any {\n    return ast;\n  }\n  visitExpression(ast: Expression, context: any): any {\n    if (ast.type) {\n      ast.type.visitType(this, context);\n    }\n    return ast;\n  }\n  visitBuiltinType(type: BuiltinType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitExpressionType(type: ExpressionType, context: any): any {\n    type.value.visitExpression(this, context);\n    if (type.typeParams !== null) {\n      type.typeParams.forEach(param => this.visitType(param, context));\n    }\n    return this.visitType(type, context);\n  }\n  visitArrayType(type: ArrayType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitMapType(type: MapType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any {\n    return ast;\n  }\n  visitTypeofExpr(ast: TypeofExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitWriteVarExpr(ast: WriteVarExpr, context: any): any {\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitWriteKeyExpr(ast: WriteKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitWritePropExpr(ast: WritePropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any {\n    ast.fn.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTaggedTemplateExpr(ast: TaggedTemplateExpr, context: any): any {\n    ast.tag.visitExpression(this, context);\n    this.visitAllExpressions(ast.template.expressions, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any {\n    ast.classExpr.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralExpr(ast: LiteralExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitLocalizedString(ast: LocalizedString, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitExternalExpr(ast: ExternalExpr, context: any): any {\n    if (ast.typeParams) {\n      ast.typeParams.forEach(type => type.visitType(this, context));\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    ast.trueCase.visitExpression(this, context);\n    ast.falseCase!.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitNotExpr(ast: NotExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitAssertNotNullExpr(ast: AssertNotNull, context: any): any {\n    ast.condition.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitCastExpr(ast: CastExpr, context: any): any {\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitFunctionExpr(ast: FunctionExpr, context: any): any {\n    this.visitAllStatements(ast.statements, context);\n    return this.visitExpression(ast, context);\n  }\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any {\n    ast.lhs.visitExpression(this, context);\n    ast.rhs.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any {\n    this.visitAllExpressions(ast.entries, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any {\n    ast.entries.forEach((entry) => entry.value.visitExpression(this, context));\n    return this.visitExpression(ast, context);\n  }\n  visitCommaExpr(ast: CommaExpr, context: any): any {\n    this.visitAllExpressions(ast.parts, context);\n    return this.visitExpression(ast, context);\n  }\n  visitAllExpressions(exprs: Expression[], context: any): void {\n    exprs.forEach(expr => expr.visitExpression(this, context));\n  }\n\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any {\n    if (stmt.value) {\n      stmt.value.visitExpression(this, context);\n    }\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n    this.visitAllStatements(stmt.statements, context);\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any {\n    stmt.expr.visitExpression(this, context);\n    return stmt;\n  }\n  visitReturnStmt(stmt: ReturnStatement, context: any): any {\n    stmt.value.visitExpression(this, context);\n    return stmt;\n  }\n  visitDeclareClassStmt(stmt: ClassStmt, context: any): any {\n    stmt.parent!.visitExpression(this, context);\n    stmt.getters.forEach(getter => this.visitAllStatements(getter.body, context));\n    if (stmt.constructorMethod) {\n      this.visitAllStatements(stmt.constructorMethod.body, context);\n    }\n    stmt.methods.forEach(method => this.visitAllStatements(method.body, context));\n    return stmt;\n  }\n  visitIfStmt(stmt: IfStmt, context: any): any {\n    stmt.condition.visitExpression(this, context);\n    this.visitAllStatements(stmt.trueCase, context);\n    this.visitAllStatements(stmt.falseCase, context);\n    return stmt;\n  }\n  visitTryCatchStmt(stmt: TryCatchStmt, context: any): any {\n    this.visitAllStatements(stmt.bodyStmts, context);\n    this.visitAllStatements(stmt.catchStmts, context);\n    return stmt;\n  }\n  visitThrowStmt(stmt: ThrowStmt, context: any): any {\n    stmt.error.visitExpression(this, context);\n    return stmt;\n  }\n  visitAllStatements(stmts: Statement[], context: any): void {\n    stmts.forEach(stmt => stmt.visitStatement(this, context));\n  }\n}\n\nexport function findReadVarNames(stmts: Statement[]): Set<string> {\n  const visitor = new _ReadVarVisitor();\n  visitor.visitAllStatements(stmts, null);\n  return visitor.varNames;\n}\n\nclass _ReadVarVisitor extends RecursiveAstVisitor {\n  varNames = new Set<string>();\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n    // Don't descend into nested functions\n    return stmt;\n  }\n  visitDeclareClassStmt(stmt: ClassStmt, context: any): any {\n    // Don't descend into nested classes\n    return stmt;\n  }\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any {\n    if (ast.name) {\n      this.varNames.add(ast.name);\n    }\n    return null;\n  }\n}\n\nexport function collectExternalReferences(stmts: Statement[]): ExternalReference[] {\n  const visitor = new _FindExternalReferencesVisitor();\n  visitor.visitAllStatements(stmts, null);\n  return visitor.externalReferences;\n}\n\nclass _FindExternalReferencesVisitor extends RecursiveAstVisitor {\n  externalReferences: ExternalReference[] = [];\n  visitExternalExpr(e: ExternalExpr, context: any) {\n    this.externalReferences.push(e.value);\n    return super.visitExternalExpr(e, context);\n  }\n}\n\nexport function applySourceSpanToStatementIfNeeded(\n    stmt: Statement, sourceSpan: ParseSourceSpan|null): Statement {\n  if (!sourceSpan) {\n    return stmt;\n  }\n  const transformer = new _ApplySourceSpanTransformer(sourceSpan);\n  return stmt.visitStatement(transformer, null);\n}\n\nexport function applySourceSpanToExpressionIfNeeded(\n    expr: Expression, sourceSpan: ParseSourceSpan|null): Expression {\n  if (!sourceSpan) {\n    return expr;\n  }\n  const transformer = new _ApplySourceSpanTransformer(sourceSpan);\n  return expr.visitExpression(transformer, null);\n}\n\nclass _ApplySourceSpanTransformer extends AstTransformer {\n  constructor(private sourceSpan: ParseSourceSpan) {\n    super();\n  }\n  private _clone(obj: any): any {\n    const clone = Object.create(obj.constructor.prototype);\n    for (let prop of Object.keys(obj)) {\n      clone[prop] = obj[prop];\n    }\n    return clone;\n  }\n\n  transformExpr(expr: Expression, context: any): Expression {\n    if (!expr.sourceSpan) {\n      expr = this._clone(expr);\n      expr.sourceSpan = this.sourceSpan;\n    }\n    return expr;\n  }\n\n  transformStmt(stmt: Statement, context: any): Statement {\n    if (!stmt.sourceSpan) {\n      stmt = this._clone(stmt);\n      stmt.sourceSpan = this.sourceSpan;\n    }\n    return stmt;\n  }\n}\n\nexport function leadingComment(\n    text: string, multiline: boolean = false, trailingNewline: boolean = true): LeadingComment {\n  return new LeadingComment(text, multiline, trailingNewline);\n}\n\nexport function jsDocComment(tags: JSDocTag[] = []): JSDocComment {\n  return new JSDocComment(tags);\n}\n\nexport function variable(\n    name: string, type?: Type|null, sourceSpan?: ParseSourceSpan|null): ReadVarExpr {\n  return new ReadVarExpr(name, type, sourceSpan);\n}\n\nexport function importExpr(\n    id: ExternalReference, typeParams: Type[]|null = null,\n    sourceSpan?: ParseSourceSpan|null): ExternalExpr {\n  return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n\nexport function importType(\n    id: ExternalReference, typeParams?: Type[]|null,\n    typeModifiers?: TypeModifier[]): ExpressionType|null {\n  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\n\nexport function expressionType(\n    expr: Expression, typeModifiers?: TypeModifier[], typeParams?: Type[]|null): ExpressionType {\n  return new ExpressionType(expr, typeModifiers, typeParams);\n}\n\nexport function typeofExpr(expr: Expression) {\n  return new TypeofExpr(expr);\n}\n\nexport function literalArr(\n    values: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null): LiteralArrayExpr {\n  return new LiteralArrayExpr(values, type, sourceSpan);\n}\n\nexport function literalMap(\n    values: {key: string, quoted: boolean, value: Expression}[],\n    type: MapType|null = null): LiteralMapExpr {\n  return new LiteralMapExpr(\n      values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\n}\n\nexport function unary(\n    operator: UnaryOperator, expr: Expression, type?: Type,\n    sourceSpan?: ParseSourceSpan|null): UnaryOperatorExpr {\n  return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\n\nexport function not(expr: Expression, sourceSpan?: ParseSourceSpan|null): NotExpr {\n  return new NotExpr(expr, sourceSpan);\n}\n\nexport function assertNotNull(expr: Expression, sourceSpan?: ParseSourceSpan|null): AssertNotNull {\n  return new AssertNotNull(expr, sourceSpan);\n}\n\nexport function fn(\n    params: FnParam[], body: Statement[], type?: Type|null, sourceSpan?: ParseSourceSpan|null,\n    name?: string|null): FunctionExpr {\n  return new FunctionExpr(params, body, type, sourceSpan, name);\n}\n\nexport function ifStmt(\n    condition: Expression, thenClause: Statement[], elseClause?: Statement[],\n    sourceSpan?: ParseSourceSpan, leadingComments?: LeadingComment[]) {\n  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\n\nexport function taggedTemplate(\n    tag: Expression, template: TemplateLiteral, type?: Type|null,\n    sourceSpan?: ParseSourceSpan|null): TaggedTemplateExpr {\n  return new TaggedTemplateExpr(tag, template, type, sourceSpan);\n}\n\nexport function literal(\n    value: any, type?: Type|null, sourceSpan?: ParseSourceSpan|null): LiteralExpr {\n  return new LiteralExpr(value, type, sourceSpan);\n}\n\nexport function localizedString(\n    metaBlock: I18nMeta, messageParts: LiteralPiece[], placeholderNames: PlaceholderPiece[],\n    expressions: Expression[], sourceSpan?: ParseSourceSpan|null): LocalizedString {\n  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\n\nexport function isNull(exp: Expression): boolean {\n  return exp instanceof LiteralExpr && exp.value === null;\n}\n\n// The list of JSDoc tags that we currently support. Extend it if needed.\nexport const enum JSDocTagName {\n  Desc = 'desc',\n  Id = 'id',\n  Meaning = 'meaning',\n}\n\n/*\n * TypeScript has an API for JSDoc already, but it's not exposed.\n * https://github.com/Microsoft/TypeScript/issues/7393\n * For now we create types that are similar to theirs so that migrating\n * to their API will be easier. See e.g. `ts.JSDocTag` and `ts.JSDocComment`.\n */\nexport type JSDocTag = {\n  // `tagName` is e.g. \"param\" in an `@param` declaration\n  tagName: JSDocTagName|string,\n  // Any remaining text on the tag, e.g. the description\n  text?: string,\n}|{\n  // no `tagName` for plain text documentation that occurs before any `@param` lines\n  tagName?: undefined, text: string,\n};\n\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\nfunction tagToString(tag: JSDocTag): string {\n  let out = '';\n  if (tag.tagName) {\n    out += ` @${tag.tagName}`;\n  }\n  if (tag.text) {\n    if (tag.text.match(/\\/\\*|\\*\\//)) {\n      throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n    }\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n  return out;\n}\n\nfunction serializeTags(tags: JSDocTag[]): string {\n  if (tags.length === 0) return '';\n\n  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n    // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\n    return `*${tagToString(tags[0])} `;\n  }\n\n  let out = '*\\n';\n  for (const tag of tags) {\n    out += ' *';\n    // If the tagToString is multi-line, insert \" * \" prefixes on lines.\n    out += tagToString(tag).replace(/\\n/g, '\\n * ');\n    out += '\\n';\n  }\n  out += ' ';\n  return out;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}