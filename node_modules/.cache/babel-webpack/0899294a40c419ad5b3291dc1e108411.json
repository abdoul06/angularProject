{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\n\nvar path = require(\"path\");\n\nvar globParent = require(\"glob-parent\");\n\nvar micromatch = require(\"micromatch\");\n\nvar GLOBSTAR = '**';\nvar ESCAPE_SYMBOL = '\\\\';\nvar COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nvar REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[.*]/;\nvar REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\(.*\\|.*\\)/;\nvar GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\(.*\\)/;\nvar BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\\.\\.).*}/;\n\nfunction isStaticPattern(pattern) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return !isDynamicPattern(pattern, options);\n}\n\nexports.isStaticPattern = isStaticPattern;\n\nfunction isDynamicPattern(pattern) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /**\r\n   * A special case with an empty string is necessary for matching patterns that start with a forward slash.\r\n   * An empty string cannot be a dynamic pattern.\r\n   * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\r\n   */\n  if (pattern === '') {\n    return false;\n  }\n  /**\r\n   * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\r\n   * filepath directly (without read directory).\r\n   */\n\n\n  if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n    return true;\n  }\n\n  if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isDynamicPattern = isDynamicPattern;\n\nfunction convertToPositivePattern(pattern) {\n  return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\n\nexports.convertToPositivePattern = convertToPositivePattern;\n\nfunction convertToNegativePattern(pattern) {\n  return '!' + pattern;\n}\n\nexports.convertToNegativePattern = convertToNegativePattern;\n\nfunction isNegativePattern(pattern) {\n  return pattern.startsWith('!') && pattern[1] !== '(';\n}\n\nexports.isNegativePattern = isNegativePattern;\n\nfunction isPositivePattern(pattern) {\n  return !isNegativePattern(pattern);\n}\n\nexports.isPositivePattern = isPositivePattern;\n\nfunction getNegativePatterns(patterns) {\n  return patterns.filter(isNegativePattern);\n}\n\nexports.getNegativePatterns = getNegativePatterns;\n\nfunction getPositivePatterns(patterns) {\n  return patterns.filter(isPositivePattern);\n}\n\nexports.getPositivePatterns = getPositivePatterns;\n/**\r\n * Returns patterns that can be applied inside the current directory.\r\n *\r\n * @example\r\n * // ['./*', '*', 'a/*']\r\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\r\n */\n\nfunction getPatternsInsideCurrentDirectory(patterns) {\n  return patterns.filter(function (pattern) {\n    return !isPatternRelatedToParentDirectory(pattern);\n  });\n}\n\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\r\n * Returns patterns to be expanded relative to (outside) the current directory.\r\n *\r\n * @example\r\n * // ['../*', './../*']\r\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\r\n */\n\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n  return patterns.filter(isPatternRelatedToParentDirectory);\n}\n\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\n\nfunction isPatternRelatedToParentDirectory(pattern) {\n  return pattern.startsWith('..') || pattern.startsWith('./..');\n}\n\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\n\nfunction getBaseDirectory(pattern) {\n  return globParent(pattern, {\n    flipBackslashes: false\n  });\n}\n\nexports.getBaseDirectory = getBaseDirectory;\n\nfunction hasGlobStar(pattern) {\n  return pattern.includes(GLOBSTAR);\n}\n\nexports.hasGlobStar = hasGlobStar;\n\nfunction endsWithSlashGlobStar(pattern) {\n  return pattern.endsWith('/' + GLOBSTAR);\n}\n\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\n\nfunction isAffectDepthOfReadingPattern(pattern) {\n  var basename = path.basename(pattern);\n  return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\n\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\n\nfunction expandPatternsWithBraceExpansion(patterns) {\n  return patterns.reduce(function (collection, pattern) {\n    return collection.concat(expandBraceExpansion(pattern));\n  }, []);\n}\n\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\n\nfunction expandBraceExpansion(pattern) {\n  return micromatch.braces(pattern, {\n    expand: true,\n    nodupes: true\n  });\n}\n\nexports.expandBraceExpansion = expandBraceExpansion;\n\nfunction getPatternParts(pattern, options) {\n  var _micromatch$scan = micromatch.scan(pattern, Object.assign(Object.assign({}, options), {\n    parts: true\n  })),\n      parts = _micromatch$scan.parts;\n  /**\r\n   * The scan method returns an empty array in some cases.\r\n   * See micromatch/picomatch#58 for more details.\r\n   */\n\n\n  if (parts.length === 0) {\n    parts = [pattern];\n  }\n  /**\r\n   * The scan method does not return an empty part for the pattern with a forward slash.\r\n   * This is another part of micromatch/picomatch#58.\r\n   */\n\n\n  if (parts[0].startsWith('/')) {\n    parts[0] = parts[0].slice(1);\n    parts.unshift('');\n  }\n\n  return parts;\n}\n\nexports.getPatternParts = getPatternParts;\n\nfunction makeRe(pattern, options) {\n  return micromatch.makeRe(pattern, options);\n}\n\nexports.makeRe = makeRe;\n\nfunction convertPatternsToRe(patterns, options) {\n  return patterns.map(function (pattern) {\n    return makeRe(pattern, options);\n  });\n}\n\nexports.convertPatternsToRe = convertPatternsToRe;\n\nfunction matchAny(entry, patternsRe) {\n  return patternsRe.some(function (patternRe) {\n    return patternRe.test(entry);\n  });\n}\n\nexports.matchAny = matchAny;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/fast-glob/out/utils/pattern.js"],"names":["Object","defineProperty","exports","value","matchAny","convertPatternsToRe","makeRe","getPatternParts","expandBraceExpansion","expandPatternsWithBraceExpansion","isAffectDepthOfReadingPattern","endsWithSlashGlobStar","hasGlobStar","getBaseDirectory","isPatternRelatedToParentDirectory","getPatternsOutsideCurrentDirectory","getPatternsInsideCurrentDirectory","getPositivePatterns","getNegativePatterns","isPositivePattern","isNegativePattern","convertToNegativePattern","convertToPositivePattern","isDynamicPattern","isStaticPattern","path","require","globParent","micromatch","GLOBSTAR","ESCAPE_SYMBOL","COMMON_GLOB_SYMBOLS_RE","REGEX_CHARACTER_CLASS_SYMBOLS_RE","REGEX_GROUP_SYMBOLS_RE","GLOB_EXTENSION_SYMBOLS_RE","BRACE_EXPANSIONS_SYMBOLS_RE","pattern","options","caseSensitiveMatch","includes","test","extglob","braceExpansion","slice","startsWith","patterns","filter","flipBackslashes","endsWith","basename","reduce","collection","concat","braces","expand","nodupes","scan","assign","parts","length","unshift","map","entry","patternsRe","some","patternRe"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\r\nconst path = require(\"path\");\r\nconst globParent = require(\"glob-parent\");\r\nconst micromatch = require(\"micromatch\");\r\nconst GLOBSTAR = '**';\r\nconst ESCAPE_SYMBOL = '\\\\';\r\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\r\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[.*]/;\r\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\(.*\\|.*\\)/;\r\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\(.*\\)/;\r\nconst BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\\.\\.).*}/;\r\nfunction isStaticPattern(pattern, options = {}) {\r\n    return !isDynamicPattern(pattern, options);\r\n}\r\nexports.isStaticPattern = isStaticPattern;\r\nfunction isDynamicPattern(pattern, options = {}) {\r\n    /**\r\n     * A special case with an empty string is necessary for matching patterns that start with a forward slash.\r\n     * An empty string cannot be a dynamic pattern.\r\n     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\r\n     */\r\n    if (pattern === '') {\r\n        return false;\r\n    }\r\n    /**\r\n     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\r\n     * filepath directly (without read directory).\r\n     */\r\n    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\r\n        return true;\r\n    }\r\n    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isDynamicPattern = isDynamicPattern;\r\nfunction convertToPositivePattern(pattern) {\r\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\r\n}\r\nexports.convertToPositivePattern = convertToPositivePattern;\r\nfunction convertToNegativePattern(pattern) {\r\n    return '!' + pattern;\r\n}\r\nexports.convertToNegativePattern = convertToNegativePattern;\r\nfunction isNegativePattern(pattern) {\r\n    return pattern.startsWith('!') && pattern[1] !== '(';\r\n}\r\nexports.isNegativePattern = isNegativePattern;\r\nfunction isPositivePattern(pattern) {\r\n    return !isNegativePattern(pattern);\r\n}\r\nexports.isPositivePattern = isPositivePattern;\r\nfunction getNegativePatterns(patterns) {\r\n    return patterns.filter(isNegativePattern);\r\n}\r\nexports.getNegativePatterns = getNegativePatterns;\r\nfunction getPositivePatterns(patterns) {\r\n    return patterns.filter(isPositivePattern);\r\n}\r\nexports.getPositivePatterns = getPositivePatterns;\r\n/**\r\n * Returns patterns that can be applied inside the current directory.\r\n *\r\n * @example\r\n * // ['./*', '*', 'a/*']\r\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\r\n */\r\nfunction getPatternsInsideCurrentDirectory(patterns) {\r\n    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));\r\n}\r\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\r\n/**\r\n * Returns patterns to be expanded relative to (outside) the current directory.\r\n *\r\n * @example\r\n * // ['../*', './../*']\r\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\r\n */\r\nfunction getPatternsOutsideCurrentDirectory(patterns) {\r\n    return patterns.filter(isPatternRelatedToParentDirectory);\r\n}\r\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\r\nfunction isPatternRelatedToParentDirectory(pattern) {\r\n    return pattern.startsWith('..') || pattern.startsWith('./..');\r\n}\r\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\r\nfunction getBaseDirectory(pattern) {\r\n    return globParent(pattern, { flipBackslashes: false });\r\n}\r\nexports.getBaseDirectory = getBaseDirectory;\r\nfunction hasGlobStar(pattern) {\r\n    return pattern.includes(GLOBSTAR);\r\n}\r\nexports.hasGlobStar = hasGlobStar;\r\nfunction endsWithSlashGlobStar(pattern) {\r\n    return pattern.endsWith('/' + GLOBSTAR);\r\n}\r\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\r\nfunction isAffectDepthOfReadingPattern(pattern) {\r\n    const basename = path.basename(pattern);\r\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\r\n}\r\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\r\nfunction expandPatternsWithBraceExpansion(patterns) {\r\n    return patterns.reduce((collection, pattern) => {\r\n        return collection.concat(expandBraceExpansion(pattern));\r\n    }, []);\r\n}\r\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\r\nfunction expandBraceExpansion(pattern) {\r\n    return micromatch.braces(pattern, {\r\n        expand: true,\r\n        nodupes: true\r\n    });\r\n}\r\nexports.expandBraceExpansion = expandBraceExpansion;\r\nfunction getPatternParts(pattern, options) {\r\n    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));\r\n    /**\r\n     * The scan method returns an empty array in some cases.\r\n     * See micromatch/picomatch#58 for more details.\r\n     */\r\n    if (parts.length === 0) {\r\n        parts = [pattern];\r\n    }\r\n    /**\r\n     * The scan method does not return an empty part for the pattern with a forward slash.\r\n     * This is another part of micromatch/picomatch#58.\r\n     */\r\n    if (parts[0].startsWith('/')) {\r\n        parts[0] = parts[0].slice(1);\r\n        parts.unshift('');\r\n    }\r\n    return parts;\r\n}\r\nexports.getPatternParts = getPatternParts;\r\nfunction makeRe(pattern, options) {\r\n    return micromatch.makeRe(pattern, options);\r\n}\r\nexports.makeRe = makeRe;\r\nfunction convertPatternsToRe(patterns, options) {\r\n    return patterns.map((pattern) => makeRe(pattern, options));\r\n}\r\nexports.convertPatternsToRe = convertPatternsToRe;\r\nfunction matchAny(entry, patternsRe) {\r\n    return patternsRe.some((patternRe) => patternRe.test(entry));\r\n}\r\nexports.matchAny = matchAny;\r\n"]},"metadata":{},"sourceType":"script"}