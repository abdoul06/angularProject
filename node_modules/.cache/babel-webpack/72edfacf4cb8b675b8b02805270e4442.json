{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/r3_template_transform\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/ml_parser/ast\", \"@angular/compiler/src/ml_parser/html_whitespaces\", \"@angular/compiler/src/ml_parser/tags\", \"@angular/compiler/src/parse_util\", \"@angular/compiler/src/style_url_resolver\", \"@angular/compiler/src/template_parser/template_preparser\", \"@angular/compiler/src/render3/r3_ast\", \"@angular/compiler/src/render3/view/i18n/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.htmlAstToRender3Ast = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var html = require(\"@angular/compiler/src/ml_parser/ast\");\n\n  var html_whitespaces_1 = require(\"@angular/compiler/src/ml_parser/html_whitespaces\");\n\n  var tags_1 = require(\"@angular/compiler/src/ml_parser/tags\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/parse_util\");\n\n  var style_url_resolver_1 = require(\"@angular/compiler/src/style_url_resolver\");\n\n  var template_preparser_1 = require(\"@angular/compiler/src/template_parser/template_preparser\");\n\n  var t = require(\"@angular/compiler/src/render3/r3_ast\");\n\n  var util_1 = require(\"@angular/compiler/src/render3/view/i18n/util\");\n\n  var BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/; // Group 1 = \"bind-\"\n\n  var KW_BIND_IDX = 1; // Group 2 = \"let-\"\n\n  var KW_LET_IDX = 2; // Group 3 = \"ref-/#\"\n\n  var KW_REF_IDX = 3; // Group 4 = \"on-\"\n\n  var KW_ON_IDX = 4; // Group 5 = \"bindon-\"\n\n  var KW_BINDON_IDX = 5; // Group 6 = \"@\"\n\n  var KW_AT_IDX = 6; // Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\n\n  var IDENT_KW_IDX = 7;\n  var BINDING_DELIMS = {\n    BANANA_BOX: {\n      start: '[(',\n      end: ')]'\n    },\n    PROPERTY: {\n      start: '[',\n      end: ']'\n    },\n    EVENT: {\n      start: '(',\n      end: ')'\n    }\n  };\n  var TEMPLATE_ATTR_PREFIX = '*';\n\n  function htmlAstToRender3Ast(htmlNodes, bindingParser, options) {\n    var transformer = new HtmlAstToIvyAst(bindingParser, options);\n    var ivyNodes = html.visitAll(transformer, htmlNodes); // Errors might originate in either the binding parser or the html to ivy transformer\n\n    var allErrors = bindingParser.errors.concat(transformer.errors);\n    var result = {\n      nodes: ivyNodes,\n      errors: allErrors,\n      styleUrls: transformer.styleUrls,\n      styles: transformer.styles,\n      ngContentSelectors: transformer.ngContentSelectors\n    };\n\n    if (options.collectCommentNodes) {\n      result.commentNodes = transformer.commentNodes;\n    }\n\n    return result;\n  }\n\n  exports.htmlAstToRender3Ast = htmlAstToRender3Ast;\n\n  var HtmlAstToIvyAst =\n  /** @class */\n  function () {\n    function HtmlAstToIvyAst(bindingParser, options) {\n      this.bindingParser = bindingParser;\n      this.options = options;\n      this.errors = [];\n      this.styles = [];\n      this.styleUrls = [];\n      this.ngContentSelectors = []; // This array will be populated if `Render3ParseOptions['collectCommentNodes']` is true\n\n      this.commentNodes = [];\n      this.inI18nBlock = false;\n    } // HTML visitor\n\n\n    HtmlAstToIvyAst.prototype.visitElement = function (element) {\n      var e_1, _a;\n\n      var _this = this;\n\n      var isI18nRootElement = util_1.isI18nRootNode(element.i18n);\n\n      if (isI18nRootElement) {\n        if (this.inI18nBlock) {\n          this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);\n        }\n\n        this.inI18nBlock = true;\n      }\n\n      var preparsedElement = template_preparser_1.preparseElement(element);\n\n      if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT) {\n        return null;\n      } else if (preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE) {\n        var contents = textContents(element);\n\n        if (contents !== null) {\n          this.styles.push(contents);\n        }\n\n        return null;\n      } else if (preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET && style_url_resolver_1.isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n        this.styleUrls.push(preparsedElement.hrefAttr);\n        return null;\n      } // Whether the element is a `<ng-template>`\n\n\n      var isTemplateElement = tags_1.isNgTemplate(element.name);\n      var parsedProperties = [];\n      var boundEvents = [];\n      var variables = [];\n      var references = [];\n      var attributes = [];\n      var i18nAttrsMeta = {};\n      var templateParsedProperties = [];\n      var templateVariables = []; // Whether the element has any *-attribute\n\n      var elementHasInlineTemplate = false;\n\n      try {\n        for (var _b = tslib_1.__values(element.attrs), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var attribute = _c.value;\n          var hasBinding = false;\n          var normalizedName = normalizeAttributeName(attribute.name); // `*attr` defines template bindings\n\n          var isTemplateBinding = false;\n\n          if (attribute.i18n) {\n            i18nAttrsMeta[attribute.name] = attribute.i18n;\n          }\n\n          if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n            // *-attributes\n            if (elementHasInlineTemplate) {\n              this.reportError(\"Can't have multiple template bindings on one element. Use only one attribute prefixed with *\", attribute.sourceSpan);\n            }\n\n            isTemplateBinding = true;\n            elementHasInlineTemplate = true;\n            var templateValue = attribute.value;\n            var templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n            var parsedVariables = [];\n            var absoluteValueOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : // If there is no value span the attribute does not have a value, like `attr` in\n            //`<div attr></div>`. In this case, point to one character beyond the last character of\n            // the attribute name.\n            attribute.sourceSpan.start.offset + attribute.name.length;\n            this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true\n            /* isIvyAst */\n            );\n            templateVariables.push.apply(templateVariables, tslib_1.__spread(parsedVariables.map(function (v) {\n              return new t.Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan);\n            })));\n          } else {\n            // Check for variables, events, property bindings, interpolation\n            hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n          }\n\n          if (!hasBinding && !isTemplateBinding) {\n            // don't include the bindings as attributes as well in the AST\n            attributes.push(this.visitAttribute(attribute));\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      var children = html.visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);\n      var parsedElement;\n\n      if (preparsedElement.type === template_preparser_1.PreparsedElementType.NG_CONTENT) {\n        // `<ng-content>`\n        if (element.children && !element.children.every(function (node) {\n          return isEmptyTextNode(node) || isCommentNode(node);\n        })) {\n          this.reportError(\"<ng-content> element cannot have content.\", element.sourceSpan);\n        }\n\n        var selector = preparsedElement.selectAttr;\n        var attrs = element.attrs.map(function (attr) {\n          return _this.visitAttribute(attr);\n        });\n        parsedElement = new t.Content(selector, attrs, element.sourceSpan, element.i18n);\n        this.ngContentSelectors.push(selector);\n      } else if (isTemplateElement) {\n        // `<ng-template>`\n        var attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n        parsedElement = new t.Template(element.name, attributes, attrs.bound, boundEvents, [\n          /* no template attributes */\n        ], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n      } else {\n        var attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n        parsedElement = new t.Element(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n      }\n\n      if (elementHasInlineTemplate) {\n        // If this node is an inline-template (e.g. has *ngFor) then we need to create a template\n        // node that contains this node.\n        // Moreover, if the node is an element, then we need to hoist its attributes to the template\n        // node for matching against content projection selectors.\n        var attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);\n        var templateAttrs_1 = [];\n        attrs.literal.forEach(function (attr) {\n          return templateAttrs_1.push(attr);\n        });\n        attrs.bound.forEach(function (attr) {\n          return templateAttrs_1.push(attr);\n        });\n        var hoistedAttrs = parsedElement instanceof t.Element ? {\n          attributes: parsedElement.attributes,\n          inputs: parsedElement.inputs,\n          outputs: parsedElement.outputs\n        } : {\n          attributes: [],\n          inputs: [],\n          outputs: []\n        }; // For <ng-template>s with structural directives on them, avoid passing i18n information to\n        // the wrapping template to prevent unnecessary i18n instructions from being generated. The\n        // necessary i18n meta information will be extracted from child elements.\n\n        var i18n_1 = isTemplateElement && isI18nRootElement ? undefined : element.i18n; // TODO(pk): test for this case\n\n        parsedElement = new t.Template(parsedElement.name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs_1, [parsedElement], [\n          /* no references */\n        ], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n_1);\n      }\n\n      if (isI18nRootElement) {\n        this.inI18nBlock = false;\n      }\n\n      return parsedElement;\n    };\n\n    HtmlAstToIvyAst.prototype.visitAttribute = function (attribute) {\n      return new t.TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n    };\n\n    HtmlAstToIvyAst.prototype.visitText = function (text) {\n      return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);\n    };\n\n    HtmlAstToIvyAst.prototype.visitExpansion = function (expansion) {\n      var _this = this;\n\n      if (!expansion.i18n) {\n        // do not generate Icu in case it was created\n        // outside of i18n block in a template\n        return null;\n      }\n\n      if (!util_1.isI18nRootNode(expansion.i18n)) {\n        throw new Error(\"Invalid type \\\"\" + expansion.i18n.constructor + \"\\\" for \\\"i18n\\\" property of \" + expansion.sourceSpan.toString() + \". Expected a \\\"Message\\\"\");\n      }\n\n      var message = expansion.i18n;\n      var vars = {};\n      var placeholders = {}; // extract VARs from ICUs - we process them separately while\n      // assembling resulting message via goog.getMsg function, since\n      // we need to pass them to top-level goog.getMsg call\n\n      Object.keys(message.placeholders).forEach(function (key) {\n        var value = message.placeholders[key];\n\n        if (key.startsWith(util_1.I18N_ICU_VAR_PREFIX)) {\n          // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.\n          // `{count, select , ...}`), these spaces are also included into the key names in ICU vars\n          // (e.g. \"VAR_SELECT \"). These trailing spaces are not desirable, since they will later be\n          // converted into `_` symbols while normalizing placeholder names, which might lead to\n          // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).\n          var formattedKey = key.trim();\n\n          var ast = _this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);\n\n          vars[formattedKey] = new t.BoundText(ast, value.sourceSpan);\n        } else {\n          placeholders[key] = _this._visitTextWithInterpolation(value.text, value.sourceSpan);\n        }\n      });\n      return new t.Icu(vars, placeholders, expansion.sourceSpan, message);\n    };\n\n    HtmlAstToIvyAst.prototype.visitExpansionCase = function (expansionCase) {\n      return null;\n    };\n\n    HtmlAstToIvyAst.prototype.visitComment = function (comment) {\n      if (this.options.collectCommentNodes) {\n        this.commentNodes.push(new t.Comment(comment.value || '', comment.sourceSpan));\n      }\n\n      return null;\n    }; // convert view engine `ParsedProperty` to a format suitable for IVY\n\n\n    HtmlAstToIvyAst.prototype.extractAttributes = function (elementName, properties, i18nPropsMeta) {\n      var _this = this;\n\n      var bound = [];\n      var literal = [];\n      properties.forEach(function (prop) {\n        var i18n = i18nPropsMeta[prop.name];\n\n        if (prop.isLiteral) {\n          literal.push(new t.TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));\n        } else {\n          // Note that validation is skipped and property mapping is disabled\n          // due to the fact that we need to make sure a given prop is not an\n          // input of a directive and directive matching happens at runtime.\n          var bep = _this.bindingParser.createBoundElementProperty(elementName, prop,\n          /* skipValidation */\n          true,\n          /* mapPropertyName */\n          false);\n\n          bound.push(t.BoundAttribute.fromBoundElementProperty(bep, i18n));\n        }\n      });\n      return {\n        bound: bound,\n        literal: literal\n      };\n    };\n\n    HtmlAstToIvyAst.prototype.parseAttribute = function (isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {\n      var name = normalizeAttributeName(attribute.name);\n      var value = attribute.value;\n      var srcSpan = attribute.sourceSpan;\n      var absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;\n\n      function createKeySpan(srcSpan, prefix, identifier) {\n        // We need to adjust the start location for the keySpan to account for the removed 'data-'\n        // prefix from `normalizeAttributeName`.\n        var normalizationAdjustment = attribute.name.length - name.length;\n        var keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\n        var keySpanEnd = keySpanStart.moveBy(identifier.length);\n        return new parse_util_1.ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);\n      }\n\n      var bindParts = name.match(BIND_NAME_REGEXP);\n\n      if (bindParts) {\n        if (bindParts[KW_BIND_IDX] != null) {\n          var identifier = bindParts[IDENT_KW_IDX];\n          var keySpan_1 = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);\n          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan_1);\n        } else if (bindParts[KW_LET_IDX]) {\n          if (isTemplateElement) {\n            var identifier = bindParts[IDENT_KW_IDX];\n            var keySpan_2 = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);\n            this.parseVariable(identifier, value, srcSpan, keySpan_2, attribute.valueSpan, variables);\n          } else {\n            this.reportError(\"\\\"let-\\\" is only supported on ng-template elements.\", srcSpan);\n          }\n        } else if (bindParts[KW_REF_IDX]) {\n          var identifier = bindParts[IDENT_KW_IDX];\n          var keySpan_3 = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);\n          this.parseReference(identifier, value, srcSpan, keySpan_3, attribute.valueSpan, references);\n        } else if (bindParts[KW_ON_IDX]) {\n          var events = [];\n          var identifier = bindParts[IDENT_KW_IDX];\n          var keySpan_4 = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);\n          this.bindingParser.parseEvent(identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan_4);\n          addEvents(events, boundEvents);\n        } else if (bindParts[KW_BINDON_IDX]) {\n          var identifier = bindParts[IDENT_KW_IDX];\n          var keySpan_5 = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);\n          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan_5);\n          this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan_5);\n        } else if (bindParts[KW_AT_IDX]) {\n          var keySpan_6 = createKeySpan(srcSpan, '', name);\n          this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan_6);\n        }\n\n        return true;\n      } // We didn't see a kw-prefixed property binding, but we have not yet checked\n      // for the []/()/[()] syntax.\n\n\n      var delims = null;\n\n      if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\n        delims = BINDING_DELIMS.BANANA_BOX;\n      } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\n        delims = BINDING_DELIMS.PROPERTY;\n      } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\n        delims = BINDING_DELIMS.EVENT;\n      }\n\n      if (delims !== null && // NOTE: older versions of the parser would match a start/end delimited\n      // binding iff the property name was terminated by the ending delimiter\n      // and the identifier in the binding was non-empty.\n      // TODO(ayazhafiz): update this to handle malformed bindings.\n      name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {\n        var identifier = name.substring(delims.start.length, name.length - delims.end.length);\n        var keySpan_7 = createKeySpan(srcSpan, delims.start, identifier);\n\n        if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\n          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan_7);\n          this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan_7);\n        } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\n          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan_7);\n        } else {\n          var events = [];\n          this.bindingParser.parseEvent(identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan_7);\n          addEvents(events, boundEvents);\n        }\n\n        return true;\n      } // No explicit binding found.\n\n\n      var keySpan = createKeySpan(srcSpan, ''\n      /* prefix */\n      , name);\n      var hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n      return hasBinding;\n    };\n\n    HtmlAstToIvyAst.prototype._visitTextWithInterpolation = function (value, sourceSpan, i18n) {\n      var valueNoNgsp = html_whitespaces_1.replaceNgsp(value);\n      var expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);\n      return expr ? new t.BoundText(expr, sourceSpan, i18n) : new t.Text(valueNoNgsp, sourceSpan);\n    };\n\n    HtmlAstToIvyAst.prototype.parseVariable = function (identifier, value, sourceSpan, keySpan, valueSpan, variables) {\n      if (identifier.indexOf('-') > -1) {\n        this.reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n      } else if (identifier.length === 0) {\n        this.reportError(\"Variable does not have a name\", sourceSpan);\n      }\n\n      variables.push(new t.Variable(identifier, value, sourceSpan, keySpan, valueSpan));\n    };\n\n    HtmlAstToIvyAst.prototype.parseReference = function (identifier, value, sourceSpan, keySpan, valueSpan, references) {\n      if (identifier.indexOf('-') > -1) {\n        this.reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n      } else if (identifier.length === 0) {\n        this.reportError(\"Reference does not have a name\", sourceSpan);\n      } else if (references.some(function (reference) {\n        return reference.name === identifier;\n      })) {\n        this.reportError(\"Reference \\\"#\" + identifier + \"\\\" is defined more than once\", sourceSpan);\n      }\n\n      references.push(new t.Reference(identifier, value, sourceSpan, keySpan, valueSpan));\n    };\n\n    HtmlAstToIvyAst.prototype.parseAssignmentEvent = function (name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan) {\n      var events = [];\n      this.bindingParser.parseEvent(name + \"Change\", expression + \"=$event\", sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);\n      addEvents(events, boundEvents);\n    };\n\n    HtmlAstToIvyAst.prototype.reportError = function (message, sourceSpan, level) {\n      if (level === void 0) {\n        level = parse_util_1.ParseErrorLevel.ERROR;\n      }\n\n      this.errors.push(new parse_util_1.ParseError(sourceSpan, message, level));\n    };\n\n    return HtmlAstToIvyAst;\n  }();\n\n  var NonBindableVisitor =\n  /** @class */\n  function () {\n    function NonBindableVisitor() {}\n\n    NonBindableVisitor.prototype.visitElement = function (ast) {\n      var preparsedElement = template_preparser_1.preparseElement(ast);\n\n      if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT || preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE || preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET) {\n        // Skipping <script> for security reasons\n        // Skipping <style> and stylesheets as we already processed them\n        // in the StyleCompiler\n        return null;\n      }\n\n      var children = html.visitAll(this, ast.children, null);\n      return new t.Element(ast.name, html.visitAll(this, ast.attrs),\n      /* inputs */\n      [],\n      /* outputs */\n      [], children,\n      /* references */\n      [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);\n    };\n\n    NonBindableVisitor.prototype.visitComment = function (comment) {\n      return null;\n    };\n\n    NonBindableVisitor.prototype.visitAttribute = function (attribute) {\n      return new t.TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n    };\n\n    NonBindableVisitor.prototype.visitText = function (text) {\n      return new t.Text(text.value, text.sourceSpan);\n    };\n\n    NonBindableVisitor.prototype.visitExpansion = function (expansion) {\n      return null;\n    };\n\n    NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase) {\n      return null;\n    };\n\n    return NonBindableVisitor;\n  }();\n\n  var NON_BINDABLE_VISITOR = new NonBindableVisitor();\n\n  function normalizeAttributeName(attrName) {\n    return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n  }\n\n  function addEvents(events, boundEvents) {\n    boundEvents.push.apply(boundEvents, tslib_1.__spread(events.map(function (e) {\n      return t.BoundEvent.fromParsedEvent(e);\n    })));\n  }\n\n  function isEmptyTextNode(node) {\n    return node instanceof html.Text && node.value.trim().length == 0;\n  }\n\n  function isCommentNode(node) {\n    return node instanceof html.Comment;\n  }\n\n  function textContents(node) {\n    if (node.children.length !== 1 || !(node.children[0] instanceof html.Text)) {\n      return null;\n    } else {\n      return node.children[0].value;\n    }\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/render3/r3_template_transform.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParsedEvent, ParsedProperty, ParsedVariable} from '../expression_parser/ast';\nimport * as i18n from '../i18n/i18n_ast';\nimport * as html from '../ml_parser/ast';\nimport {replaceNgsp} from '../ml_parser/html_whitespaces';\nimport {isNgTemplate} from '../ml_parser/tags';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {isStyleUrlResolvable} from '../style_url_resolver';\nimport {BindingParser} from '../template_parser/binding_parser';\nimport {PreparsedElementType, preparseElement} from '../template_parser/template_preparser';\n\nimport * as t from './r3_ast';\nimport {I18N_ICU_VAR_PREFIX, isI18nRootNode} from './view/i18n/util';\n\nconst BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;\n\n// Group 1 = \"bind-\"\nconst KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst IDENT_KW_IDX = 7;\n\nconst BINDING_DELIMS = {\n  BANANA_BOX: {start: '[(', end: ')]'},\n  PROPERTY: {start: '[', end: ']'},\n  EVENT: {start: '(', end: ')'},\n};\n\nconst TEMPLATE_ATTR_PREFIX = '*';\n\n// Result of the html AST to Ivy AST transformation\nexport interface Render3ParseResult {\n  nodes: t.Node[];\n  errors: ParseError[];\n  styles: string[];\n  styleUrls: string[];\n  ngContentSelectors: string[];\n  // Will be defined if `Render3ParseOptions['collectCommentNodes']` is true\n  commentNodes?: t.Comment[];\n}\n\ninterface Render3ParseOptions {\n  collectCommentNodes: boolean;\n}\n\nexport function htmlAstToRender3Ast(\n    htmlNodes: html.Node[], bindingParser: BindingParser,\n    options: Render3ParseOptions): Render3ParseResult {\n  const transformer = new HtmlAstToIvyAst(bindingParser, options);\n  const ivyNodes = html.visitAll(transformer, htmlNodes);\n\n  // Errors might originate in either the binding parser or the html to ivy transformer\n  const allErrors = bindingParser.errors.concat(transformer.errors);\n\n  const result: Render3ParseResult = {\n    nodes: ivyNodes,\n    errors: allErrors,\n    styleUrls: transformer.styleUrls,\n    styles: transformer.styles,\n    ngContentSelectors: transformer.ngContentSelectors\n  };\n  if (options.collectCommentNodes) {\n    result.commentNodes = transformer.commentNodes;\n  }\n  return result;\n}\n\nclass HtmlAstToIvyAst implements html.Visitor {\n  errors: ParseError[] = [];\n  styles: string[] = [];\n  styleUrls: string[] = [];\n  ngContentSelectors: string[] = [];\n  // This array will be populated if `Render3ParseOptions['collectCommentNodes']` is true\n  commentNodes: t.Comment[] = [];\n  private inI18nBlock: boolean = false;\n\n  constructor(private bindingParser: BindingParser, private options: Render3ParseOptions) {}\n\n  // HTML visitor\n  visitElement(element: html.Element): t.Node|null {\n    const isI18nRootElement = isI18nRootNode(element.i18n);\n    if (isI18nRootElement) {\n      if (this.inI18nBlock) {\n        this.reportError(\n            'Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.',\n            element.sourceSpan);\n      }\n      this.inI18nBlock = true;\n    }\n    const preparsedElement = preparseElement(element);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n      return null;\n    } else if (preparsedElement.type === PreparsedElementType.STYLE) {\n      const contents = textContents(element);\n      if (contents !== null) {\n        this.styles.push(contents);\n      }\n      return null;\n    } else if (\n        preparsedElement.type === PreparsedElementType.STYLESHEET &&\n        isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n      this.styleUrls.push(preparsedElement.hrefAttr);\n      return null;\n    }\n\n    // Whether the element is a `<ng-template>`\n    const isTemplateElement = isNgTemplate(element.name);\n\n    const parsedProperties: ParsedProperty[] = [];\n    const boundEvents: t.BoundEvent[] = [];\n    const variables: t.Variable[] = [];\n    const references: t.Reference[] = [];\n    const attributes: t.TextAttribute[] = [];\n    const i18nAttrsMeta: {[key: string]: i18n.I18nMeta} = {};\n\n    const templateParsedProperties: ParsedProperty[] = [];\n    const templateVariables: t.Variable[] = [];\n\n    // Whether the element has any *-attribute\n    let elementHasInlineTemplate = false;\n\n    for (const attribute of element.attrs) {\n      let hasBinding = false;\n      const normalizedName = normalizeAttributeName(attribute.name);\n\n      // `*attr` defines template bindings\n      let isTemplateBinding = false;\n\n      if (attribute.i18n) {\n        i18nAttrsMeta[attribute.name] = attribute.i18n;\n      }\n\n      if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n        // *-attributes\n        if (elementHasInlineTemplate) {\n          this.reportError(\n              `Can't have multiple template bindings on one element. Use only one attribute prefixed with *`,\n              attribute.sourceSpan);\n        }\n        isTemplateBinding = true;\n        elementHasInlineTemplate = true;\n        const templateValue = attribute.value;\n        const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n\n        const parsedVariables: ParsedVariable[] = [];\n        const absoluteValueOffset = attribute.valueSpan ?\n            attribute.valueSpan.start.offset :\n            // If there is no value span the attribute does not have a value, like `attr` in\n            //`<div attr></div>`. In this case, point to one character beyond the last character of\n            // the attribute name.\n            attribute.sourceSpan.start.offset + attribute.name.length;\n\n        this.bindingParser.parseInlineTemplateBinding(\n            templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [],\n            templateParsedProperties, parsedVariables, true /* isIvyAst */);\n        templateVariables.push(...parsedVariables.map(\n            v => new t.Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));\n      } else {\n        // Check for variables, events, property bindings, interpolation\n        hasBinding = this.parseAttribute(\n            isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n      }\n\n      if (!hasBinding && !isTemplateBinding) {\n        // don't include the bindings as attributes as well in the AST\n        attributes.push(this.visitAttribute(attribute));\n      }\n    }\n\n    const children: t.Node[] =\n        html.visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);\n\n    let parsedElement: t.Node|undefined;\n    if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n      // `<ng-content>`\n      if (element.children &&\n          !element.children.every(\n              (node: html.Node) => isEmptyTextNode(node) || isCommentNode(node))) {\n        this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);\n      }\n      const selector = preparsedElement.selectAttr;\n      const attrs: t.TextAttribute[] = element.attrs.map(attr => this.visitAttribute(attr));\n      parsedElement = new t.Content(selector, attrs, element.sourceSpan, element.i18n);\n\n      this.ngContentSelectors.push(selector);\n    } else if (isTemplateElement) {\n      // `<ng-template>`\n      const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n\n      parsedElement = new t.Template(\n          element.name, attributes, attrs.bound, boundEvents, [/* no template attributes */],\n          children, references, variables, element.sourceSpan, element.startSourceSpan,\n          element.endSourceSpan, element.i18n);\n    } else {\n      const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n      parsedElement = new t.Element(\n          element.name, attributes, attrs.bound, boundEvents, children, references,\n          element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n    }\n\n    if (elementHasInlineTemplate) {\n      // If this node is an inline-template (e.g. has *ngFor) then we need to create a template\n      // node that contains this node.\n      // Moreover, if the node is an element, then we need to hoist its attributes to the template\n      // node for matching against content projection selectors.\n      const attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);\n      const templateAttrs: (t.TextAttribute|t.BoundAttribute)[] = [];\n      attrs.literal.forEach(attr => templateAttrs.push(attr));\n      attrs.bound.forEach(attr => templateAttrs.push(attr));\n      const hoistedAttrs = parsedElement instanceof t.Element ?\n          {\n            attributes: parsedElement.attributes,\n            inputs: parsedElement.inputs,\n            outputs: parsedElement.outputs,\n          } :\n          {attributes: [], inputs: [], outputs: []};\n\n      // For <ng-template>s with structural directives on them, avoid passing i18n information to\n      // the wrapping template to prevent unnecessary i18n instructions from being generated. The\n      // necessary i18n meta information will be extracted from child elements.\n      const i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n;\n\n      // TODO(pk): test for this case\n      parsedElement = new t.Template(\n          (parsedElement as t.Element | t.Content).name, hoistedAttrs.attributes,\n          hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement],\n          [/* no references */], templateVariables, element.sourceSpan, element.startSourceSpan,\n          element.endSourceSpan, i18n);\n    }\n    if (isI18nRootElement) {\n      this.inI18nBlock = false;\n    }\n    return parsedElement;\n  }\n\n  visitAttribute(attribute: html.Attribute): t.TextAttribute {\n    return new t.TextAttribute(\n        attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan,\n        attribute.valueSpan, attribute.i18n);\n  }\n\n  visitText(text: html.Text): t.Node {\n    return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);\n  }\n\n  visitExpansion(expansion: html.Expansion): t.Icu|null {\n    if (!expansion.i18n) {\n      // do not generate Icu in case it was created\n      // outside of i18n block in a template\n      return null;\n    }\n    if (!isI18nRootNode(expansion.i18n)) {\n      throw new Error(`Invalid type \"${expansion.i18n.constructor}\" for \"i18n\" property of ${\n          expansion.sourceSpan.toString()}. Expected a \"Message\"`);\n    }\n    const message = expansion.i18n;\n    const vars: {[name: string]: t.BoundText} = {};\n    const placeholders: {[name: string]: t.Text|t.BoundText} = {};\n    // extract VARs from ICUs - we process them separately while\n    // assembling resulting message via goog.getMsg function, since\n    // we need to pass them to top-level goog.getMsg call\n    Object.keys(message.placeholders).forEach(key => {\n      const value = message.placeholders[key];\n      if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n        // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.\n        // `{count, select , ...}`), these spaces are also included into the key names in ICU vars\n        // (e.g. \"VAR_SELECT \"). These trailing spaces are not desirable, since they will later be\n        // converted into `_` symbols while normalizing placeholder names, which might lead to\n        // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).\n        const formattedKey = key.trim();\n\n        const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);\n\n        vars[formattedKey] = new t.BoundText(ast, value.sourceSpan);\n      } else {\n        placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan);\n      }\n    });\n    return new t.Icu(vars, placeholders, expansion.sourceSpan, message);\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase): null {\n    return null;\n  }\n\n  visitComment(comment: html.Comment): null {\n    if (this.options.collectCommentNodes) {\n      this.commentNodes.push(new t.Comment(comment.value || '', comment.sourceSpan));\n    }\n    return null;\n  }\n\n  // convert view engine `ParsedProperty` to a format suitable for IVY\n  private extractAttributes(\n      elementName: string, properties: ParsedProperty[],\n      i18nPropsMeta: {[key: string]: i18n.I18nMeta}):\n      {bound: t.BoundAttribute[], literal: t.TextAttribute[]} {\n    const bound: t.BoundAttribute[] = [];\n    const literal: t.TextAttribute[] = [];\n\n    properties.forEach(prop => {\n      const i18n = i18nPropsMeta[prop.name];\n      if (prop.isLiteral) {\n        literal.push(new t.TextAttribute(\n            prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan,\n            i18n));\n      } else {\n        // Note that validation is skipped and property mapping is disabled\n        // due to the fact that we need to make sure a given prop is not an\n        // input of a directive and directive matching happens at runtime.\n        const bep = this.bindingParser.createBoundElementProperty(\n            elementName, prop, /* skipValidation */ true, /* mapPropertyName */ false);\n        bound.push(t.BoundAttribute.fromBoundElementProperty(bep, i18n));\n      }\n    });\n\n    return {bound, literal};\n  }\n\n  private parseAttribute(\n      isTemplateElement: boolean, attribute: html.Attribute, matchableAttributes: string[][],\n      parsedProperties: ParsedProperty[], boundEvents: t.BoundEvent[], variables: t.Variable[],\n      references: t.Reference[]) {\n    const name = normalizeAttributeName(attribute.name);\n    const value = attribute.value;\n    const srcSpan = attribute.sourceSpan;\n    const absoluteOffset =\n        attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;\n\n    function createKeySpan(srcSpan: ParseSourceSpan, prefix: string, identifier: string) {\n      // We need to adjust the start location for the keySpan to account for the removed 'data-'\n      // prefix from `normalizeAttributeName`.\n      const normalizationAdjustment = attribute.name.length - name.length;\n      const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\n      const keySpanEnd = keySpanStart.moveBy(identifier.length);\n      return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);\n    }\n\n    const bindParts = name.match(BIND_NAME_REGEXP);\n\n    if (bindParts) {\n      if (bindParts[KW_BIND_IDX] != null) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(\n            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n            matchableAttributes, parsedProperties, keySpan);\n\n      } else if (bindParts[KW_LET_IDX]) {\n        if (isTemplateElement) {\n          const identifier = bindParts[IDENT_KW_IDX];\n          const keySpan = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);\n          this.parseVariable(identifier, value, srcSpan, keySpan, attribute.valueSpan, variables);\n        } else {\n          this.reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n        }\n\n      } else if (bindParts[KW_REF_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);\n        this.parseReference(identifier, value, srcSpan, keySpan, attribute.valueSpan, references);\n      } else if (bindParts[KW_ON_IDX]) {\n        const events: ParsedEvent[] = [];\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);\n        this.bindingParser.parseEvent(\n            identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events,\n            keySpan);\n        addEvents(events, boundEvents);\n      } else if (bindParts[KW_BINDON_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(\n            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n            matchableAttributes, parsedProperties, keySpan);\n        this.parseAssignmentEvent(\n            identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents,\n            keySpan);\n      } else if (bindParts[KW_AT_IDX]) {\n        const keySpan = createKeySpan(srcSpan, '', name);\n        this.bindingParser.parseLiteralAttr(\n            name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes,\n            parsedProperties, keySpan);\n      }\n      return true;\n    }\n\n    // We didn't see a kw-prefixed property binding, but we have not yet checked\n    // for the []/()/[()] syntax.\n    let delims: {start: string, end: string}|null = null;\n    if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\n      delims = BINDING_DELIMS.BANANA_BOX;\n    } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\n      delims = BINDING_DELIMS.PROPERTY;\n    } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\n      delims = BINDING_DELIMS.EVENT;\n    }\n    if (delims !== null &&\n        // NOTE: older versions of the parser would match a start/end delimited\n        // binding iff the property name was terminated by the ending delimiter\n        // and the identifier in the binding was non-empty.\n        // TODO(ayazhafiz): update this to handle malformed bindings.\n        name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {\n      const identifier = name.substring(delims.start.length, name.length - delims.end.length);\n      const keySpan = createKeySpan(srcSpan, delims.start, identifier);\n      if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\n        this.bindingParser.parsePropertyBinding(\n            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n            matchableAttributes, parsedProperties, keySpan);\n        this.parseAssignmentEvent(\n            identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents,\n            keySpan);\n      } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\n        this.bindingParser.parsePropertyBinding(\n            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n            matchableAttributes, parsedProperties, keySpan);\n      } else {\n        const events: ParsedEvent[] = [];\n        this.bindingParser.parseEvent(\n            identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events,\n            keySpan);\n        addEvents(events, boundEvents);\n      }\n\n      return true;\n    }\n\n    // No explicit binding found.\n    const keySpan = createKeySpan(srcSpan, '' /* prefix */, name);\n    const hasBinding = this.bindingParser.parsePropertyInterpolation(\n        name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n    return hasBinding;\n  }\n\n  private _visitTextWithInterpolation(\n      value: string, sourceSpan: ParseSourceSpan, i18n?: i18n.I18nMeta): t.Text|t.BoundText {\n    const valueNoNgsp = replaceNgsp(value);\n    const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);\n    return expr ? new t.BoundText(expr, sourceSpan, i18n) : new t.Text(valueNoNgsp, sourceSpan);\n  }\n\n  private parseVariable(\n      identifier: string, value: string, sourceSpan: ParseSourceSpan, keySpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, variables: t.Variable[]) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Variable does not have a name`, sourceSpan);\n    }\n\n    variables.push(new t.Variable(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n\n  private parseReference(\n      identifier: string, value: string, sourceSpan: ParseSourceSpan, keySpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, references: t.Reference[]) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Reference does not have a name`, sourceSpan);\n    } else if (references.some(reference => reference.name === identifier)) {\n      this.reportError(`Reference \"#${identifier}\" is defined more than once`, sourceSpan);\n    }\n\n    references.push(new t.Reference(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n\n  private parseAssignmentEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      boundEvents: t.BoundEvent[], keySpan: ParseSourceSpan) {\n    const events: ParsedEvent[] = [];\n    this.bindingParser.parseEvent(\n        `${name}Change`, `${expression}=$event`, sourceSpan, valueSpan || sourceSpan,\n        targetMatchableAttrs, events, keySpan);\n    addEvents(events, boundEvents);\n  }\n\n  private reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n}\n\nclass NonBindableVisitor implements html.Visitor {\n  visitElement(ast: html.Element): t.Element|null {\n    const preparsedElement = preparseElement(ast);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n        preparsedElement.type === PreparsedElementType.STYLE ||\n        preparsedElement.type === PreparsedElementType.STYLESHEET) {\n      // Skipping <script> for security reasons\n      // Skipping <style> and stylesheets as we already processed them\n      // in the StyleCompiler\n      return null;\n    }\n\n    const children: t.Node[] = html.visitAll(this, ast.children, null);\n    return new t.Element(\n        ast.name, html.visitAll(this, ast.attrs) as t.TextAttribute[],\n        /* inputs */[], /* outputs */[], children, /* references */[], ast.sourceSpan,\n        ast.startSourceSpan, ast.endSourceSpan);\n  }\n\n  visitComment(comment: html.Comment): any {\n    return null;\n  }\n\n  visitAttribute(attribute: html.Attribute): t.TextAttribute {\n    return new t.TextAttribute(\n        attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan,\n        attribute.valueSpan, attribute.i18n);\n  }\n\n  visitText(text: html.Text): t.Text {\n    return new t.Text(text.value, text.sourceSpan);\n  }\n\n  visitExpansion(expansion: html.Expansion): any {\n    return null;\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase): any {\n    return null;\n  }\n}\n\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\n\nfunction normalizeAttributeName(attrName: string): string {\n  return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\n\nfunction addEvents(events: ParsedEvent[], boundEvents: t.BoundEvent[]) {\n  boundEvents.push(...events.map(e => t.BoundEvent.fromParsedEvent(e)));\n}\n\nfunction isEmptyTextNode(node: html.Node): boolean {\n  return node instanceof html.Text && node.value.trim().length == 0;\n}\n\nfunction isCommentNode(node: html.Node): boolean {\n  return node instanceof html.Comment;\n}\n\nfunction textContents(node: html.Element): string|null {\n  if (node.children.length !== 1 || !(node.children[0] instanceof html.Text)) {\n    return null;\n  } else {\n    return (node.children[0] as html.Text).value;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}