{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar picomatch = require('picomatch');\n\nvar normalizePath = require('normalize-path');\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\n\n\nvar BANG = '!';\nvar DEFAULT_OPTIONS = {\n  returnIndex: false\n};\n\nvar arrify = function arrify(item) {\n  return Array.isArray(item) ? item : [item];\n};\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\n\n\nvar createPattern = function createPattern(matcher, options) {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n\n  if (typeof matcher === 'string') {\n    var glob = picomatch(matcher, options);\n    return function (string) {\n      return matcher === string || glob(string);\n    };\n  }\n\n  if (matcher instanceof RegExp) {\n    return function (string) {\n      return matcher.test(string);\n    };\n  }\n\n  return function (string) {\n    return false;\n  };\n};\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\n\n\nvar matchPatterns = function matchPatterns(patterns, negPatterns, args, returnIndex) {\n  var isList = Array.isArray(args);\n\n  var _path = isList ? args[0] : args;\n\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));\n  }\n\n  var path = normalizePath(_path);\n\n  for (var index = 0; index < negPatterns.length; index++) {\n    var nglob = negPatterns[index];\n\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  var applied = isList && [path].concat(args.slice(1));\n\n  for (var _index = 0; _index < patterns.length; _index++) {\n    var pattern = patterns[_index];\n\n    if (isList ? pattern.apply(void 0, _toConsumableArray(applied)) : pattern(path)) {\n      return returnIndex ? _index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\n\n\nvar anymatch = function anymatch(matchers, testString) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;\n\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n\n  var opts = typeof options === 'boolean' ? {\n    returnIndex: options\n  } : options;\n  var returnIndex = opts.returnIndex || false; // Early cache for matchers.\n\n  var mtchers = arrify(matchers);\n  var negatedGlobs = mtchers.filter(function (item) {\n    return typeof item === 'string' && item.charAt(0) === BANG;\n  }).map(function (item) {\n    return item.slice(1);\n  }).map(function (item) {\n    return picomatch(item, opts);\n  });\n  var patterns = mtchers.filter(function (item) {\n    return typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG;\n  }).map(function (matcher) {\n    return createPattern(matcher, opts);\n  });\n\n  if (testString == null) {\n    return function (testString) {\n      var ri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    };\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/anymatch/index.js"],"names":["Object","defineProperty","exports","value","picomatch","require","normalizePath","BANG","DEFAULT_OPTIONS","returnIndex","arrify","item","Array","isArray","createPattern","matcher","options","glob","string","RegExp","test","matchPatterns","patterns","negPatterns","args","isList","_path","TypeError","prototype","toString","call","path","index","length","nglob","applied","concat","slice","pattern","anymatch","matchers","testString","opts","mtchers","negatedGlobs","filter","charAt","map","ri","default","module"],"mappings":"AAAA;;;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAMC,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAzB;;AACA,IAAMC,aAAa,GAAGD,OAAO,CAAC,gBAAD,CAA7B;AAEA;AACA;AACA;AACA;AACA;;;AACA,IAAME,IAAI,GAAG,GAAb;AACA,IAAMC,eAAe,GAAG;AAACC,EAAAA,WAAW,EAAE;AAAd,CAAxB;;AACA,IAAMC,MAAM,GAAG,SAATA,MAAS,CAACC,IAAD;AAAA,SAAUC,KAAK,CAACC,OAAN,CAAcF,IAAd,IAAsBA,IAAtB,GAA6B,CAACA,IAAD,CAAvC;AAAA,CAAf;AAEA;AACA;AACA;AACA;AACA;;;AACA,IAAMG,aAAa,GAAG,SAAhBA,aAAgB,CAACC,OAAD,EAAUC,OAAV,EAAsB;AAC1C,MAAI,OAAOD,OAAP,KAAmB,UAAvB,EAAmC;AACjC,WAAOA,OAAP;AACD;;AACD,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,QAAME,IAAI,GAAGb,SAAS,CAACW,OAAD,EAAUC,OAAV,CAAtB;AACA,WAAO,UAACE,MAAD;AAAA,aAAYH,OAAO,KAAKG,MAAZ,IAAsBD,IAAI,CAACC,MAAD,CAAtC;AAAA,KAAP;AACD;;AACD,MAAIH,OAAO,YAAYI,MAAvB,EAA+B;AAC7B,WAAO,UAACD,MAAD;AAAA,aAAYH,OAAO,CAACK,IAAR,CAAaF,MAAb,CAAZ;AAAA,KAAP;AACD;;AACD,SAAO,UAACA,MAAD;AAAA,WAAY,KAAZ;AAAA,GAAP;AACD,CAZD;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMG,aAAa,GAAG,SAAhBA,aAAgB,CAACC,QAAD,EAAWC,WAAX,EAAwBC,IAAxB,EAA8Bf,WAA9B,EAA8C;AAClE,MAAMgB,MAAM,GAAGb,KAAK,CAACC,OAAN,CAAcW,IAAd,CAAf;;AACA,MAAME,KAAK,GAAGD,MAAM,GAAGD,IAAI,CAAC,CAAD,CAAP,GAAaA,IAAjC;;AACA,MAAI,CAACC,MAAD,IAAW,OAAOC,KAAP,KAAiB,QAAhC,EAA0C;AACxC,UAAM,IAAIC,SAAJ,CAAc,qDAClB3B,MAAM,CAAC4B,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BJ,KAA/B,CADI,CAAN;AAED;;AACD,MAAMK,IAAI,GAAGzB,aAAa,CAACoB,KAAD,CAA1B;;AAEA,OAAK,IAAIM,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGT,WAAW,CAACU,MAAxC,EAAgDD,KAAK,EAArD,EAAyD;AACvD,QAAME,KAAK,GAAGX,WAAW,CAACS,KAAD,CAAzB;;AACA,QAAIE,KAAK,CAACH,IAAD,CAAT,EAAiB;AACf,aAAOtB,WAAW,GAAG,CAAC,CAAJ,GAAQ,KAA1B;AACD;AACF;;AAED,MAAM0B,OAAO,GAAGV,MAAM,IAAI,CAACM,IAAD,EAAOK,MAAP,CAAcZ,IAAI,CAACa,KAAL,CAAW,CAAX,CAAd,CAA1B;;AACA,OAAK,IAAIL,MAAK,GAAG,CAAjB,EAAoBA,MAAK,GAAGV,QAAQ,CAACW,MAArC,EAA6CD,MAAK,EAAlD,EAAsD;AACpD,QAAMM,OAAO,GAAGhB,QAAQ,CAACU,MAAD,CAAxB;;AACA,QAAIP,MAAM,GAAGa,OAAO,MAAP,4BAAWH,OAAX,EAAH,GAAyBG,OAAO,CAACP,IAAD,CAA1C,EAAkD;AAChD,aAAOtB,WAAW,GAAGuB,MAAH,GAAW,IAA7B;AACD;AACF;;AAED,SAAOvB,WAAW,GAAG,CAAC,CAAJ,GAAQ,KAA1B;AACD,CAzBD;AA2BA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAM8B,QAAQ,GAAG,SAAXA,QAAW,CAACC,QAAD,EAAWC,UAAX,EAAqD;AAAA,MAA9BzB,OAA8B,uEAApBR,eAAoB;;AACpE,MAAIgC,QAAQ,IAAI,IAAhB,EAAsB;AACpB,UAAM,IAAIb,SAAJ,CAAc,kCAAd,CAAN;AACD;;AACD,MAAMe,IAAI,GAAG,OAAO1B,OAAP,KAAmB,SAAnB,GAA+B;AAACP,IAAAA,WAAW,EAAEO;AAAd,GAA/B,GAAwDA,OAArE;AACA,MAAMP,WAAW,GAAGiC,IAAI,CAACjC,WAAL,IAAoB,KAAxC,CALoE,CAOpE;;AACA,MAAMkC,OAAO,GAAGjC,MAAM,CAAC8B,QAAD,CAAtB;AACA,MAAMI,YAAY,GAAGD,OAAO,CACzBE,MADkB,CACX,UAAAlC,IAAI;AAAA,WAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,CAACmC,MAAL,CAAY,CAAZ,MAAmBvC,IAAnD;AAAA,GADO,EAElBwC,GAFkB,CAEd,UAAApC,IAAI;AAAA,WAAIA,IAAI,CAAC0B,KAAL,CAAW,CAAX,CAAJ;AAAA,GAFU,EAGlBU,GAHkB,CAGd,UAAApC,IAAI;AAAA,WAAIP,SAAS,CAACO,IAAD,EAAO+B,IAAP,CAAb;AAAA,GAHU,CAArB;AAIA,MAAMpB,QAAQ,GAAGqB,OAAO,CACrBE,MADc,CACP,UAAAlC,IAAI;AAAA,WAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA6B,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,CAACmC,MAAL,CAAY,CAAZ,MAAmBvC,IAAhF;AAAA,GADG,EAEdwC,GAFc,CAEV,UAAAhC,OAAO;AAAA,WAAID,aAAa,CAACC,OAAD,EAAU2B,IAAV,CAAjB;AAAA,GAFG,CAAjB;;AAIA,MAAID,UAAU,IAAI,IAAlB,EAAwB;AACtB,WAAO,UAACA,UAAD,EAA4B;AAAA,UAAfO,EAAe,uEAAV,KAAU;AACjC,UAAMvC,WAAW,GAAG,OAAOuC,EAAP,KAAc,SAAd,GAA0BA,EAA1B,GAA+B,KAAnD;AACA,aAAO3B,aAAa,CAACC,QAAD,EAAWsB,YAAX,EAAyBH,UAAzB,EAAqChC,WAArC,CAApB;AACD,KAHD;AAID;;AAED,SAAOY,aAAa,CAACC,QAAD,EAAWsB,YAAX,EAAyBH,UAAzB,EAAqChC,WAArC,CAApB;AACD,CAzBD;;AA2BA8B,QAAQ,CAACU,OAAT,GAAmBV,QAAnB;AACAW,MAAM,CAAChD,OAAP,GAAiBqC,QAAjB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nconst picomatch = require('picomatch');\nconst normalizePath = require('normalize-path');\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers\n    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG))\n    .map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;\n"]},"metadata":{},"sourceType":"script"}